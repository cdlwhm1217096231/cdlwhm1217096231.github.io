<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
        background: #1E92FB; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #1E92FB, 0 0 5px     #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #1E92FB;    /*上边框颜色*/
        border-left-color: #1E92FB;    /*左边框颜色*/
    }
</style>








<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="剑指Offer,">





  <link rel="alternate" href="/atom.xml" title="Curry_Coder的空间" type="application/atom+xml">






<meta name="description" content="1.滑动窗口的最大值（剑指offer原59题） 解题思路：其实是一个队列的问题，用一个队列去维护当前窗口中的所有元素；首先将超出窗口中的队头元素先删掉，然后将新的元素插入当前窗口中，插入时要判断新插入的元素与队尾元素的大小，如果队尾元素较小，则先删除队尾元素再插入。  123456789101112131415161718192021222324#include &amp;lt;iostream&amp;gt;#">
<meta name="keywords" content="剑指Offer">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指offer第二版题解(详细版)">
<meta property="og:url" content="https://cdlwhm1217096231.github.io/数据结构与算法/剑指offer第二版题解-详细版/index.html">
<meta property="og:site_name" content="Curry_Coder的空间">
<meta property="og:description" content="1.滑动窗口的最大值（剑指offer原59题） 解题思路：其实是一个队列的问题，用一个队列去维护当前窗口中的所有元素；首先将超出窗口中的队头元素先删掉，然后将新的元素插入当前窗口中，插入时要判断新插入的元素与队尾元素的大小，如果队尾元素较小，则先删除队尾元素再插入。  123456789101112131415161718192021222324#include &amp;lt;iostream&amp;gt;#">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-03-08T07:00:18.942Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="剑指offer第二版题解(详细版)">
<meta name="twitter:description" content="1.滑动窗口的最大值（剑指offer原59题） 解题思路：其实是一个队列的问题，用一个队列去维护当前窗口中的所有元素；首先将超出窗口中的队头元素先删掉，然后将新的元素插入当前窗口中，插入时要判断新插入的元素与队尾元素的大小，如果队尾元素较小，则先删除队尾元素再插入。  123456789101112131415161718192021222324#include &amp;lt;iostream&amp;gt;#">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://cdlwhm1217096231.github.io/数据结构与算法/剑指offer第二版题解-详细版/">





  <title>剑指offer第二版题解(详细版) | Curry_Coder的空间</title>
  








</head>
<script type="text/javascript" src="/lib/clipboard/clipboard.js"></script>
<script type="text/javascript" src="/js/src/custom.js"></script>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/cdlwhm1217096231" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Curry_Coder的空间</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">好好学习，天天向上！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-相册">
          <a href="/photos/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-camera"></i> <br>
            
            相册
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-categories" itemscope itemtype="http://schema.org/Article">
  
  
  


  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cdlwhm1217096231.github.io/数据结构与算法/剑指offer第二版题解-详细版/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Curry_Coder">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/curry.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Curry_Coder的空间">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">剑指offer第二版题解(详细版)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-09T16:22:44+08:00">
                2019-09-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-03-08T15:00:18+08:00">
                2020-03-08
              </time>
            
          </span>

          
            <span id="busuanzi_container_page_pv">  |  阅读量 <span id="busuanzi_value_page_pv"></span> 次</span>
          

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/数据结构与算法/剑指offer第二版题解-详细版/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/数据结构与算法/剑指offer第二版题解-详细版/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/数据结构与算法/剑指offer第二版题解-详细版/" class="leancloud_visitors" data-flag-title="剑指offer第二版题解(详细版)">
               <span class="post-meta-divider">|</span>
               
                 <span class="post-meta-item-text">热度&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
                 <span>℃</span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  18.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  85
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="1-滑动窗口的最大值（剑指offer原59题）"><a href="#1-滑动窗口的最大值（剑指offer原59题）" class="headerlink" title="1.滑动窗口的最大值（剑指offer原59题）"></a>1.滑动窗口的最大值（剑指offer原59题）</h4><ul>
<li>解题思路：<strong>其实是一个队列的问题，用一个队列去维护当前窗口中的所有元素；首先将超出窗口中的队头元素先删掉，然后将新的元素插入当前窗口中，插入时要判断新插入的元素与队尾元素的大小，如果队尾元素较小，则先删除队尾元素再插入</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)   <span class="comment">// k是窗口的大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; q.front() &lt;= i - k) q.pop_front();  <span class="comment">// 将已经划出窗口中的元素从队列中删除</span></span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; nums[q.back()] &lt;= nums[i])  nums.pop_back();   <span class="comment">// 如果在队尾插入的元素大于等于当前队尾的元素值，就可以删除队尾的元素！</span></span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) res.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！-与剑指offer60题有点差别！"><a href="#2-n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！-与剑指offer60题有点差别！" class="headerlink" title="2.n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！(与剑指offer60题有点差别！)"></a>2.n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！(与剑指offer60题有点差别！)</h4><ul>
<li><p>解题思路：每次扔骰子，最小值是1，最大值是6；所以扔n个骰子在地上后的，最小值就是n，最大值就是6*n。dfs()算法的思路：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs方法来解决：注意两点，第一是状态的表示是什么(从输出中来)？第二是按照什么顺序来计算第一步中的状态？</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numberOfDice(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt;= <span class="number">6</span> * n; i++) res.push_back(dfs(n, i));  <span class="comment">// dfs(n, s)表示的就是所要输出的结果；也就是每次求总和是s的情况下，一共投了n次骰子，一共有多少种方案</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> !sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res += dfs(n - <span class="number">1</span>, sum - i);  <span class="comment">// 热狗法：最后一次骰子点数已经确定时，则只需要计算前面投了n-1次骰子，总和是s-i的情况下，一共有多少种方案。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态规划算法dp的思路：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dp方法来解决：注意三点，第一是状态的表示是什么(从输出中来)？第二是如何计算第一步中的状态？第三是边界问题</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numberOfDice(<span class="keyword">int</span> n)&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n * <span class="number">6</span> + <span class="number">1</span>));  <span class="comment">// dp的状态表示</span></span><br><span class="line">       f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 当所有的骰子都没有扔出时，总和s=0时，只有一种方案；总和s=1, 2, 3, 4, ....都是不合法的！</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;  <span class="comment">// 先循环扔出去的次数</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i * <span class="number">6</span>; j++)&#123;      <span class="comment">// 再循环总和s是多少</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= min(j, <span class="number">6</span>); k++)&#123;  <span class="comment">// 枚举最后一次的点数是多少</span></span><br><span class="line">                    f[i][j] += f[i- <span class="number">1</span>][j - k];  <span class="comment">// 状态f[i][j]表示前i次总和是j的方案数！</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt;= n * <span class="number">6</span>; i++) res.push_back(f[n][i]);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-扑克牌的顺子-剑指offer原61题"><a href="#3-扑克牌的顺子-剑指offer原61题" class="headerlink" title="3.扑克牌的顺子(剑指offer原61题)"></a>3.扑克牌的顺子(剑指offer原61题)</h4><ul>
<li>解题思路：模拟人的想法，先将<strong>除去了大小王之外</strong>的牌拿过来，如果有相同元素，则一定不是顺子！如果没有任何两个元素相同，看一下牌中最小值与最大值的差距是否在4以内。如果满足条件，则可以将缺失的部分用大小王来进行填补。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从扑克牌中随机抽5张牌，判断是不是一个顺子。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isContinous</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nums[k]) k++;   <span class="comment">// 去掉行首的0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt; nums.size(); i++)&#123;  <span class="comment">// 去掉重复元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums.back() - nums[k] &lt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-圆圈中最后剩下的数字-剑指offer原62题-——约瑟夫环问题"><a href="#4-圆圈中最后剩下的数字-剑指offer原62题-——约瑟夫环问题" class="headerlink" title="4.圆圈中最后剩下的数字(剑指offer原62题)——约瑟夫环问题"></a>4.圆圈中最后剩下的数字(剑指offer原62题)——约瑟夫环问题</h4><ul>
<li>解题思路：f(n,m)表示总共n个数字，每次报到数字m时，就将此数字从环中删除,最后剩下的数字。f(n-1,m)表示从剩下的n-1个数字中，每次报到数字m时，就将此数字从环中删除，最后剩下的数字。观察f(n,m)与f(n-1,m)之间的关系，可知f(n,m) = (f(n-1,m) + m) % n,其中边界条件是f(n==1, m) = 0;  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (lastRemaining(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-股票的最大利润（剑指offer原63题）"><a href="#5-股票的最大利润（剑指offer原63题）" class="headerlink" title="5.股票的最大利润（剑指offer原63题）"></a>5.股票的最大利润（剑指offer原63题）</h4><ul>
<li>解题思路：找出前i天的最小值，利用一个变量minValue来存储。第i天卖出的价格是nums[i]，最大利润res是等于第i天卖出价格与前i天中价格最低时买入的价格之差，此时获得的利润是最大的。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDiff</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;   <span class="comment">// 最大利润</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, minValue = nums[<span class="number">0</span>]; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            res = max(res, nums[i] - minValue);  <span class="comment">// minValue表示前i天的最小值，nums[i]表示第i天卖出的价格！</span></span><br><span class="line">            minValue = min(minValue, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-求1-2-3-…-n，不能使用乘除法和各种循环、判断语句-剑指offer原64题"><a href="#6-求1-2-3-…-n，不能使用乘除法和各种循环、判断语句-剑指offer原64题" class="headerlink" title="6.求1+2+3+…+n，不能使用乘除法和各种循环、判断语句(剑指offer原64题)"></a>6.求1+2+3+…+n，不能使用乘除法和各种循环、判断语句(剑指offer原64题)</h4><ul>
<li>解题思路：使用递归的思路来写，但是将当中的if语句，改成&amp;&amp;运算符。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        n &gt; <span class="number">0</span> &amp;&amp; (res += getSum(n - <span class="number">1</span>));   <span class="comment">// 实际是对if(n &gt; 0) res += getSum(n - 1);语句的改写</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-不用加减乘除做加法-剑指offer原65题"><a href="#7-不用加减乘除做加法-剑指offer原65题" class="headerlink" title="7.不用加减乘除做加法(剑指offer原65题)"></a>7.不用加减乘除做加法(剑指offer原65题)</h4><ul>
<li>解题思路：模拟计算机中的加法A + B，结果是CD。其中C是十位，D是个位。A和B对应位上的取值有四种(0 0、0 1、1 0、1 1)，C上的结果是(0 0 0 1),D上的结果是(0 1 1 0)。可以将C上的结果看出(A对应位上的取值 &amp; B对应位上的取值)；将D上的结果看出(A对应位上的取值 ^ B对应位上的取值)。因此，可以将多位数相加A + B可以看出是A + B= A^B(无进位) + (A &amp; B &lt;&lt; 1)(A &amp; B表示的就是进位)。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num2)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 ^ num2;</span><br><span class="line">            <span class="keyword">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="8-构建乘积数组-剑指offer原66题-不能用除法、只能开一个数组"><a href="#8-构建乘积数组-剑指offer原66题-不能用除法、只能开一个数组" class="headerlink" title="8.构建乘积数组(剑指offer原66题)[不能用除法、只能开一个数组]"></a>8.构建乘积数组(剑指offer原66题)[不能用除法、只能开一个数组]</h4><ul>
<li>解题思路：B[i] = A[0] * A[1] * … * A[i-1] * A[i+1] * … * A[n-1]。可以先算i的左半边 A[0] * A[1] * … * A[i-1]，然后算i的右半边A[i+1] * … * A[n-1]，最后两部分相乘。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先算A[0]到A[i-1]的乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            B[i] = p;</span><br><span class="line">            p *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再算A[i+1]到A[n-1]的乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>, p = <span class="number">1</span>; ~i; i--)&#123;</span><br><span class="line">            B[i] *= p;</span><br><span class="line">            p *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-把字符串转换成整数-剑指offer原67题"><a href="#9-把字符串转换成整数-剑指offer原67题" class="headerlink" title="9.把字符串转换成整数(剑指offer原67题)"></a>9.把字符串转换成整数(剑指offer原67题)</h4><ul>
<li>解题思路：处理好各种边界问题！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; str.size() &amp;&amp; str[k] == <span class="string">' '</span>) k++;  <span class="comment">// 忽略所有的行首空格！</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> is_minus = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 忽略完行首的空格后，可能有-/+的符号</span></span><br><span class="line">        <span class="keyword">if</span>(str[k] == <span class="string">'+'</span>) k++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[k] == <span class="string">'-'</span>) k++, is_minus = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k &lt; str.size() &amp;&amp; str[k] &gt;= <span class="string">'0'</span> &amp;&amp; str[k] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">            number = number * <span class="number">10</span> + str[k] - <span class="string">'0'</span>;   <span class="comment">// 字符串表示的数字转换成真正的数字</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is_minus) number *= <span class="number">-1</span>;  <span class="comment">// 处理负数的情况</span></span><br><span class="line">        <span class="keyword">if</span>(number &gt; INT_MAX) number = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(number &lt; INT_MIN) number = INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="10-树中两个结点的最低公共祖先-剑指offer原68题"><a href="#10-树中两个结点的最低公共祖先-剑指offer原68题" class="headerlink" title="10.树中两个结点的最低公共祖先(剑指offer原68题)"></a>10.树中两个结点的最低公共祖先(剑指offer原68题)</h4><ul>
<li>解题思路：给出的两个结点的位置可能有两种情况，一种是两个结点出现在一个结点的左右两个子树上；另一种是一个给定的结点出现最低公共祖先节点上，另一个给定的结点出现在左子树或右子树上！<br>具体的方法是：先遍历左子树，检查是否有给定的两个结点p、q；再遍历右子树，检查是否有给定的两个结点p、q。如果左右子树中同时出现了p、q，则当前结点就是需要返回的就是最低公共祖先结点；如果只在左子树或右子树中出现p、q，则返回值就是p、q的最低公共祖先。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 空树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> left = lowestCommonAncestor(root-&gt;left, p, q);   <span class="comment">// 检查一下左边是否有p和q</span></span><br><span class="line">        <span class="keyword">auto</span> right = lowestCommonAncestor(root-&gt;right, p, q);  <span class="comment">// 检查一下右边是否有p和q</span></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="11-数字在排序数组中出现的次数-剑指offer原53题—题目一）"><a href="#11-数字在排序数组中出现的次数-剑指offer原53题—题目一）" class="headerlink" title="11.数字在排序数组中出现的次数(剑指offer原53题—题目一）"></a>11.数字在排序数组中出现的次数(剑指offer原53题—题目一）</h4><ul>
<li>解题思路：<strong>二分法解决！</strong>就是此数字第一次出现的位置与此数字最后一次出现的位置，两者之间的数的个数就是该数字出现的次数！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; k) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[l] != k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = l;</span><br><span class="line">        l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= k) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="12-0到n-1中缺失的数字-剑指offer原53题—-题目二"><a href="#12-0到n-1中缺失的数字-剑指offer原53题—-题目二" class="headerlink" title="12.0到n-1中缺失的数字(剑指offer原53题—-题目二)"></a>12.0到n-1中缺失的数字(剑指offer原53题—-题目二)</h4><ul>
<li>题目要求的是：长度为n的数组,将其中的一个数删掉，只剩下n-1个数了。将剩下的n-1个数作为程序的输入，找出被删除的那个数！</li>
<li>解题思路：先计算0到n-1中的n个数的和，再减去当前序列中的每个数，也就可以得到答案了。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;  <span class="comment">// nums是输入的n-1个数</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = (n - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums) res -= x;</span><br><span class="line">        <span class="keyword">return</span> res;   <span class="comment">// res就是0到n-1中缺失的那个数字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="13-数组中数值和下标相等的元素-剑指offer原53题—-题目三"><a href="#13-数组中数值和下标相等的元素-剑指offer原53题—-题目三" class="headerlink" title="13.数组中数值和下标相等的元素(剑指offer原53题—-题目三)"></a>13.数组中数值和下标相等的元素(剑指offer原53题—-题目三)</h4><ul>
<li>解题思路：因为给定的数组nums具有单调递增的性质，可以使用二分查找，时间复杂度是O(logn)。考察数组nums[i]-i是否具有单调性。即（nums[i]-i &gt;= nums[i-1] - (i-1)是否成立？）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] - mid &gt;= <span class="number">0</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[r] - r == <span class="number">0</span>) <span class="keyword">return</span> r;  <span class="comment">// 相等元素的下标</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="14-二叉搜索树的第K个大的结点-剑指offer原54题"><a href="#14-二叉搜索树的第K个大的结点-剑指offer原54题" class="headerlink" title="14.二叉搜索树的第K个大的结点(剑指offer原54题)"></a>14.二叉搜索树的第K个大的结点(剑指offer原54题)</h4><ul>
<li>解题思路：先对二叉搜索树进行中序遍历，每遍历到一个结点后，就对K进行减一操作。直到k减小到0后，就已经找到了第K个大的结点。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        dfs(root, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;left, k);  <span class="comment">// 中序遍历</span></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(!k) ans = root;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span>) dfs(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="15-二叉树的深度-剑指offer原55题"><a href="#15-二叉树的深度-剑指offer原55题" class="headerlink" title="15.二叉树的深度(剑指offer原55题)"></a>15.二叉树的深度(剑指offer原55题)</h4><ul>
<li>解题思路：深度就是找出从根结点到叶子节点的路径最长长度！具体就是找出根节点的左右子树两者中更长者的深度+1，即二叉树的深度。左右子树的深度用递归的方法来求解，当递归到叶子节点时，递归停止！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 递归终止条件！</span></span><br><span class="line">        <span class="keyword">return</span> max(treeDepth(root-&gt;left), treeDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="16-平衡二叉树-剑指offer原55题—题目二"><a href="#16-平衡二叉树-剑指offer原55题—题目二" class="headerlink" title="16.平衡二叉树(剑指offer原55题—题目二)"></a>16.平衡二叉树(剑指offer原55题—题目二)</h4><ul>
<li>解题思路：利用上一题的思路，求出左右子树的深度之差是否是大于1的，如果所有点的深度差都不大于1的话，则是平衡二叉树；如果任意一个结点的左右子树深度之差大于1，则一定是非平衡二叉树!  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root-&gt;left), right = dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>;  <span class="comment">// 当前结点的深度 == 当前结点左右子树的深度的更大者 + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="17-数组中只出现一次的两个数字-剑指offer原56题"><a href="#17-数组中只出现一次的两个数字-剑指offer原56题" class="headerlink" title="17.数组中只出现一次的两个数字(剑指offer原56题)"></a>17.数组中只出现一次的两个数字(剑指offer原56题)</h4><ul>
<li>原题是：一个数组中除了两个数字之外，其他数字都出现了2次。利用程序找出这两个只出现一次的数字！</li>
<li>解题思路：<ul>
<li><strong>先考虑一种简单的情况</strong>，数组中除了一个数字只出现一次外，其余数字都出现了2次，找出这个只出现一次的数字。<strong>利用异或运算的特点，所有出现两次的数字异或时都被消成0，再将异或结果与只出现一次的数字进行异或，结果就是我们要找的数字</strong>。</li>
<li>本题中只出现一次的数字有两个，如何找出这两个只出现一次的数呢?<strong>*利用上面一样的操作，对所有的数字执行异或操作，得到的结果是两个只出现一次的数字的异或，由于两个数字都只出现一次。因此，最终的异或结果肯定不等于0</strong>。因为两个只出现一次的数字的异或的结果不等于0，所以异或结果的二进制表示中肯定有一位是1。假设异或结果中的第3位是1，则两个只出现一次的数字二进制表示的第3位一定是不相同的。<strong>此时，将原始数组中所有数字划分成两个集合，划分的依据就是看数组中每个数字的第3位是0还是1。因此，两个只出现一次的数字一定不在同一个集合中！所有出现两次的数字一定在同一个集合中！此时，两个集合中的数字就转化成最开始讨论的一种简单情况的例子</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumsAppearance(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) sum ^= x;   <span class="comment">// 先求所有数字的异或和,也就是sum = x ^ y  x,y分别表示数组中只出现一次的数字</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(sum &gt;&gt; k &amp; <span class="number">1</span>)) k++;  <span class="comment">// 然后从sum中找出其二进制表示中任意一位不为0的位，k存储的就是x ^ y结果中第k位是1的那一位</span></span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;&gt; k &amp; <span class="number">1</span>)   <span class="comment">// 将x的二进制表示中第k位是1的划分到第一个集合first中！</span></span><br><span class="line">                first ^= x;  <span class="comment">// 第一个集合异或的结果first  第二个结果异或的结果first ^ sum</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;first, sum ^ first&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="18-数组中唯一只出现一次的数字-剑指offer原56题—题目2"><a href="#18-数组中唯一只出现一次的数字-剑指offer原56题—题目2" class="headerlink" title="18.数组中唯一只出现一次的数字(剑指offer原56题—题目2)"></a>18.数组中唯一只出现一次的数字(剑指offer原56题—题目2)</h4><ul>
<li>原题目：一个数组中除了一个数字只出现一次外，其他数字都出现了三次，找出那个只出现一次的数字。</li>
<li>解题思路：<strong>有限状态机原理，初始的状态是(ones=0,twos=0);输入的数字的二进制表示中某一位是1时，状态转移成(1,0),接着数字的二进制表示中某一位仍然是1时，状态转移成(0,1),接着数字的二进制表示中某一位继续是1时，状态转移成(0,0)。也就是每三个状态构成一个循环；当输入的数字的二进制表示中某一位是0时，从初始的状态是(ones=0,twos=0)转移至自身(0,0)；当所有的输入数字中某一位出现次数是%3余1时，状态就转移到(1,0)；当所有的输入数字中某一位出现次数是%3余0时，状态就转移到(0,0)状态</strong>。ones就代表了上面两种情况的结果。数组中唯一只出现一次的数字。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumberAppearingOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            ones = (ones ^ x) &amp; ~twos;</span><br><span class="line">            twos = (twos ^ x) &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="19-和为s的数字-剑指offer原57题—-题目一"><a href="#19-和为s的数字-剑指offer原57题—-题目一" class="headerlink" title="19.和为s的数字(剑指offer原57题—-题目一)"></a>19.和为s的数字(剑指offer原57题—-题目一)</h4><ul>
<li><p>解题思路1：暴力解法，先依次遍历每个数字，遍历到某个数字时，固定这个数字。再依次判断数组中其余的n-1个数字与它的和是否等于target。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力解法O(n**2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumberWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[j]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解题思路2：对第二重循环进行优化，第二重循环的目的是判断对于j &lt; i这个范围内，是否存在一个数字nums[j]使得target - nums[i] == nums[j]成立。因此，可以使用哈希表来统计数字nums[j]是否出现从而来优化，使得时间复杂度变成O(n)。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumberWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.count(target - nums[i])) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;target - nums[i], nums[i]&#125;;  <span class="comment">// hash.count(target - nums[i])就是判断nums[j]是否在j &lt; i的范围内出现！</span></span><br><span class="line">            hash.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="20-和为s的连续正数序列-剑指offer原57题—-题目二"><a href="#20-和为s的连续正数序列-剑指offer原57题—-题目二" class="headerlink" title="20.和为s的连续正数序列(剑指offer原57题—-题目二)"></a>20.和为s的连续正数序列(剑指offer原57题—-题目二)</h4><ul>
<li>原题：<strong>输入一个正数s,输出所有和为s的连续正数序列</strong>，序列中至少含有两个数。</li>
<li>解题思路：暴力方法是给出区间的起点i,再给出区间的终点j。利用求和公式计算出区间[i,j]中数字的和是否为s，时间复杂度是O(n<strong>2)。改进的方法是：假设区间[i,j]中数字的和是s，当区间左端点i向右移动到i1时，</strong>区间的右端点j也会向右移动到j1，如果右端点j向左移动到j2，则区间[i1,j2]中的数字之和一定是小于s的**。总结起来就是使用双指针算法，时间复杂度变成O(n)。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力方法：O(n**2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> sum)&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, s = <span class="number">1</span>; i &lt;= sum; i++)  <span class="comment">// s是当前序列的和</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span>(s &lt; sum) s += ++j;</span><br><span class="line">           <span class="keyword">if</span>(s == sum &amp;&amp; j - i + <span class="number">1</span> &gt; <span class="number">1</span>)&#123;  <span class="comment">// [i,j]中包含的元素个数是: j - i + 1</span></span><br><span class="line">               <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; line;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++) line.push_back(k);  <span class="comment">// line是一个一维数组，数组中存放的是区间[i,j]中和为s的数字</span></span><br><span class="line">               res.push_back(line);</span><br><span class="line">           &#125;</span><br><span class="line">           s -= i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="21-翻转单词顺序-剑指offer原58题—-题目一"><a href="#21-翻转单词顺序-剑指offer原58题—-题目一" class="headerlink" title="21.翻转单词顺序(剑指offer原58题—-题目一)"></a>21.翻转单词顺序(剑指offer原58题—-题目一)</h4><ul>
<li>原题：输入一个句子，翻转句子中单词的顺序，但每个单词内的字母顺序不变。</li>
<li>解题思路：先用双指针i和j，将整个句子的每个单词以字母为单位进行翻转；然后对句子的每个单词进行翻转。  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">string</span> reverseWords(<span class="keyword">string</span> s)&#123;</span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());  <span class="comment">// 等价于for(int i = 0, j = s.size() - 1; i &lt; j; i++, j--) swap(s[i], s[j]); 第一步首先对整个句子进行翻转</span></span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;  <span class="comment">// 对第一步中翻转后的每个单词进行翻转，下面是从一段字符串中提取出一个单词的操作！</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="built_in">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] != <span class="string">' '</span>) j++;</span><br><span class="line">            reverse(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + j);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="22-左旋转字符串-剑指offer原58题—-题目二"><a href="#22-左旋转字符串-剑指offer原58题—-题目二" class="headerlink" title="22.左旋转字符串(剑指offer原58题—-题目二)"></a>22.左旋转字符串(剑指offer原58题—-题目二)</h4><ul>
<li>原题是：将字符串中的前面的前n位移动到字符串的尾部。</li>
<li>解题思路：和上一题一样的思路，先对整个字符串进行翻转。然后将翻转后的结果分成两个部分：前str.size() - n个字符和倒数n个字符，然后分别对上面的两部分进行翻转即可。  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">string</span> leftRotateString(<span class="keyword">string</span> str, <span class="keyword">int</span> n)&#123;</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>() + str.<span class="built_in">size</span>() - n);</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>() + str.<span class="built_in">size</span>() - n, str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="23-数字序列中某一位的数字-剑指offer原44题"><a href="#23-数字序列中某一位的数字-剑指offer原44题" class="headerlink" title="23.数字序列中某一位的数字(剑指offer原44题)"></a>23.数字序列中某一位的数字(剑指offer原44题)</h4><ul>
<li>解题思路：<ul>
<li>1.确定是几位数（n - 10*1 - 90*2 - 900*3 - …）</li>
<li>2.确定是几位数的第几个数</li>
<li>3.确定那个数的第几位</li>
</ul>
</li>
<li>详细过程：首先要确定第n位对应的数字在什么范围内，也就是确定第n位对应的数字是几位数。因为一位数有10个，占10位，两位数有90个，占180位，三位数有900个，占2700位。假设输入的是第1000位，则第1000位对应的应该是一个三位数（因为1000-10-180 = 720 &lt; 2700）；然后确定第1000位对应的是哪个三位数上的某一位。因为经过上一步的分析可知，输入的第1000位出现在两位数之后的第720位，因为三位数每个数占3位，所以输入的第1000位对应的应该是第240个三位数中的某一位！由于三位数从100开始，所以第240个三位数是100 + 240 - 1 = 339；最后确定对应是339中的哪一位（因为720 / 3 = 240，所以应该对应339的最后一位9）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>, s = <span class="number">9</span>, base = <span class="number">1</span>;  <span class="comment">// i是几位数  s是几位数的个数  base是几位数的开始第一个数字</span></span><br><span class="line">        <span class="comment">// 确定n对应是几位数</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; i * s)&#123;</span><br><span class="line">            n -= i * s;</span><br><span class="line">            i++;</span><br><span class="line">            s *= <span class="number">10</span>;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定是几位数中的哪个数</span></span><br><span class="line">        <span class="keyword">int</span> number = base + (n + i - <span class="number">1</span>) / i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 确定那个数的第几位</span></span><br><span class="line">        <span class="keyword">int</span> r = n % i ? n % i : i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - r; j++) number /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="24-把数组排成最小的数-剑指offer原45题"><a href="#24-把数组排成最小的数-剑指offer原45题" class="headerlink" title="24.把数组排成最小的数(剑指offer原45题)"></a>24.把数组排成最小的数(剑指offer原45题)</h4><ul>
<li>解题思路：首先在数组中定义两个数字之间的小于&lt;关系：即a &lt; b等价于ab &lt; ba。然后将原始的输入数组按照定义的小于关系重新排序，一次拼接派好序后的数组中的数字即可。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> as = to_string(a), bs = to_string(b);</span><br><span class="line">        <span class="keyword">return</span> as + bs &lt; bs + as;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">printMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end(), cmp);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) res += to_string(x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="25-把数字翻译成字符串-剑指offer原46题"><a href="#25-把数字翻译成字符串-剑指offer原46题" class="headerlink" title="25.把数字翻译成字符串(剑指offer原46题)"></a>25.把数字翻译成字符串(剑指offer原46题)</h4><ul>
<li>解题思路：<strong>大部分计数的问题，可以看成是动态规划的问题</strong>。问题的关键是<strong>a.状态表示 b.状态如何计算 c.边界怎么定义</strong>。f(i)表示前i位数字一共有多少种翻译方式，f(i)<br>如何计算？如果将第i位数字单独翻译成一个字母，则f(i)可表示为前i-1位数字一共有多少种翻译方式；如果将第i位和第i-1位数字翻译成两个个字母，则f(i)可表示为前i-2为数字一共有多少种翻译方式。综合上述两种情况,f(i) = f(i-1) + f(i-2)。<strong>注意第二种情况：f(i-2)是将第i和第i-1位数字联合起来翻译成字母，因此必须有约束,范围是[10,25]之间</strong>。最后，考虑边界f(0) = 1。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTranslationCount</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n+<span class="number">1</span>);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>];   <span class="comment">// 第一种情况</span></span><br><span class="line">            <span class="keyword">int</span> t = (s[i<span class="number">-2</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + s[i<span class="number">-1</span>] - <span class="string">'0'</span>;  <span class="comment">// 第二种情况</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">25</span>) f[i] += f[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="26-礼物的最大价值-剑指offer原47题"><a href="#26-礼物的最大价值-剑指offer原47题" class="headerlink" title="26.礼物的最大价值(剑指offer原47题)"></a>26.礼物的最大价值(剑指offer原47题)</h4><ul>
<li>解题思路：<strong>经典的边界问题，还是要考虑三个问题，状态怎么表示；状态的计算问题；怎么定义边界</strong>。f[i,j]表示从左上角出发，到达当格子获得的最大价值。状态计算[i, j] = max(f[i-1, j],f[i, j-1]) + gifts[i,j]；边界f[i,0] = f[0, j] = 0。所要求的答案是f[n,m]。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                f[i][j] = max(f[i <span class="number">-1</span>][j], f[i][j<span class="number">-1</span>]) + grid[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="27-最长不含重复字符的子字符串-剑指offer原48题"><a href="#27-最长不含重复字符的子字符串-剑指offer原48题" class="headerlink" title="27.最长不含重复字符的子字符串(剑指offer原48题)"></a>27.最长不含重复字符的子字符串(剑指offer原48题)</h4><ul>
<li>解题思路：双指针i、j算法，当j指针每向后移动一位时，判断i到j中是否有重复字符，如果出现了重复字符，就将i指向的重复字符删除，同时i指针向后移动一次。当j移动到字符串末尾时，j-i+1的距离就是不含重复字符的子字符串。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthLongestSubString</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">            hash[s[j]]++;</span><br><span class="line">            <span class="keyword">while</span>(hash[s[j]] &gt; <span class="number">1</span>) hash[s[i++]]--;</span><br><span class="line">            res = max(res, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="28-丑数-剑指offer原49题-———求第n个丑数的值"><a href="#28-丑数-剑指offer原49题-———求第n个丑数的值" class="headerlink" title="28.丑数(剑指offer原49题)———求第n个丑数的值"></a>28.丑数(剑指offer原49题)———求第n个丑数的值</h4><ul>
<li>解题思路：丑数：一个数的质因子中只包含2 3 5的数！首先将1加入丑数集合中去，然后分别用三个i,j,k指针指向1.。其中i表示2，j表示3，k表示5；然后用1分别与i、j、k三个指针相乘，取相乘后所有结果中的最小值放在1的下一个位置。同时，将指针向后移动一个位置。<strong>当有多个相等的最小值出现时，需要将多个指针分别向后移动一个位置</strong>。依次循环下去，就可以找到整个丑数组成的集合了。（实际上是3路归并排序，将包含因子2的排好序丑数放入一个数组、包含因子3的排好序丑数放入一个数组、包含因子5的排好序丑数放入一个数组；<strong>前面的三个数组中，是不包含因子1</strong>。然后将三个数组分别除以数字2 数字3 数字5得到的结果仍然是一个丑数序列，将得到的3个丑数序列合并后进行判重处理，就得到了最终结果）  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">int</span> getUglyNumber(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; <span class="string">q(1, 1)</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(--n)&#123;  <span class="regexp">//</span> 循环n-<span class="number">1</span>次    <span class="keyword">while</span>(n--)&#123;&#125;是循环n次</span><br><span class="line">            <span class="keyword">int</span> t = min(<span class="string">q[i]</span> * <span class="number">2</span>, min(<span class="string">q[j]</span> * <span class="number">3</span>, <span class="string">q[k]</span> * <span class="number">5</span>));</span><br><span class="line">            q.push_back(t);</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">q[i]</span> * <span class="number">2</span> == t) i++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">q[j]</span> * <span class="number">3</span> == t) j++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">q[k]</span> * <span class="number">5</span> == t) k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="29-字符串中第一个只出现一次的字符-剑指offer原50题—-题目一"><a href="#29-字符串中第一个只出现一次的字符-剑指offer原50题—-题目一" class="headerlink" title="29.字符串中第一个只出现一次的字符(剑指offer原50题—-题目一)"></a>29.字符串中第一个只出现一次的字符(剑指offer原50题—-题目一)</h4><ul>
<li>解题思路：先定义一个hash表，统计每个字符出现多少次，然后从前往后遍历hash表，扫描到第一个值是1对应的key，也就是最终的结果  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) hash[c]++;  <span class="comment">// 统计字符串s中每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">char</span> res = <span class="string">'#'</span>;  <span class="comment">// 无解的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">            <span class="keyword">if</span>(hash[c] == <span class="number">1</span>)&#123;</span><br><span class="line">                res = c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="30-字符流中第一个只出现一次的字符-剑指offer原50题—-题目二"><a href="#30-字符流中第一个只出现一次的字符-剑指offer原50题—-题目二" class="headerlink" title="30.字符流中第一个只出现一次的字符(剑指offer原50题—-题目二)"></a>30.字符流中第一个只出现一次的字符(剑指offer原50题—-题目二)</h4><ul>
<li>解题思路：每次输入字符时，将输入的字符流中出现次数大于1的字符删除。使用队列的数据结构来存储插入的字符！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入字符到一个队列queue中</span></span><br><span class="line">    <span class="comment">// 利用hash表判断当前正在插入的字符是否出现在当前的队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(++hash[ch] &gt; <span class="number">1</span>)&#123;  <span class="comment">// 插入的字符已经出现在队列中</span></span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; hash[q.front()] &gt; <span class="number">1</span>) q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> q.push(ch); <span class="comment">// 插入的字符没有出现在队列中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstAppearingOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="31-数组中的逆序对-剑指offer原51题）"><a href="#31-数组中的逆序对-剑指offer原51题）" class="headerlink" title="31.数组中的逆序对(剑指offer原51题）"></a>31.数组中的逆序对(剑指offer原51题）</h4><ul>
<li>解题思路：暴力做法的时间复杂度是O(n**2)，考虑能否使用归并排序的方法来优化算法为O(nlogn)。首先分别对统计同时在左右两个子序列中一共有多少个逆序对（递归方法）；然后计算逆序对不在同一个子序列时，对第二个序列中的每一个数a[j]，计算第一个序列中一共有多少个数a[i]比a[j]要大。因此一共有r-i+1个数比a[j]]要大！最后的结果是上面三个部分的和。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = merge(nums, l, mid) + merge(nums, mid + <span class="number">1</span>, r);  <span class="comment">// 第一和第二部分</span></span><br><span class="line">        <span class="comment">// 第三个部分</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j]) temp.push_back(nums[i++]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp.push_back(nums[j++]);</span><br><span class="line">                res += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= mid) temp.push_back(nums[i++]);</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= r) temp.push_back(nums[j++]);</span><br><span class="line">            i = l;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : temp) nums[i++] = x;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">inversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="32-两个链表的第一个公共结点-剑指offer原52题）"><a href="#32-两个链表的第一个公共结点-剑指offer原52题）" class="headerlink" title="32.两个链表的第一个公共结点(剑指offer原52题）"></a>32.两个链表的第一个公共结点(剑指offer原52题）</h4><ul>
<li>思路：使用两个指针p和q，p指针指向第一个链表的头结点，q指针指向第二个链表的头结点。当p指针遍历到第一个链表的末尾时，接着回到第二链表的头结点位置；当q指针遍历到第二个链表的末尾时，接着回到第一链表的头结点位置。<strong>注意两个指针所走的总距离是相等的</strong>！当进行了多次循环后，两个指针一定会在某个结点处相遇，即公共结点。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">findFirstCommonNode</span><span class="params">(ListNode* headA, ListNode* headB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = headA, q = headB;</span><br><span class="line">        <span class="keyword">while</span>(p != q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p) p = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p = headB;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(q) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> q = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="33-二叉搜索树的后序遍历序列-剑指offer原33题"><a href="#33-二叉搜索树的后序遍历序列-剑指offer原33题" class="headerlink" title="33.二叉搜索树的后序遍历序列(剑指offer原33题)"></a>33.二叉搜索树的后序遍历序列(剑指offer原33题)</h4><ul>
<li>题目：给定一个数组，判断此数组是否是某二叉搜索树的后序遍历结果！</li>
<li>解题思路：先找出数组中的最后一个元素作为树根root，然后找到二叉搜索树的左子树的最后一个位置（左子树中的结点值均小于root，右子树的结点值均大于root）。接着找到二叉搜索树的右子树的最后一个位置。判断结点的值是否满足二叉搜索树的定义！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifySequenceOFBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span></span>&#123;</span><br><span class="line">        seq = sequence;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, seq.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> root = seq[r];</span><br><span class="line">        <span class="keyword">int</span> k = l;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; r &amp;&amp; seq[k] &lt; root) k++;  <span class="comment">// 二叉搜索树的左子树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; r; i++)&#123;  <span class="comment">// 判断二叉搜索树的右子树是否合法</span></span><br><span class="line">            <span class="keyword">if</span>(seq[i] &lt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(l, k<span class="number">-1</span>) &amp;&amp; dfs(k+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="34-二叉树中和为某一值的路径-剑指offer原34题"><a href="#34-二叉树中和为某一值的路径-剑指offer原34题" class="headerlink" title="34.二叉树中和为某一值的路径(剑指offer原34题)"></a>34.二叉树中和为某一值的路径(剑指offer原34题)</h4><ul>
<li>解题思路：直接遍历一遍二叉树，当遍历到叶节点时，判断从根节点到当前节点的路径上的节点值之和是否等于给定值。如果等于的话，就记录当前的路径。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findPath(TreeNode* root, <span class="keyword">int</span> sum)&#123;</span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;  <span class="comment">// 当前节点是空的，就不是叶子节点</span></span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="comment">// 如果当前节点的左右子树都是空的，则当前节点是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !sum) ans.push_back(path);</span><br><span class="line">        <span class="comment">// 递归处理左右子树</span></span><br><span class="line">        dfs(root-&gt;left, sum);</span><br><span class="line">        dfs(root-&gt;right, sum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="35-复杂链表的复制-剑指offer原35题"><a href="#35-复杂链表的复制-剑指offer原35题" class="headerlink" title="35.复杂链表的复制(剑指offer原35题)"></a>35.复杂链表的复制(剑指offer原35题)</h4><ul>
<li>解题思路：第一步将每个节点复制出来，然后将当前节点的next指针指向复制出来的节点；第二步将原先节点p的random指针指向第3个节点；那么，被复制出来的p节点是p-&gt;next，其random指针即p-&gt;next-&gt;random指向p-&gt;random-&gt;next节点。最后将复制出来的节点全部连接起来！  <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next, *random;</span><br><span class="line">    ListNode(int x): val(x), next(nullptr), random(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* copyRandomList(ListNode* head)&#123;</span><br><span class="line">        <span class="comment">// 第一步复制所有的节点，并将当前节点指向复制出来的节点</span></span><br><span class="line">        <span class="keyword">for</span>(auto p = head; p;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">auto</span> np = new ListNode(p-&gt;</span>val);  <span class="comment">// 复制出来的新节点</span></span><br><span class="line">            <span class="function"><span class="title">auto</span> next = p-&gt;</span><span class="function"><span class="title">next</span>;   // 备份一下p-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>next = np;   <span class="comment">// 复制出来的点接在当前节点的后面</span></span><br><span class="line">            <span class="function"><span class="title">np</span>-&gt;</span>next = next;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二步复制random指针</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(auto p = head; p; p = p-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next)&#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(p-&gt;</span>random)</span><br><span class="line">                <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">random</span> = p-&gt;</span><span class="function"><span class="title">random</span>-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第三步将所有复制出来的节点连接起来</span></span><br><span class="line">        auto dummy = new ListNode(-<span class="number">1</span>);</span><br><span class="line">        auto cur = dummy;   <span class="comment">// 当前新链表的尾节点</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(auto p = head; p; p = p-&gt;</span>next)&#123;</span><br><span class="line">            <span class="function"><span class="title">cur</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">cur</span> = cur-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">return</span> dummy-&gt;</span>next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="36-二叉搜索树与双向链表-剑指offer原36题"><a href="#36-二叉搜索树与双向链表-剑指offer原36题" class="headerlink" title="36.二叉搜索树与双向链表(剑指offer原36题)"></a>36.二叉搜索树与双向链表(剑指offer原36题)</h4><ul>
<li>解题思路：首先获取根节点；然后分别递归左右子树，左右子树分别返回一个首尾节点(即当前子树中最左边的节点和当前子树中最右边的节点)；接着将三部分拼接起来；最后将左子树的最左侧和右子树的最右侧节点返回就是最后的答案。  <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">using</span> namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* <span class="built_in">left</span>;</span><br><span class="line">    TreeNode* <span class="built_in">right</span>;</span><br><span class="line">    TreeNode(int x): val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* convert(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> nullptr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">auto</span> sides = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> sides.<span class="built_in">first</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;TreeNode*, TreeNode*&gt; dfs(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;<span class="built_in">left</span> &amp;&amp; !root-&gt;<span class="built_in">right</span>) <span class="keyword">return</span> &#123;root, root&#125;;  // 当前节点是叶子节点</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> &amp;&amp; root-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="built_in">auto</span> lsides = dfs(root-&gt;<span class="built_in">left</span>), rsides = dfs(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">            lsides.second-&gt;<span class="built_in">right</span> = root, root-&gt;<span class="built_in">left</span> = lsides.second;</span><br><span class="line">            root-&gt;<span class="built_in">right</span> = rsides.<span class="built_in">first</span>, rsides.<span class="built_in">first</span>-&gt;<span class="built_in">left</span> = root;</span><br><span class="line">            <span class="keyword">return</span> &#123;lsides.<span class="built_in">first</span>, rsides.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>)&#123;</span><br><span class="line">            <span class="built_in">auto</span> lsides = dfs(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">            lsides.second-&gt;<span class="built_in">right</span> = root, root-&gt;<span class="built_in">left</span> = lsides.second;</span><br><span class="line">            <span class="keyword">return</span> &#123;lsides.<span class="built_in">first</span>, root&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="built_in">auto</span> rsides = dfs(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">            root-&gt;<span class="built_in">right</span> = rsides.<span class="built_in">first</span>, rsides.<span class="built_in">first</span>-&gt;<span class="built_in">left</span> = root;</span><br><span class="line">            <span class="keyword">return</span> &#123;root, rsides.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="37-序列化二叉树-剑指offer原37题"><a href="#37-序列化二叉树-剑指offer原37题" class="headerlink" title="37.序列化二叉树(剑指offer原37题)"></a>37.序列化二叉树(剑指offer原37题)</h4><ul>
<li>题目：确保二叉树可以序列化为字符串；并且可以将此字符串反序列化为原始树结构。</li>
<li>解题思路：利用二叉树的前序遍历实现从二叉树到字符串的序列化操作；反序列化实现的是从字符串到二叉树的转换，注意将字符串类型的数字转成整数的方法！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        dfs_s(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历实现序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            res += <span class="string">"null "</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += to_string(root-&gt;val) + <span class="string">' '</span>;</span><br><span class="line">        dfs_s(root-&gt;left, res);</span><br><span class="line">        dfs_s(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs_d(data, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_d</span><span class="params">(<span class="built_in">string</span> data, <span class="keyword">int</span>&amp; u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == data.size()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> k = u;</span><br><span class="line">        <span class="keyword">while</span>(data[k] != <span class="string">' '</span>) k++;</span><br><span class="line">        <span class="keyword">if</span>(data[u] == <span class="string">'n'</span>)&#123; <span class="comment">// 'n'是null的开始字符</span></span><br><span class="line">            u = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = u; i &lt; k; i++) val = val * <span class="number">10</span> + data[i] - <span class="string">'0'</span>;  <span class="comment">// 将字符串整数"123"转换成整数123</span></span><br><span class="line">        u = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root-&gt;left = dfs_d(data, u);</span><br><span class="line">        root-&gt;right = dfs_d(data, u);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="38-数字排列—-（与剑指offer38题不同）"><a href="#38-数字排列—-（与剑指offer38题不同）" class="headerlink" title="38.数字排列—-（与剑指offer38题不同）"></a>38.数字排列—-（与剑指offer38题不同）</h4><ul>
<li>题目：输入一组数字(可能包含重复数字)，输出其所有的全排列</li>
<li>解题思路：先对输入的数字进行排序，然后开辟与输入一组数字相同长度的数组，接着从输入数字中按顺序取一个数字放在数组的任意一个位置上。<strong>接下来，取第二个数字放在数组中剩下空间的任意一个位置上，如果第二个数字与第一个数字值是相同的，则规定第二个数字只能放在第一个数字的后面的位置</strong>，依次将输入的数字放入数组中，直到数组的各位都已经占满为止。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permutation(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        path.resize(nums.size());   <span class="comment">// 开辟的数组空间大小</span></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">// 用一个二进制位来表示哪些位置是空的</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> u, <span class="keyword">int</span> start, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">        <span class="comment">// u:当前枚举的位置   start: 当前这个数应该从哪个位置开始枚举？（即上一个数的后一个位置开始枚举）</span></span><br><span class="line">        <span class="comment">// state: 存储的是状态，表示哪些数被用过</span></span><br><span class="line">        <span class="keyword">if</span>(u == nums.size())&#123;</span><br><span class="line">            ans.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!u || nums[u] != nums[u<span class="number">-1</span>]) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(state &gt;&gt; i &amp; <span class="number">1</span>))&#123;   <span class="comment">// state &gt;&gt; i &amp; 1：看一下state的二进制表示中第i位是否表示为1</span></span><br><span class="line">                path[i] = nums[u];</span><br><span class="line">                dfs(nums, u + <span class="number">1</span>, i + <span class="number">1</span>, state + (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="39-数组中出现次数超过一半的数字（寻找数组中的众数）-剑指offer原39题"><a href="#39-数组中出现次数超过一半的数字（寻找数组中的众数）-剑指offer原39题" class="headerlink" title="39.数组中出现次数超过一半的数字（寻找数组中的众数）(剑指offer原39题)"></a>39.数组中出现次数超过一半的数字（寻找数组中的众数）(剑指offer原39题)</h4><ul>
<li>解题思路：初始化一个计数变量count = 0，然后遍历数组中的每个元素，当val等于第一个元素时，count加1。接着遍历第二个元素，如果第二个元素的值与第一个元素的值相同时，则count加1；如果第二个元素的值与第一个元素的值不同时，count减1；最后遍历完整个数组后，最终结果存储在val变量中。<strong>摩尔投票法原理</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">moreThanHalfNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, val = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt) val = x, cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x == val) cnt++;</span><br><span class="line">                <span class="keyword">else</span> cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="40-最小的k个数-剑指offer原40题"><a href="#40-最小的k个数-剑指offer原40题" class="headerlink" title="40.最小的k个数(剑指offer原40题)"></a>40.最小的k个数(剑指offer原40题)</h4><ul>
<li>解题思路：维护一个大顶堆，当最小的k个数存放在大顶堆中。遍历输入数组中的每个元素，然后将每个元素与大顶堆中的堆顶元素进行比较，如果比堆顶元素小，就更新堆顶元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : input)</span><br><span class="line">        &#123;</span><br><span class="line">            heap.push(x);</span><br><span class="line">            <span class="keyword">if</span>(heap.size() &gt; k) heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(heap.size()) res.push_back(heap.top()), heap.pop();  <span class="comment">// heap存放的是从大到小的顺序</span></span><br><span class="line">        reverse(res.rbegin(), res.rend());  <span class="comment">// 翻转一下变成从小到大</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="41-数据流中的中位数-剑指offer原41题"><a href="#41-数据流中的中位数-剑指offer原41题" class="headerlink" title="41.数据流中的中位数(剑指offer原41题)"></a>41.数据流中的中位数(剑指offer原41题)</h4><ul>
<li>题目：如果从数据流中读出奇数个数值，则中位数就是所有数值排序后位于中间的数值；如果从数据流中读出偶数个数值，则中位数就是所有数值排序之后中间两个数的平均值。</li>
<li>解题思路：将当前所有的数维护成两个集合，第一个集合是一个小顶堆，存的是比较大的那一部分数；第二个集合是一个大顶堆，存的是比较小的那一部分数。<strong>可以发现，大顶堆的堆顶元素和小顶堆的堆顶元素实际就是输入数据流中间的两个数</strong>。规定，数据流中读出的是奇数个数值时，大顶堆比小顶堆中的元素多一个。如何维护这个结构？<strong>每次插入一个新的元素到大顶堆中，如果下面大顶堆的堆顶元素比上面小顶堆的堆顶元素的大（即逆序了），则交换；如果下面大顶堆中的元素太多了，就要直接转移当中的一个元素到小顶堆中</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; max_heap;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; min_heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        max_heap.push(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(min_heap.size() &amp;&amp; max_heap.top() &gt; min_heap.top())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> maxv = max_heap.top(), minv = min_heap.top();</span><br><span class="line">            max_heap.pop(), min_heap.pop();</span><br><span class="line">            max_heap.push(minv), min_heap.push(maxv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(max_heap.size() &gt; min_heap.size() + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            min_heap.push(max_heap.top());</span><br><span class="line">            max_heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(max_heap.size() + min_heap.size() &amp; <span class="number">1</span>) <span class="keyword">return</span> max_heap.top();   <span class="comment">// 数据流中是奇数个数值</span></span><br><span class="line">        <span class="keyword">return</span> (max_heap.top() + min_heap.top()) / <span class="number">2.0</span>;    <span class="comment">// 数据流中是偶数个数值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="42-连续子数组的最大和-剑指offer原42题"><a href="#42-连续子数组的最大和-剑指offer原42题" class="headerlink" title="42.连续子数组的最大和(剑指offer原42题)"></a>42.连续子数组的最大和(剑指offer原42题)</h4><ul>
<li>解题思路：s表示遍历到当前数x前一个位置为结尾的子数组的和最大值，s如何更新？当s &gt; 0时，s = s + x；当s &lt;= 0时，s = x；  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s &lt; <span class="number">0</span>) s = <span class="number">0</span>;</span><br><span class="line">            s += x;</span><br><span class="line">            res = max(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="43-从1到n整数中1出现的次数-剑指offer原43题"><a href="#43-从1到n整数中1出现的次数-剑指offer原43题" class="headerlink" title="43.从1到n整数中1出现的次数(剑指offer原43题)"></a>43.从1到n整数中1出现的次数(剑指offer原43题)</h4><ul>
<li>解题思路：假设输入13015，则万位上的1个数：10000-13015共3016个；千位上的1个数：1000-1999,11000-11999，一共有2000个；百位上的1个数：情况有很多种！十位上的1个数：情况有很多种！总结出的一般规律：输入的数字是abcedf，第一种情况：假设c位置上的数字是1，则ab位置上的取值范围是00到ab-1；def位置上的取值范围是000到999，则总方案数是ab*1000。第二种情况：最高位恰好取到ab时，分两种情况讨论。1.c位等于0时，就只有0个1；2.c位等于1时，则def的取值范围是0到def，一共有def+1种方案；3.c大于1时，def位置上的取值范围是000到999，则总方案数是1000！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfBetween1AndN</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; number;</span><br><span class="line">        <span class="comment">// 取出n中的每位数字放入number中</span></span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            number.push_back(n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = number.size() -  <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="number">0</span>, right = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = number.size() - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                left = left * <span class="number">10</span> + number[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                right = right * <span class="number">10</span> + number[j];</span><br><span class="line">                t *= <span class="number">10</span>;  <span class="comment">// t表示右边一共有多少位数</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res += left * t;</span><br><span class="line">            <span class="keyword">if</span>(number[i] == <span class="number">1</span>) res += right + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(number[i] &gt; <span class="number">1</span>) res += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="44-反转链表-剑指offer原24题"><a href="#44-反转链表-剑指offer原24题" class="headerlink" title="44.反转链表(剑指offer原24题)"></a>44.反转链表(剑指offer原24题)</h4><ul>
<li>解题思路：因为反转的是一个单向链表，所以无法直接遍历当前节点的前驱结点，因此利用一个变量pre记录当前节点的前驱结点。然后从头开始遍历给定的单向链表，直到遍历到空结点为止。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;   <span class="comment">// 记录当前结点的前驱结点</span></span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = cur-&gt;next;    <span class="comment">// 用next变量缓存cur-&gt;next，用来使得cur向后移动一位</span></span><br><span class="line">            cur-&gt;next = pre;                   <span class="comment">// 每次遍历时，将当前结点的next指针指向其前驱结点</span></span><br><span class="line">            pre = cur;        <span class="comment">// 将pre指针向后移动一位，此时pre指向cur</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;                 <span class="comment">// pre就是反转后链表的头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="45-合并两个排序的链表-剑指offer原25题"><a href="#45-合并两个排序的链表-剑指offer原25题" class="headerlink" title="45.合并两个排序的链表(剑指offer原25题)"></a>45.合并两个排序的链表(剑指offer原25题)</h4><ul>
<li>解题思路：<strong>归并排序的方法来实现即可！</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;   <span class="comment">// 因为往合并后的链表中添加元素时，是尾部插入的。因此，需要一个cur指针来记录当前链表的尾结点在哪。</span></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将两个链表中更长者中剩余的部分链接到已合并链表的末尾</span></span><br><span class="line">        <span class="keyword">if</span>(l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="46-树的子结构—-树的匹配-剑指offer原26题"><a href="#46-树的子结构—-树的匹配-剑指offer原26题" class="headerlink" title="46.树的子结构—-树的匹配(剑指offer原26题)"></a>46.树的子结构—-树的匹配(剑指offer原26题)</h4><ul>
<li>解题思路：类比字符串匹配的方法，从根结点root开始枚举，看一下树根root是否是子树的根节点；不是的话，判断树的左孩子结点是否是子树的树根结点；不是的话，判断树的右孩子结点是否是子树的树根结点。然后利用前序遍历树和子树即可。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasSubTree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot1 || !pRoot2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 前序遍历树pRoot1，然后与pRoot2结点进行对比</span></span><br><span class="line">        <span class="keyword">if</span>(isPart(pRoot1, pRoot2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasSubTree(pRoot1-&gt;left, pRoot2) || hasSubTree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPart</span><span class="params">(TreeNode* p1, TreeNode* p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p1 || p1-&gt;val != p2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isPart(p1-&gt;left, p2-&gt;left) &amp;&amp; isPart(p1-&gt;right, p2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="47-二叉树的镜像-剑指offer原27题"><a href="#47-二叉树的镜像-剑指offer原27题" class="headerlink" title="47.二叉树的镜像(剑指offer原27题)"></a>47.二叉树的镜像(剑指offer原27题)</h4><ul>
<li>解题思路：所有结点的左右孩子结点都交换了一下，遍历树中的所有结点，每次遍历完后，将每个结点的左右孩子结点交换一下就可以了。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mirror</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        mirror(root-&gt;left);</span><br><span class="line">        mirror(root-&gt;right);</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="48-对称的二叉树-剑指offer原28题"><a href="#48-对称的二叉树-剑指offer原28题" class="headerlink" title="48.对称的二叉树(剑指offer原28题)"></a>48.对称的二叉树(剑指offer原28题)</h4><ul>
<li>解题思路：除了根节点之外，其他的每个结点它的左边的结点和右边的结点是对应的！并且左边结点的左孩子和右边结点的右孩子是对称的，左边结点的右孩子和右边结点的左孩子是对称的！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> !p &amp;&amp; !q;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="49-顺时针打印矩阵-剑指offer原29题"><a href="#49-顺时针打印矩阵-剑指offer原29题" class="headerlink" title="49.顺时针打印矩阵(剑指offer原29题)"></a>49.顺时针打印矩阵(剑指offer原29题)</h4><ul>
<li>解题思路：顺时针定义四个方向：右 下 左 上；先按右的方向走，走到不能走为止；然后向下移动一个位置，按下的方向走，走到不能走为止；再向左移动一个位置，按左的方向走，走到不能走为止；最后向上移动一个位置，按上的方向走，走到不能走为止！直到总完n<em>m步就完成了！不能走的定义是：<em>*要么走出了边界，要么你已经走过了这个格子了</em></em>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>));   <span class="comment">// 二维数组记录每个格子是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;   <span class="comment">// 上 右 下 左</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">1</span>;  <span class="comment">// 起始方向是向右移动，故d = 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(matrix[x][y]);</span><br><span class="line">            st[x][y] = <span class="literal">true</span>;   <span class="comment">// 当前点被标记成已经访问</span></span><br><span class="line">            <span class="keyword">int</span> a = x + dx[d], b = y + dy[d];  <span class="comment">// 下一个点的坐标</span></span><br><span class="line">            <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || st[a][b])&#123;  <span class="comment">// 当前点已经出界或者被访问过</span></span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;   <span class="comment">// d向下移动</span></span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="50-包含min函数的栈-剑指offer原30题"><a href="#50-包含min函数的栈-剑指offer原30题" class="headerlink" title="50.包含min函数的栈(剑指offer原30题)"></a>50.包含min函数的栈(剑指offer原30题)</h4><ul>
<li>题目：设计一个支持push pop top等操作并可以在O(1)的时间复杂度内检索出最小元素的堆栈。</li>
<li>解题思路：利用一个辅助栈(<strong>单调栈</strong>)来操作。单调栈：即栈中的元素是单调的！维护一个单调栈，单调栈中的元素大小是单独变化的，当插入一个新的元素到主栈中时，将其与单调栈中的栈顶元素进行比较，当插入的元素比单调栈中的栈顶元素大，则不会将新的元素插入到主栈中；<strong>当插入的元素比单调栈中的栈顶元素小或者与单调栈中的栈顶元素相等时，则将新的元素插入到主栈中去</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk, min_stk;   <span class="comment">// stk是主栈  min_stk是单调栈</span></span><br><span class="line"></span><br><span class="line">    MinStack()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        stk.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min_stk.empty() || min_stk.top() &gt;= x) min_stk.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.top() == min_stk.top()) min_stk.pop();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="51-栈的压入与弹出序列-剑指offer原31题"><a href="#51-栈的压入与弹出序列-剑指offer原31题" class="headerlink" title="51.栈的压入与弹出序列(剑指offer原31题)"></a>51.栈的压入与弹出序列(剑指offer原31题)</h4><ul>
<li>解题思路：模拟一遍整个过程，每次往栈里面加一个元素，加完后判断当前栈顶元素是否是当前弹出序列的元素。如果是，则将栈顶元素弹出。当栈里面已经是空时，弹出序列就是合法的，否则就是不合法的!  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(popV.size() != pushV.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushV.size(); i++)&#123;</span><br><span class="line">            s.push(pushV[i]);</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() == popV[index])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="52-不分行从上往下打印二叉树-层序遍历-剑指offer原32题—-题目一"><a href="#52-不分行从上往下打印二叉树-层序遍历-剑指offer原32题—-题目一" class="headerlink" title="52.不分行从上往下打印二叉树[层序遍历](剑指offer原32题—-题目一)"></a>52.不分行从上往下打印二叉树[层序遍历](剑指offer原32题—-题目一)</h4><ul>
<li>解题思路：宽度优先搜索BFS，利用队列这个数据结构来实现  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printFromTopToBottom(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(q.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            res.push_back(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="53-分行从上往下打印二叉树-剑指offer原32题—-题目二"><a href="#53-分行从上往下打印二叉树-剑指offer原32题—-题目二" class="headerlink" title="53.分行从上往下打印二叉树(剑指offer原32题—-题目二)"></a>53.分行从上往下打印二叉树(剑指offer原32题—-题目二)</h4><ul>
<li>解题思路：在队列中增加一个null标记，表示当前层的结点已经全部遍历结束。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; printFromTopToBottom(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;   <span class="comment">// 辅助的数组表示每层中有多少个结点</span></span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();  <span class="comment">// 队首元素</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t)  <span class="comment">// t为空时，表示已经遍历完一层</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(level.empty()) <span class="keyword">break</span>;  <span class="comment">// level数组为空时，表示已经遍历完所有的结点，就直接返回</span></span><br><span class="line">                res.push_back(level);</span><br><span class="line">                level.clear();</span><br><span class="line">                q.push(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            level.push_back(t-&gt;val);  <span class="comment">// t不为空时，将当前的点加入到level中，进行扩展</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="54-之字形打印二叉树-剑指offer原32题—-题目三"><a href="#54-之字形打印二叉树-剑指offer原32题—-题目三" class="headerlink" title="54.之字形打印二叉树(剑指offer原32题—-题目三)"></a>54.之字形打印二叉树(剑指offer原32题—-题目三)</h4><ul>
<li>解题思路：在上一题的基础上增加一个布尔类型的变量zigzag，当zigzag为true时，表示从右到左打印；zigzag为false时，表示从左到右打印！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; printFromTopToBottom(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;   <span class="comment">// 辅助的数组表示每层中有多少个结点</span></span><br><span class="line">        <span class="keyword">bool</span> zigzag = <span class="literal">false</span>;   <span class="comment">// 表示从左到右打印</span></span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();  <span class="comment">// 队首元素</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t)  <span class="comment">// t为空时，表示已经遍历完一层</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(level.empty()) <span class="keyword">break</span>;  <span class="comment">// level数组为空时，表示已经遍历完所有的结点，就直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(zigzag) reverse(level.begin(), level.end());</span><br><span class="line">                res.push_back(level);</span><br><span class="line">                level.clear();</span><br><span class="line">                q.push(<span class="literal">nullptr</span>);</span><br><span class="line">                zigzag = !zigzag;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            level.push_back(t-&gt;val);  <span class="comment">// t不为空时，将当前的点加入到level中，进行扩展</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="55-机器人的运动范围-剑指offer原13题"><a href="#55-机器人的运动范围-剑指offer原13题" class="headerlink" title="55.机器人的运动范围(剑指offer原13题)"></a>55.机器人的运动范围(剑指offer原13题)</h4><ul>
<li>解题思路：一般考虑使用宽度优先遍历BFS，不建议使用深度优先遍历DFS。因为深度优先遍历在数据范围比较大时，可能会出现栈溢出！从(0,0)点开始遍历，每次将<strong>符合要求</strong>的格子加入到队列中去。最后一共遍历完多少个合法的格子，就是我们最终的结果。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 算出一个数字的各个位置上的数字之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_single_sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            s += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 算出一个格子中的各个位置上数字之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get_single_sum(p.first) + get_single_sum(p.second);    <span class="comment">// p.first是x坐标   p.second是y坐标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingcount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!rows || !cols) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st(rows, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (cols, <span class="literal">false</span>));   <span class="comment">// 全部初始化成false，记录每个格子是否已经被访问</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);  <span class="comment">// 初始坐标初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;    <span class="comment">// 顺时针来记忆 上 右 下 左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(get_sum(t) &gt; threshold || st[t.first][t.second]) <span class="keyword">continue</span>;</span><br><span class="line">            res++;</span><br><span class="line">            st[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols)&#123;</span><br><span class="line">                    q.push(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="56-剪绳子-剑指offer原14题"><a href="#56-剪绳子-剑指offer原14题" class="headerlink" title="56.剪绳子(剑指offer原14题)"></a>56.剪绳子(剑指offer原14题)</h4><ul>
<li>题目：给定一个正整数，将此整数划分成若干个更小的正整数的和<br><strong>使得划分出来的若干个正整数的乘积最大</strong></li>
<li>解题思路：目标：假设输入的正整数是N，拆分成尽可能多的3！。分下面几种情况：1.如果N % 3 == 0，则拆分成若干个3；2.如果N % 3 == 1，则先将N拆分成两个2，剩下的全部拆分成3；3.如果N % 3 == 2，则先将N拆分成一个2，剩下的全部拆分成3；</li>
<li>证明上面的三种情况：N &gt; 0，N = n1 + n2 + n3 + …+ nk 1.假设ni &gt;= 5，3 * (ni - 3) &gt;= ni(即3*ni-9 &gt;= ni得到2ni &gt;= 9)是否成立？2.ni = 4， 4 = 2 * 2。<strong>由前面的1和2得到拆分出来的数字一定不包含4和大于等于5的数字</strong>；因此可知所有拆分出来的ni不是2就是3。接下来证明拆分出来的数字中，最多只有两个2（因为2*2*2 &lt; 3*3）。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">1</span>) res *= <span class="number">4</span>, n -= <span class="number">4</span>;  <span class="comment">// 拆成出来两个2</span></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">2</span>) res *= <span class="number">2</span>, n -= <span class="number">2</span>;  <span class="comment">// 拆出来一个2</span></span><br><span class="line">        <span class="keyword">while</span>(n) res *= <span class="number">3</span>, n -= <span class="number">3</span>;    <span class="comment">// 拆出来全部都是3</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="57-二进制中1的个数-剑指offer原15题"><a href="#57-二进制中1的个数-剑指offer原15题" class="headerlink" title="57.二进制中1的个数(剑指offer原15题)"></a>57.二进制中1的个数(剑指offer原15题)</h4><ul>
<li>解题思路：s += n &amp; 1是先统计n中个位上是数字1的个数，n&gt;&gt;1则是统计完n中个位的结果后，移除n的个位上的数字来进行更新。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOf1</span><span class="params">(<span class="keyword">int</span> _n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> n = _n;  <span class="comment">// 将有符号数转换成无符号数，为了下面的循环</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            s += n &amp; <span class="number">1</span>;  <span class="comment">// 每次将n的个位取出来，判断是否是1，是1的话就s++</span></span><br><span class="line">            n &gt;&gt; <span class="number">1</span>;  <span class="comment">// 然后将n的个位移除，即n右移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="58-数值的整数次方-剑指offer原16题"><a href="#58-数值的整数次方-剑指offer原16题" class="headerlink" title="58.数值的整数次方(剑指offer原16题)"></a>58.数值的整数次方(剑指offer原16题)</h4><ul>
<li>解题思路：注意处理次方是负数的情况即可！  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span>(<span class="params"><span class="keyword">double</span> <span class="keyword">base</span>, <span class="keyword">int</span> exponent</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; abs(exponent); i++)&#123;</span><br><span class="line">            res *= <span class="keyword">base</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>) res = <span class="number">1</span> / res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="59-在O-1-的时间复杂度内删除链表结点（剑指offer原18题—题目一）"><a href="#59-在O-1-的时间复杂度内删除链表结点（剑指offer原18题—题目一）" class="headerlink" title="59.在O(1)的时间复杂度内删除链表结点（剑指offer原18题—题目一）"></a>59.在O(1)的时间复杂度内删除链表结点（剑指offer原18题—题目一）</h4><ul>
<li>解题思路：此题不能使用常规方法！因为要删除的结点不是链表的最后一个结点，所以下一个结点一定不是空结点。删除的方法是：<strong>用下一个结点的值去覆盖当前结点的值，然后将下一个结点的值删掉</strong>。这种方法就不需要用到前驱结点了。  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(int x): val(x), next(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void deleteNode(ListNode* <span class="keyword">node</span><span class="title">)&#123;</span></span><br><span class="line"><span class="title">        node-</span>&gt;val = <span class="keyword">node</span><span class="title">-&gt;next-</span>&gt;val;</span><br><span class="line">        <span class="keyword">node</span><span class="title">-&gt;next</span> = <span class="keyword">node</span><span class="title">-&gt;next-</span>&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="60-删除链表中重复的结点（剑指offer原18题—题目二）"><a href="#60-删除链表中重复的结点（剑指offer原18题—题目二）" class="headerlink" title="60.删除链表中重复的结点（剑指offer原18题—题目二）"></a>60.删除链表中重复的结点（剑指offer原18题—题目二）</h4><ul>
<li>解题思路：<strong>建议凡是可能会把头结点删掉的链表问题，一般来说都会增加一个虚拟头结点来简化代码</strong>。使用两个指针，第一个指针p指向上一次保留的结点的最后一个位置，q指向的是下一段的第一个结点，q用来扫描下一段的所有结点。  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* <span class="keyword">next</span>;</span><br><span class="line">    ListNode(int x): val(x), <span class="keyword">next</span>(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)&#123;</span><br><span class="line">        auto dummy = new ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy-&gt;<span class="keyword">next</span> = head;</span><br><span class="line"></span><br><span class="line">        auto p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;<span class="keyword">next</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            auto q = p-&gt;<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">while</span>(q &amp;&amp; p-&gt;<span class="keyword">next</span>-&gt;val == q-&gt;val)&#123;</span><br><span class="line">                q = q-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            if(p-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span> == q) p = p-&gt;<span class="keyword">next</span>;   <span class="regexp">//</span> 下一段的长度是<span class="number">1</span>，没有重复结点，不用删</span><br><span class="line">            else p-&gt;<span class="keyword">next</span> = q;   <span class="regexp">//</span> 下一段的长度超过<span class="number">1</span>，则删除重复结点</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="61-正则表达式的匹配（剑指offer原19题）"><a href="#61-正则表达式的匹配（剑指offer原19题）" class="headerlink" title="61.正则表达式的匹配（剑指offer原19题）"></a>61.正则表达式的匹配（剑指offer原19题）</h4><ul>
<li>题目：实现一个函数用来匹配包括.和*的正则表达式。字符.表示任意一个字符；字符*表示它前面的字符可以出现任意次（含0次）。</li>
<li>解题思路：<strong>动态规划问题</strong>。状态表示f[i][j]:s[i,…]和p[j,…]是相匹配的；状态转移：情况1：如果p[j]是正常字符，则f[i][j] = s[i] == p[j] &amp;&amp; f[i + 1][j + 1]；情况2：p[j]是.，f[i][j] = f[i + 1][j + 1]；情况3：p[j + 1] = *，*表示的字符是0次或*表示的字符匹配1次，则f[i][j] = f[i][j + 2] || f[i + 1][j]；边界问题：f[n][m] = true  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f;</span><br><span class="line">    <span class="built_in">string</span> s, p;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">inMatch</span><span class="params">(<span class="built_in">string</span> _s, <span class="built_in">string</span> _p)</span></span>&#123;</span><br><span class="line">        s = _s, p = _p;</span><br><span class="line">        n = s.size(), m = p.size();</span><br><span class="line">        f = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">        <span class="keyword">if</span>(y == m)</span><br><span class="line">            <span class="keyword">return</span> f[x][y] = x == n;</span><br><span class="line">        <span class="keyword">bool</span> first_match = x &lt; n &amp;&amp; (p[y] == <span class="string">'.'</span> || s[x] == p[y]);  <span class="comment">// 情况1和情况2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(y + <span class="number">1</span> &lt; m &amp;&amp; p[y + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;  <span class="comment">// 情况3</span></span><br><span class="line">            f[x][y] = dp(x, y + <span class="number">2</span>) || dp(x + <span class="number">1</span>, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[x][y] = first_match &amp;&amp; dp(x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="62-表示数值的字符串（剑指offer原20题）"><a href="#62-表示数值的字符串（剑指offer原20题）" class="headerlink" title="62.表示数值的字符串（剑指offer原20题）"></a>62.表示数值的字符串（剑指offer原20题）</h4><ul>
<li>解题思路：分各种情况讨论  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    bool isNumber(string s)&#123;</span><br><span class="line">        int i = <span class="number">0</span>, j = s.size();</span><br><span class="line">        /<span class="regexp">/ 删除字符串s中的前后空格</span></span><br><span class="line"><span class="regexp">        while(i &lt;= j &amp;&amp; s[i] == ' ') i++;</span></span><br><span class="line"><span class="regexp">        while(i &lt;= j &amp;&amp; s[j] == ' ') j--;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        if(i &gt; j) return false;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        s = s.substr(i, j - i + 1);</span></span><br><span class="line"><span class="regexp">        if(s[0] == '+' || s[0] == '-') s = s.substr(1);</span></span><br><span class="line"><span class="regexp">        if(s.empty() || (s[0] == '.' &amp;&amp; s.size() == 1)) return false;  /</span><span class="regexp">/ + - .</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        int dot = 0, e = 0;   /</span><span class="regexp">/ 统计有多少个.和e</span></span><br><span class="line"><span class="regexp">        for(int i = 0; i &lt; s.size(); i++)&#123;</span></span><br><span class="line"><span class="regexp">            if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9');</span></span><br><span class="line"><span class="regexp">            else if(s[i] == '.')&#123;</span></span><br><span class="line"><span class="regexp">                dot++;</span></span><br><span class="line"><span class="regexp">                if(dot &gt; 1 || e) return false;  /</span><span class="regexp">/ 3434.23232.4343, 23232e23232.2323</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            else if(s[i] == 'e' || s[i] == 'E')&#123;</span></span><br><span class="line"><span class="regexp">                e++;</span></span><br><span class="line"><span class="regexp">                if(!i || i + 1 == s.size() || e &gt; 1 || s[i - 1] == '.' &amp;&amp; i == 1) return false; /</span><span class="regexp">/ e1223233, 11232e, 1212e32323e</span></span><br><span class="line"><span class="regexp">                if(s[i + 1] == '+' || s[i + 1] == '-')&#123;</span></span><br><span class="line"><span class="regexp">                    if(i + 2 == s.size()) return false;   /</span><span class="regexp">/ 12341e+</span></span><br><span class="line"><span class="regexp">                    i++;</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            else return false;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        return true;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="63-调整数组顺序使奇数位于偶数前面（剑指offer原21题）"><a href="#63-调整数组顺序使奇数位于偶数前面（剑指offer原21题）" class="headerlink" title="63.调整数组顺序使奇数位于偶数前面（剑指offer原21题）"></a>63.调整数组顺序使奇数位于偶数前面（剑指offer原21题）</h4><ul>
<li>题目：输入一个数组，实现数组中数字的顺序，使得所有的奇数位于数组的前半部分；所有的偶数位于后半部分。</li>
<li>解题思路：使用双指针，一个指针从前往后，另一个指针从后往前。保证第一个指针前面全部是奇数，第二个指针前面全部是偶数。  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">class</span> Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">        int <span class="keyword">first</span> = <span class="number">0</span>, <span class="keyword">second</span> = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">first</span> &lt;= <span class="keyword">second</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">first</span> &lt;= <span class="keyword">second</span> &amp;&amp; nums[<span class="keyword">first</span>] % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">first</span>++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">first</span> &lt;= <span class="keyword">second</span> &amp;&amp; nums[<span class="keyword">second</span>] % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">second</span><span class="comment">--;</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">first</span> &lt; <span class="keyword">second</span>) swap(nums[<span class="keyword">first</span>], nums[<span class="keyword">second</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="64-链表中倒数第k个节点（剑指offer原22题）"><a href="#64-链表中倒数第k个节点（剑指offer原22题）" class="headerlink" title="64.链表中倒数第k个节点（剑指offer原22题）"></a>64.链表中倒数第k个节点（剑指offer原22题）</h4><ul>
<li>解题思路：由于单链表不能从后往前遍历的，只能从前往后遍历。因此首先求出整个链表的长度n，求倒数第k个节点相当于求正序的n-k+1个节点，然后从前往后遍历到n-k+1个节点就可以了。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">findKthToTail</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next) n++;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k; i++) p = p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="65-链表中环的入口节点（剑指offer原23题）"><a href="#65-链表中环的入口节点（剑指offer原23题）" class="headerlink" title="65.链表中环的入口节点（剑指offer原23题）"></a>65.链表中环的入口节点（剑指offer原23题）</h4><ul>
<li>解题思路：<strong>使用快慢指针算法，用两个指针first和second分别从起点开始走，first每次走一步，second每次走两步。如果过程中second走到null，则说明不存在环；否则当first和second相遇后，让first返回起点，second待在原地不动，然后两个指针每次分别走一步，当相遇时，相遇点就是环的入口</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">entryNodeOfLoop</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i = head, j = head; <span class="comment">// i是慢指针，每次走一步;j是快指针，每次走两步</span></span><br><span class="line">        <span class="keyword">while</span>(i &amp;&amp; j)&#123;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">            j = j-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(j) j = j-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;  <span class="comment">// i和j相遇了</span></span><br><span class="line">                i = head;  <span class="comment">// 慢指针i回到起点</span></span><br><span class="line">                <span class="keyword">while</span>(i != j)&#123; <span class="comment">// 慢指针和快指针同时向后移动一个位置</span></span><br><span class="line">                    i = i-&gt;next;</span><br><span class="line">                    j = j-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> i;   <span class="comment">// 环入口的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 无环存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="66-找出数组中重复的数字（剑指offer原3题—-题目一）"><a href="#66-找出数组中重复的数字（剑指offer原3题—-题目一）" class="headerlink" title="66.找出数组中重复的数字（剑指offer原3题—-题目一）"></a>66.找出数组中重复的数字（剑指offer原3题—-题目一）</h4><ul>
<li>解题思路：从前往后遍历整个数组中的每个元素，如果元素的取值不在0到n-1范围内，就直接返回-1；如果元素的取值在0到n-1范围内时，检查数组下标是取值为该元素时的数组位置上存储的是哪个数字；如果存储的数字与其在数组中对应的下标相等，则找出了重复的数字，否则将两个位置上的数字进行交换，重复此步骤，直到存储的数字与其在数组中对应的下标相等为止。  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int duplicateInArray(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(auto x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; nums.<span class="built_in">size</span>(); <span class="built_in">i</span>++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">i</span> != nums[<span class="built_in">i</span>] &amp;&amp; nums[nums[<span class="built_in">i</span>]] != nums[<span class="built_in">i</span>]) swap(nums[<span class="built_in">i</span>], nums[nums[<span class="built_in">i</span>]]);</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">i</span>] != <span class="built_in">i</span> &amp;&amp; nums[nums[<span class="built_in">i</span>]] == nums[<span class="built_in">i</span>]) <span class="keyword">return</span> nums[<span class="built_in">i</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="67-不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）"><a href="#67-不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）" class="headerlink" title="67.不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）"></a>67.不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）</h4><ul>
<li>解题思路：<strong>根据抽屉原理</strong>，至少有2个数字会重复！利用递归的思想，将这个数组一分为二，分别计算左右子数组两边的长度和元素的个数，至少有一边元素的个数会大于子数组的长度。递归上面的过程即可！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duplicateInArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;  <span class="comment">// [l, mid], [mid + 1, r]</span></span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;  <span class="comment">// 统计元素的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) s += x &gt;= l &amp;&amp; x &lt;= mid;</span><br><span class="line">            <span class="keyword">if</span>(s &gt; mid - l + <span class="number">1</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="68-二维数组中的查找（剑指offer原4题）"><a href="#68-二维数组中的查找（剑指offer原4题）" class="headerlink" title="68.二维数组中的查找（剑指offer原4题）"></a>68.二维数组中的查找（剑指offer原4题）</h4><ul>
<li>解题思路：从二维数组右上角的位置开始查找，如果要查找的目标数字比右上角的数字要大，则目标数字出现在二维数组的右下角位置；如果要查找的目标数字比右上角的数字要小，则目标数字出现在二维数组的左上角位置。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty() || <span class="built_in">array</span>[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">array</span>[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="built_in">array</span>.size() &amp;&amp; j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &gt; target) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="69-替换空格（剑指offer原5题）"><a href="#69-替换空格（剑指offer原5题）" class="headerlink" title="69.替换空格（剑指offer原5题）"></a>69.替换空格（剑指offer原5题）</h4><ul>
<li>解题思路：开一个新的字符串，遍历原始的字符串，如果遇到空格字符，就将20%存储在新字符串中；否则，直接存储在新字符串中。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpaces</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : str)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="string">' '</span>)</span><br><span class="line">                res += <span class="string">"20%"</span>;</span><br><span class="line">            <span class="keyword">else</span> res += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="70-从尾到头打印链表（剑指offer原6题）"><a href="#70-从尾到头打印链表（剑指offer原6题）" class="headerlink" title="70.从尾到头打印链表（剑指offer原6题）"></a>70.从尾到头打印链表（剑指offer原6题）</h4><ul>
<li>解题思路：先将整个链表遍历一遍，然后将整个链表翻转一下即可。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListReversingly(ListNode* head)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res.rbegin(), res.rend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="71-重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）"><a href="#71-重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）" class="headerlink" title="71.重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）"></a>71.重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）</h4><ul>
<li>解题思路：首先，根据前序遍历确定当前区间的根节点是哪个；然后，根据已经确定的根节点，从中序遍历中找到根节点的位置在哪，从而确定二叉树的左右子树中分别包含的数字；最后，在已经确定的左右子树中递归执行前面的两个步骤，即可重建二叉树。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;   <span class="comment">// 开一个hash表，记录每个节点在数组中的位置</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder, inorder;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; _preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; _inorder)</span></span>&#123;</span><br><span class="line">        preorder = _preorder, inorder = _inorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); i++)&#123;</span><br><span class="line">            hash[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, preorder.size() - <span class="number">1</span>, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl &gt; pr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(preorder[pl]);</span><br><span class="line">        <span class="keyword">int</span> k = hash[inorder[root-&gt;val]];</span><br><span class="line">        <span class="keyword">auto</span> left = dfs(pl + <span class="number">1</span>, pl + <span class="number">1</span> + k - il - <span class="number">1</span>, il, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> right = dfs(pl + k - il + <span class="number">1</span>, pr, k + <span class="number">1</span>, ir);</span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="72-二叉树的下一个节点（剑指offer原8题）"><a href="#72-二叉树的下一个节点（剑指offer原8题）" class="headerlink" title="72.二叉树的下一个节点（剑指offer原8题）"></a>72.二叉树的下一个节点（剑指offer原8题）</h4><ul>
<li>题目：给定二叉树中的一个节点，找出<strong>中序遍历序列</strong>的下一个节点</li>
<li>解题思路：分情况进行讨论，情况1：如果给定的节点是存在右子树的，则下一个节点是右子树中最左边的节点；情况2：如果给定的节点是不存在右子树的，又分两种情况讨论：a.如果给定的节点存在父节点，并且给定的节点是父节点的左儿子的话，则下一个节点是给定节点的父节点；b.如果给定的节点存在父节点，并且给定的节点是父节点的右儿子的话，此时沿着父节点向上找，直到找到第一个节点是当前父节点的左儿子时停止，返回父节点。  <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* inorderSuccessor(TreeNode* p)&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span>right)&#123;  <span class="comment">// 情况1</span></span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">left</span>) p = p-&gt;</span>left;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况2</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">father</span> &amp;&amp; p == p-&gt;</span><span class="function"><span class="title">father</span>-&gt;</span><span class="function"><span class="title">right</span>) p = p-&gt;</span>father;</span><br><span class="line">        <span class="function"><span class="title">return</span> p-&gt;</span>father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="73-用两个栈实现一个队列（剑指offer原9题）"><a href="#73-用两个栈实现一个队列（剑指offer原9题）" class="headerlink" title="73.用两个栈实现一个队列（剑指offer原9题）"></a>73.用两个栈实现一个队列（剑指offer原9题）</h4><ul>
<li>解题思路：先将元素依次压入栈1中，然后逐个弹出栈1中的元素，将每个元素依次压入栈2中。此时，<strong>栈2中的栈顶元素就是栈1中的栈底元素</strong>，再依次弹出栈2中的元素时，就实现了队列的先进先出功能（最先进入栈1中的元素，最先从栈2中弹出）。  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stk, cache;</span><br><span class="line"></span><br><span class="line">    MyQueue()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        stk.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">copy</span>(stack&lt;<span class="keyword">int</span>&gt;&amp; a, stack&lt;<span class="keyword">int</span>&gt;&amp; b)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a.<span class="keyword">size</span>())&#123;</span><br><span class="line">            b.<span class="keyword">push</span>(a.top());</span><br><span class="line">            a.<span class="keyword">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">pop</span>()&#123;</span><br><span class="line">        <span class="keyword">copy</span>(stk, cache);</span><br><span class="line">        <span class="keyword">int</span> res = cache.top();</span><br><span class="line">        cache.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">copy</span>(cache, stk);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> peak()&#123;</span><br><span class="line">        <span class="keyword">copy</span>(stk, cache);</span><br><span class="line">        <span class="keyword">int</span> res = cache.top();</span><br><span class="line">        <span class="keyword">copy</span>(cache, stk);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty()&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="74-斐波那契数列数列（剑指offer原10题）"><a href="#74-斐波那契数列数列（剑指offer原10题）" class="headerlink" title="74.斐波那契数列数列（剑指offer原10题）"></a>74.斐波那契数列数列（剑指offer原10题）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = a + b;</span><br><span class="line">            a = b, b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="75-旋转数组的最小数字（剑指offer原11题）"><a href="#75-旋转数组的最小数字（剑指offer原11题）" class="headerlink" title="75.旋转数组的最小数字（剑指offer原11题）"></a>75.旋转数组的最小数字（剑指offer原11题）</h4><ul>
<li>解题思路：利用<strong>画图法</strong>来解决。输入数组是0 1 2 2 2 2 3 4 5,则旋转后的数组是2 2 3 4 5 0 1 2 2。将旋转数组分成两部分2 2 3 4 5和0 1 2 2，两部分是单调的增加。首先将后半部分相同值删除，然后观察剩下的结果可知，所有的元素都比前半部分的第一个元素小。前半部分中后面的值都大于或等于第一个元素。<strong>下面就可以使用二分法，找出后半部分中第一个比前半部分第一个元素小的那个数字，就是我们要找的最小数字</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span> &amp;&amp; nums[n] == nums[<span class="number">0</span>]) n--;  <span class="comment">// 去掉后半部分相等的数值</span></span><br><span class="line">        <span class="keyword">if</span>(nums[n] &gt;= nums[<span class="number">0</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="76-矩阵中的路径（剑指offer原12题）"><a href="#76-矩阵中的路径（剑指offer原12题）" class="headerlink" title="76.矩阵中的路径（剑指offer原12题）"></a>76.矩阵中的路径（剑指offer原12题）</h4><ul>
<li>解题思路：先枚举所有起点，然后枚举方向。直到走到不能走为止，这样就得到所有的路径。  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPath(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;char&gt;&gt;&amp; <span class="keyword">matrix</span>, <span class="keyword">string</span> str)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">matrix</span>.<span class="keyword">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(<span class="keyword">matrix</span>, str, <span class="number">0</span>, i, j))  <span class="comment">// 枚举所有起点i, j，从字符串str第0个字符串开始枚举</span></span><br><span class="line">                    <span class="keyword">return</span> true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool dfs(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;char&gt;&gt;&amp; <span class="keyword">matrix</span>, <span class="keyword">string</span>&amp; str, <span class="keyword">int</span> u, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="comment">// 当前字符串str中的第几个字符u，x和y是当前路径的坐标</span></span><br><span class="line">        <span class="keyword">if</span>(u == str.<span class="keyword">size</span>()) <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">matrix</span>[x][y] != str[u]) <span class="keyword">return</span> false;</span><br><span class="line">        <span class="comment">// 枚举四个方向</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        char t = <span class="keyword">matrix</span>[x][y];  <span class="comment">// 已经访问过的字符，不能重新访问</span></span><br><span class="line">        <span class="keyword">matrix</span>[x][y] = <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = x + dx[i], b = y + dx[i];</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="keyword">matrix</span>.<span class="keyword">size</span>() &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; <span class="keyword">matrix</span>[a].<span class="keyword">size</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(<span class="keyword">matrix</span>, str, u + <span class="number">1</span>, a, b)) <span class="keyword">return</span> true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">matrix</span>[x][y] = t;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    
    
    



    <div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>剑指offer第二版题解(详细版)</p>
  <p><span>文章作者:</span>Curry_Coder</p>
  <p><span>发布时间:</span>2019年09月09日 - 16:22:44</p>
  <p><span>最后更新:</span>2020年03月08日 - 15:00:18</p>
  <p><span>原始链接:</span><a href="/数据结构与算法/剑指offer第二版题解-详细版/" title="剑指offer第二版题解(详细版)">https://cdlwhm1217096231.github.io/数据结构与算法/剑指offer第二版题解-详细版/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://cdlwhm1217096231.github.io/数据结构与算法/剑指offer第二版题解-详细版/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>
</div>
<script>
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({
          title: "",
          text: '复制成功',
          html: false,
          timer: 500,
          showConfirmButton: false
        });
      });
    }));
</script>


      
    </div>

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:16px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>


      
    </div>

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>觉得对您有所帮助，请我喝杯可乐吧!</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Curry_Coder 微信支付">
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Curry_Coder 支付宝">
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    





    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/剑指Offer/" rel="tag"><i class="fa fa-tag"></i> 剑指Offer</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/C/C-中的基本变量类型介绍/" rel="next" title="C++中的基本变量类型介绍">
                <i class="fa fa-chevron-left"></i> C++中的基本变量类型介绍
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/移动端/01移动端布局基础之流式布局/" rel="prev" title="01移动端布局基础之流式布局">
                01移动端布局基础之流式布局 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/curry.jpg" alt="Curry_Coder">
            
              <p class="site-author-name" itemprop="name">Curry_Coder</p>
              <p class="site-description motion-element" itemprop="description">业精于勤荒于嬉，行成于思毁于随。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/cdlwhm1217096231" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/4645adadefec" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-heartbeat"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/2677530011/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:1217096231cdl@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-globe"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.baidu.com/" title="百度" target="_blank">百度</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.liujiangblog.com/course/python/4" title="Python" target="_blank">Python</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://developer.mozilla.org/zh-CN/" title="MDN" target="_blank">MDN</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://leetcode-cn.com/problemset/all/" title="LeetCode" target="_blank">LeetCode</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.nowcoder.com/224349141" title="牛客网" target="_blank">牛客网</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.huaxiaozhuan.com/" title="AI算法工程师手册" target="_blank">AI算法工程师手册</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://c.biancheng.net/stl/" title="STL手册" target="_blank">STL手册</a>
                  </li>
                
              </ul>
            </div>
          
<!-- CloudCalendar -->
<div class="widget-wrap" style="width: 90%;margin-left: auto;margin-right: auto; opacity: 0.97;">
  <div class="widget" id="CloudCalendar"></div>
</div>
          <div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28285910&auto=1&height=66"></iframe>
</div>

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-滑动窗口的最大值（剑指offer原59题）"><span class="nav-number">1.</span> <span class="nav-text">1.滑动窗口的最大值（剑指offer原59题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！-与剑指offer60题有点差别！"><span class="nav-number">2.</span> <span class="nav-text">2.n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！(与剑指offer60题有点差别！)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-扑克牌的顺子-剑指offer原61题"><span class="nav-number">3.</span> <span class="nav-text">3.扑克牌的顺子(剑指offer原61题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-圆圈中最后剩下的数字-剑指offer原62题-——约瑟夫环问题"><span class="nav-number">4.</span> <span class="nav-text">4.圆圈中最后剩下的数字(剑指offer原62题)——约瑟夫环问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-股票的最大利润（剑指offer原63题）"><span class="nav-number">5.</span> <span class="nav-text">5.股票的最大利润（剑指offer原63题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-求1-2-3-…-n，不能使用乘除法和各种循环、判断语句-剑指offer原64题"><span class="nav-number">6.</span> <span class="nav-text">6.求1+2+3+…+n，不能使用乘除法和各种循环、判断语句(剑指offer原64题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-不用加减乘除做加法-剑指offer原65题"><span class="nav-number">7.</span> <span class="nav-text">7.不用加减乘除做加法(剑指offer原65题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-构建乘积数组-剑指offer原66题-不能用除法、只能开一个数组"><span class="nav-number">8.</span> <span class="nav-text">8.构建乘积数组(剑指offer原66题)[不能用除法、只能开一个数组]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-把字符串转换成整数-剑指offer原67题"><span class="nav-number">9.</span> <span class="nav-text">9.把字符串转换成整数(剑指offer原67题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-树中两个结点的最低公共祖先-剑指offer原68题"><span class="nav-number">10.</span> <span class="nav-text">10.树中两个结点的最低公共祖先(剑指offer原68题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-数字在排序数组中出现的次数-剑指offer原53题—题目一）"><span class="nav-number">11.</span> <span class="nav-text">11.数字在排序数组中出现的次数(剑指offer原53题—题目一）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-0到n-1中缺失的数字-剑指offer原53题—-题目二"><span class="nav-number">12.</span> <span class="nav-text">12.0到n-1中缺失的数字(剑指offer原53题—-题目二)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-数组中数值和下标相等的元素-剑指offer原53题—-题目三"><span class="nav-number">13.</span> <span class="nav-text">13.数组中数值和下标相等的元素(剑指offer原53题—-题目三)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-二叉搜索树的第K个大的结点-剑指offer原54题"><span class="nav-number">14.</span> <span class="nav-text">14.二叉搜索树的第K个大的结点(剑指offer原54题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-二叉树的深度-剑指offer原55题"><span class="nav-number">15.</span> <span class="nav-text">15.二叉树的深度(剑指offer原55题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-平衡二叉树-剑指offer原55题—题目二"><span class="nav-number">16.</span> <span class="nav-text">16.平衡二叉树(剑指offer原55题—题目二)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-数组中只出现一次的两个数字-剑指offer原56题"><span class="nav-number">17.</span> <span class="nav-text">17.数组中只出现一次的两个数字(剑指offer原56题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-数组中唯一只出现一次的数字-剑指offer原56题—题目2"><span class="nav-number">18.</span> <span class="nav-text">18.数组中唯一只出现一次的数字(剑指offer原56题—题目2)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-和为s的数字-剑指offer原57题—-题目一"><span class="nav-number">19.</span> <span class="nav-text">19.和为s的数字(剑指offer原57题—-题目一)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-和为s的连续正数序列-剑指offer原57题—-题目二"><span class="nav-number">20.</span> <span class="nav-text">20.和为s的连续正数序列(剑指offer原57题—-题目二)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-翻转单词顺序-剑指offer原58题—-题目一"><span class="nav-number">21.</span> <span class="nav-text">21.翻转单词顺序(剑指offer原58题—-题目一)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-左旋转字符串-剑指offer原58题—-题目二"><span class="nav-number">22.</span> <span class="nav-text">22.左旋转字符串(剑指offer原58题—-题目二)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-数字序列中某一位的数字-剑指offer原44题"><span class="nav-number">23.</span> <span class="nav-text">23.数字序列中某一位的数字(剑指offer原44题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-把数组排成最小的数-剑指offer原45题"><span class="nav-number">24.</span> <span class="nav-text">24.把数组排成最小的数(剑指offer原45题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-把数字翻译成字符串-剑指offer原46题"><span class="nav-number">25.</span> <span class="nav-text">25.把数字翻译成字符串(剑指offer原46题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-礼物的最大价值-剑指offer原47题"><span class="nav-number">26.</span> <span class="nav-text">26.礼物的最大价值(剑指offer原47题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-最长不含重复字符的子字符串-剑指offer原48题"><span class="nav-number">27.</span> <span class="nav-text">27.最长不含重复字符的子字符串(剑指offer原48题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-丑数-剑指offer原49题-———求第n个丑数的值"><span class="nav-number">28.</span> <span class="nav-text">28.丑数(剑指offer原49题)———求第n个丑数的值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29-字符串中第一个只出现一次的字符-剑指offer原50题—-题目一"><span class="nav-number">29.</span> <span class="nav-text">29.字符串中第一个只出现一次的字符(剑指offer原50题—-题目一)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#30-字符流中第一个只出现一次的字符-剑指offer原50题—-题目二"><span class="nav-number">30.</span> <span class="nav-text">30.字符流中第一个只出现一次的字符(剑指offer原50题—-题目二)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#31-数组中的逆序对-剑指offer原51题）"><span class="nav-number">31.</span> <span class="nav-text">31.数组中的逆序对(剑指offer原51题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#32-两个链表的第一个公共结点-剑指offer原52题）"><span class="nav-number">32.</span> <span class="nav-text">32.两个链表的第一个公共结点(剑指offer原52题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#33-二叉搜索树的后序遍历序列-剑指offer原33题"><span class="nav-number">33.</span> <span class="nav-text">33.二叉搜索树的后序遍历序列(剑指offer原33题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#34-二叉树中和为某一值的路径-剑指offer原34题"><span class="nav-number">34.</span> <span class="nav-text">34.二叉树中和为某一值的路径(剑指offer原34题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#35-复杂链表的复制-剑指offer原35题"><span class="nav-number">35.</span> <span class="nav-text">35.复杂链表的复制(剑指offer原35题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#36-二叉搜索树与双向链表-剑指offer原36题"><span class="nav-number">36.</span> <span class="nav-text">36.二叉搜索树与双向链表(剑指offer原36题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#37-序列化二叉树-剑指offer原37题"><span class="nav-number">37.</span> <span class="nav-text">37.序列化二叉树(剑指offer原37题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#38-数字排列—-（与剑指offer38题不同）"><span class="nav-number">38.</span> <span class="nav-text">38.数字排列—-（与剑指offer38题不同）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#39-数组中出现次数超过一半的数字（寻找数组中的众数）-剑指offer原39题"><span class="nav-number">39.</span> <span class="nav-text">39.数组中出现次数超过一半的数字（寻找数组中的众数）(剑指offer原39题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#40-最小的k个数-剑指offer原40题"><span class="nav-number">40.</span> <span class="nav-text">40.最小的k个数(剑指offer原40题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#41-数据流中的中位数-剑指offer原41题"><span class="nav-number">41.</span> <span class="nav-text">41.数据流中的中位数(剑指offer原41题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#42-连续子数组的最大和-剑指offer原42题"><span class="nav-number">42.</span> <span class="nav-text">42.连续子数组的最大和(剑指offer原42题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#43-从1到n整数中1出现的次数-剑指offer原43题"><span class="nav-number">43.</span> <span class="nav-text">43.从1到n整数中1出现的次数(剑指offer原43题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#44-反转链表-剑指offer原24题"><span class="nav-number">44.</span> <span class="nav-text">44.反转链表(剑指offer原24题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#45-合并两个排序的链表-剑指offer原25题"><span class="nav-number">45.</span> <span class="nav-text">45.合并两个排序的链表(剑指offer原25题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#46-树的子结构—-树的匹配-剑指offer原26题"><span class="nav-number">46.</span> <span class="nav-text">46.树的子结构—-树的匹配(剑指offer原26题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#47-二叉树的镜像-剑指offer原27题"><span class="nav-number">47.</span> <span class="nav-text">47.二叉树的镜像(剑指offer原27题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#48-对称的二叉树-剑指offer原28题"><span class="nav-number">48.</span> <span class="nav-text">48.对称的二叉树(剑指offer原28题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#49-顺时针打印矩阵-剑指offer原29题"><span class="nav-number">49.</span> <span class="nav-text">49.顺时针打印矩阵(剑指offer原29题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#50-包含min函数的栈-剑指offer原30题"><span class="nav-number">50.</span> <span class="nav-text">50.包含min函数的栈(剑指offer原30题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#51-栈的压入与弹出序列-剑指offer原31题"><span class="nav-number">51.</span> <span class="nav-text">51.栈的压入与弹出序列(剑指offer原31题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#52-不分行从上往下打印二叉树-层序遍历-剑指offer原32题—-题目一"><span class="nav-number">52.</span> <span class="nav-text">52.不分行从上往下打印二叉树[层序遍历](剑指offer原32题—-题目一)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#53-分行从上往下打印二叉树-剑指offer原32题—-题目二"><span class="nav-number">53.</span> <span class="nav-text">53.分行从上往下打印二叉树(剑指offer原32题—-题目二)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#54-之字形打印二叉树-剑指offer原32题—-题目三"><span class="nav-number">54.</span> <span class="nav-text">54.之字形打印二叉树(剑指offer原32题—-题目三)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#55-机器人的运动范围-剑指offer原13题"><span class="nav-number">55.</span> <span class="nav-text">55.机器人的运动范围(剑指offer原13题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#56-剪绳子-剑指offer原14题"><span class="nav-number">56.</span> <span class="nav-text">56.剪绳子(剑指offer原14题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#57-二进制中1的个数-剑指offer原15题"><span class="nav-number">57.</span> <span class="nav-text">57.二进制中1的个数(剑指offer原15题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#58-数值的整数次方-剑指offer原16题"><span class="nav-number">58.</span> <span class="nav-text">58.数值的整数次方(剑指offer原16题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#59-在O-1-的时间复杂度内删除链表结点（剑指offer原18题—题目一）"><span class="nav-number">59.</span> <span class="nav-text">59.在O(1)的时间复杂度内删除链表结点（剑指offer原18题—题目一）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#60-删除链表中重复的结点（剑指offer原18题—题目二）"><span class="nav-number">60.</span> <span class="nav-text">60.删除链表中重复的结点（剑指offer原18题—题目二）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#61-正则表达式的匹配（剑指offer原19题）"><span class="nav-number">61.</span> <span class="nav-text">61.正则表达式的匹配（剑指offer原19题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#62-表示数值的字符串（剑指offer原20题）"><span class="nav-number">62.</span> <span class="nav-text">62.表示数值的字符串（剑指offer原20题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#63-调整数组顺序使奇数位于偶数前面（剑指offer原21题）"><span class="nav-number">63.</span> <span class="nav-text">63.调整数组顺序使奇数位于偶数前面（剑指offer原21题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#64-链表中倒数第k个节点（剑指offer原22题）"><span class="nav-number">64.</span> <span class="nav-text">64.链表中倒数第k个节点（剑指offer原22题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#65-链表中环的入口节点（剑指offer原23题）"><span class="nav-number">65.</span> <span class="nav-text">65.链表中环的入口节点（剑指offer原23题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#66-找出数组中重复的数字（剑指offer原3题—-题目一）"><span class="nav-number">66.</span> <span class="nav-text">66.找出数组中重复的数字（剑指offer原3题—-题目一）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#67-不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）"><span class="nav-number">67.</span> <span class="nav-text">67.不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#68-二维数组中的查找（剑指offer原4题）"><span class="nav-number">68.</span> <span class="nav-text">68.二维数组中的查找（剑指offer原4题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#69-替换空格（剑指offer原5题）"><span class="nav-number">69.</span> <span class="nav-text">69.替换空格（剑指offer原5题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#70-从尾到头打印链表（剑指offer原6题）"><span class="nav-number">70.</span> <span class="nav-text">70.从尾到头打印链表（剑指offer原6题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#71-重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）"><span class="nav-number">71.</span> <span class="nav-text">71.重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#72-二叉树的下一个节点（剑指offer原8题）"><span class="nav-number">72.</span> <span class="nav-text">72.二叉树的下一个节点（剑指offer原8题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#73-用两个栈实现一个队列（剑指offer原9题）"><span class="nav-number">73.</span> <span class="nav-text">73.用两个栈实现一个队列（剑指offer原9题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#74-斐波那契数列数列（剑指offer原10题）"><span class="nav-number">74.</span> <span class="nav-text">74.斐波那契数列数列（剑指offer原10题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#75-旋转数组的最小数字（剑指offer原11题）"><span class="nav-number">75.</span> <span class="nav-text">75.旋转数组的最小数字（剑指offer原11题）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#76-矩阵中的路径（剑指offer原12题）"><span class="nav-number">76.</span> <span class="nav-text">76.矩阵中的路径（剑指offer原12题）</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Curry_Coder</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">94.8k</span>
  
</div>










<span id="sitetime"></span>
<script language="javascript">
  function siteTime(){
    window.setTimeout("siteTime()", 1000);
    var seconds = 1000;
    var minutes = seconds * 60;
    var hours = minutes * 60;
    var days = hours * 24;
    var years = days * 365;
    var today = new Date();
    var todayYear = today.getFullYear();
    var todayMonth = today.getMonth()+1;
    var todayDate = today.getDate();
    var todayHour = today.getHours();
    var todayMinute = today.getMinutes();
    var todaySecond = today.getSeconds();
    var t1 = Date.UTC(2018,06,07,12,00,00); // 设置建立网站的时间
    var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);
    var diff = t2-t1;
    var diffYears = Math.floor(diff/years);
    var diffDays = Math.floor((diff/days)-diffYears*365);
    var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);
    var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);
    var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);
    document.getElementById("sitetime").innerHTML=" 已运行"+diffYears+" 年 "diffDays+" 天 "+diffHours+" 小时 "+diffMinutes+" 分钟 "+diffSeconds+" 秒";
  }
  siteTime();
</script>





        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

    
    
    
      <!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("q8qeb6W0A1TKruNAGBeHCyCY-gzGzoHsz", "B8xUzdVCBezIqnzLnsEVjReh");</script>
<script>
function showTime(Counter) {
	var query = new AV.Query(Counter);
	$(".leancloud_visitors").each(function() {
		var url = $(this).attr("id").trim();
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length == 0) {
					var content = '0 ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
					return;
				}
				for (var i = 0; i < results.length; i++) {
					var object = results[i];
					var content = object.get('time') + ' ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
				}
			},
			error: function(object, error) {
				console.log("Error: " + error.code + " " + error.message);
			}
		});

	});
}

function addCount(Counter) {
	var Counter = AV.Object.extend("Counter");
	url = $(".leancloud_visitors").attr('id').trim();
	title = $(".leancloud_visitors").attr('data-flag-title').trim();
	var query = new AV.Query(Counter);
	query.equalTo("url", url);
	query.find({
		success: function(results) {
			if (results.length > 0) {
				var counter = results[0];
				counter.fetchWhenSave(true);
				counter.increment("time");
				counter.save(null, {
					success: function(counter) {
						var content =  counter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(counter, error) {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
					}
				});
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
				newcounter.set("time", 1);
				newcounter.save(null, {
					success: function(newcounter) {
					    console.log("newcounter.get('time')="+newcounter.get('time'));
						var content = newcounter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(newcounter, error) {
						console.log('Failed to create');
					}
				});
			}
		},
		error: function(error) {
			console.log('Error:' + error.code + " " + error.message);
		}
	});
}
$(function() {
	var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else if ($('.post-title-link').length > 1) {
		showTime(Counter);
	}
}); 
</script>
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>
<script src="/js/src/photoswipe.min.js?v=5.1.4"></script>
<script src="/js/src/photoswipe-ui-default.min.js?v=5.1.4"></script>


  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'q8qeb6W0A1TKruNAGBeHCyCY-gzGzoHsz',
        appKey: 'B8xUzdVCBezIqnzLnsEVjReh',
        placeholder: '来都来了，请留下你的脚印吧~',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'manual') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("", "");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  


  

  

  <!-- 小红心 -->
  <script type="text/javascript" src="/js/src/love.js"></script>
  <script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0,104,183"></script>
  <!--卖萌-->
  <script type="text/javascript" src="/js/src/dytitle.js"></script>
  
  	 <!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("q8qeb6W0A1TKruNAGBeHCyCY-gzGzoHsz", "B8xUzdVCBezIqnzLnsEVjReh");</script>
<script>
function showTime(Counter) {
	var query = new AV.Query(Counter);
	$(".leancloud_visitors").each(function() {
		var url = $(this).attr("id").trim();
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length == 0) {
					var content = '0 ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
					return;
				}
				for (var i = 0; i < results.length; i++) {
					var object = results[i];
					var content = object.get('time') + ' ' + $(document.getElementById(url)).text();
					$(document.getElementById(url)).text(content);
				}
			},
			error: function(object, error) {
				console.log("Error: " + error.code + " " + error.message);
			}
		});

	});
}

function addCount(Counter) {
	var Counter = AV.Object.extend("Counter");
	url = $(".leancloud_visitors").attr('id').trim();
	title = $(".leancloud_visitors").attr('data-flag-title').trim();
	var query = new AV.Query(Counter);
	query.equalTo("url", url);
	query.find({
		success: function(results) {
			if (results.length > 0) {
				var counter = results[0];
				counter.fetchWhenSave(true);
				counter.increment("time");
				counter.save(null, {
					success: function(counter) {
						var content =  counter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(counter, error) {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
					}
				});
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
				newcounter.set("time", 1);
				newcounter.save(null, {
					success: function(newcounter) {
					    console.log("newcounter.get('time')="+newcounter.get('time'));
						var content = newcounter.get('time') + ' ' + $(document.getElementById(url)).text();
						$(document.getElementById(url)).text(content);
					},
					error: function(newcounter, error) {
						console.log('Failed to create');
					}
				});
			}
		},
		error: function(error) {
			console.log('Error:' + error.code + " " + error.message);
		}
	});
}
$(function() {
	var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else if ($('.post-title-link').length > 1) {
		showTime(Counter);
	}
}); 
</script>
  
  
  
<!-- calendar widget -->


    <script src="/lib/CloudCalendar/CloudCalendar.js"></script>
    <script src="/lib/CloudCalendar/languages.js"></script>
    <script type="text/javascript">
    $(function() {
        $('#CloudCalendar').aCalendar('zh-CN', 
            $.extend(
                '', {
                    single:true,
                    root:'/calendar/'
                }
            )
        );
    });
    </script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"tagMode":false});</script></body>
</html>

