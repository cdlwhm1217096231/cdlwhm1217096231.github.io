<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>shell脚本编程基础</title>
    <url>/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="技术交流QQ群-1027579432，欢迎你的加入！"><a href="#技术交流QQ群-1027579432，欢迎你的加入！" class="headerlink" title="技术交流QQ群:1027579432，欢迎你的加入！"></a>技术交流QQ群:1027579432，欢迎你的加入！</h3><h3 id="本教程使用Linux发行版Centos7-0系统，请您注意"><a href="#本教程使用Linux发行版Centos7-0系统，请您注意" class="headerlink" title="本教程使用Linux发行版Centos7.0系统，请您注意~"></a>本教程使用Linux发行版Centos7.0系统，请您注意~</h3><h4 id="1-使用多个命令"><a href="#1-使用多个命令" class="headerlink" title="1.使用多个命令"></a>1.使用多个命令</h4><ul>
<li><p>shell脚本的关键之处在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给另一个命令。shell可以让多个命令串起来，一次执行。<strong>如果要两个命令一起运行，可以将它们放在同一行，之间用逗号隔开</strong>。</p>
  <figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">[njust@njust tutorials]$ date;who</span><br><span class="line">2020年 03月 11日 星期三 22:39:16 CST</span><br><span class="line">njust    :0           2020<span class="string">-03</span><span class="string">-11</span> 22:28 (:0)</span><br><span class="line">njust    pts/0        2020<span class="string">-03</span><span class="string">-11</span> 22:35 (192.168.0.107)</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述方法的缺点：使用上述方法可以将任意多个命令串联在一起使用，最大命令行字符数不超过255个。对小型的脚本适用，当有很多脚本时，直接在命令行中输入整个命令就很麻烦。</p>
</li>
</ul>
<h4 id="2-创建shell脚本文件"><a href="#2-创建shell脚本文件" class="headerlink" title="2.创建shell脚本文件"></a>2.创建shell脚本文件</h4><ul>
<li><p>创建shell脚本文件时，<strong>必须在文件的第一行指定使用的shell是哪种类型</strong>，格式为：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shell脚本中注释一般以#开头，shell脚本不会处理注释的行。但是，shell脚本的第一行是例外。<strong>#后的!会告诉shell用哪个shell来运行脚本</strong>，shell会根据命令在文件中出现的先后顺序进行处理。下面是创建脚本名为demo的文件。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">date</span><br><span class="line">who</span><br></pre></td></tr></table></figure>
</li>
<li><p>存在的问题：如何让bash shell找到你创建的脚本文件？shell会通过PATH环境变量来查找命令。PATH环境变量被设置成只在一组目录中查找命令。</p>
  <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[njust<span class="meta">@njust</span> tutorials]$ echo $PATH</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin:/</span>usr<span class="regexp">/bin:/</span>usr<span class="regexp">/local/</span><span class="string">sbin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/home/</span>njust<span class="regexp">/.local/</span><span class="string">bin:</span><span class="regexp">/home/</span>njust/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>解决方法：让shell找到脚本文件，有两个方法：</p>
<ul>
<li>将shell脚本文件所处的目录添加到PATH环境变量中；</li>
<li>在命令行中使用绝对或相对的路径来引用shell脚本文件（常用）；</li>
</ul>
</li>
<li><p><strong>由于你还没有执行文件的权限，这是由于umask变量被设置为022，因此系统创建的文件只有读写权限</strong>。使用下面的命令赋予文件有可执行权限。</p>
  <figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">chmod u+<span class="keyword">x</span> demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了引用当前目录下的文件，可以在shell中使用单点操作符.。正式执行脚本demo</p>
  <figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">./demo</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-显示消息"><a href="#3-显示消息" class="headerlink" title="3.显示消息"></a>3.显示消息</h4><ul>
<li><p>在echo命令后加上一个字符串，该命令就会显示出这个文本字符串。默认情况下，不需要使用引号将需要显示的字符串包含起来。</p>
  <figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>echo hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
</li>
<li><p>当字符串中含有单引号或双引号时，可以使用双引号或单引号(注意叙述的顺序)包含该字符串。</p>
  <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[njust<span class="meta">@njust</span> tutorials]$ echo <span class="string">"Let's see if this'll work"</span></span><br><span class="line"><span class="type">Let</span><span class="symbol">'s</span> see <span class="keyword">if</span> <span class="keyword">this</span><span class="symbol">'ll</span> work</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>echo命令可以添加到shell脚本中任何需要显示额外信息的地方</strong>！</p>
</li>
<li>当需要把字符串和命令输出显示在同一行时，可以使用带参数n的echo命令，如下所示：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"The time and date are: "</span></span><br><span class="line">date</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">The time and date are: 2020年 03月 11日 星期三 23:07:03 CST</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-使用变量"><a href="#4-使用变量" class="headerlink" title="4.使用变量"></a>4.使用变量</h4><ul>
<li>变量可以将临时信息存储在shell脚本中，便于和shell中其他的命令一起使用。</li>
<li><strong>环境变量</strong>：shell维护一组环境变量，用来记录特定的系统信息。<strong>可以使用set命令来显示一份完整的当前环境变量列表</strong>。</li>
<li><p><strong>在脚本中，可以在环境变量名称前加上美元符号$从而来使用这些变量</strong>。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print information about logger</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"User info for userid: <span class="variable">$USER</span>"</span></span><br><span class="line"><span class="built_in">echo</span> UID: <span class="variable">$UID</span></span><br><span class="line"><span class="built_in">echo</span> HOME: <span class="variable">$HOME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">User info <span class="keyword">for</span> userid: njust</span><br><span class="line">UID: 1000</span><br><span class="line">HOME: /home/njust</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：echo命令中的环境变量会在脚本运行时替换成当前值，只要脚本在引号中出现美元符，它就会以为你在引用一个变量，因此在表示真实美元的含义时，需要在$符号前加\转义字符。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The cost of the item is \$5."</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>此外，还可以通过${变量名}的形式引用变量，变量名两侧的{}通常用于帮助识别美元符后的变量名。</p>
</li>
<li><strong>用户变量</strong>：除了环境变量外，shell还允许在脚本中定义和使用自己的变量。变量名使用字母、数字或下划线组成的字符串表示，长度最长不超过20个。</li>
<li><p>注意：<strong>使用等号将值赋给用户自定义的变量，在变量、等号和值之间不能出现空格</strong>！！！</p>
  <figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">var1</span>=<span class="number">23</span>  <span class="comment"># 等号左右不能出现空格！！</span></span><br><span class="line"><span class="attr">var2</span>=demo</span><br><span class="line"><span class="attr">var3</span>=testing</span><br><span class="line"><span class="attr">var4</span>=<span class="string">"hello shell"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期内，shell脚本定义的变量会一直存在，在shell脚本结束时会被删除。<strong>用户变量也可以通过$引用</strong>。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">days=10</span><br><span class="line">guest=<span class="string">"curry"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$guest</span> checked in <span class="variable">$days</span> days ago"</span></span><br><span class="line"></span><br><span class="line">days=5</span><br><span class="line">guest=<span class="string">"durant"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$guest</span> cheked in <span class="variable">$days</span> days ago"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">curry checked <span class="keyword">in</span> 10 days ago</span><br><span class="line">durant cheked <span class="keyword">in</span> 5 days ago</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量每次引用时，都会输出当前赋给它的值。引用一个变量时需要使用美元符号$，引用一个变量var1给另一个变量var2进行赋值时，被赋值的变量不要使用$。对var1忘记使用$号，就会使var2的赋值行变成普通的字符串。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=10</span><br><span class="line">var2=<span class="variable">$var1</span>  <span class="comment"># 在赋值语句中使用var1变量的值时，必须使用$符号</span></span><br><span class="line"><span class="built_in">echo</span> The resulting value is <span class="variable">$var2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">The resulting value is 10</span><br><span class="line"></span><br><span class="line">var2=var1;  <span class="comment"># 错误的代表案例，输出结果是普通字符串</span></span><br><span class="line"><span class="built_in">echo</span> The resulting value is <span class="variable">$var2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误结果</span></span><br><span class="line">The resulting value is var1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>命令替换</strong>：shell最有用的特性之一是从命令输出中提取出信息，并将其赋值给变量。将命令的输出赋值给变量后，就可以在脚本中使用了。有两种方法可以将命令输出赋值给变量：</p>
<ul>
<li>反引号字符`</li>
<li>$()格式</li>
</ul>
</li>
<li><p>命令替换允许你将shell命令的输出赋值给变量，具体如下所示：</p>
  <figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">testing=`<span class="built_in">date</span>`</span><br><span class="line">test=$(<span class="built_in">date</span>)</span><br><span class="line">echo The <span class="built_in">date</span> <span class="keyword">and</span> <span class="built_in">time</span> are: $testing</span><br><span class="line">echo The <span class="built_in">date</span> <span class="keyword">and</span> <span class="built_in">time</span> are: $test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">The <span class="built_in">date</span> <span class="keyword">and</span> <span class="built_in">time</span> are: <span class="number">2020</span>年 <span class="number">03</span>月 <span class="number">12</span>日 星期四 <span class="number">09</span>:<span class="number">11</span>:<span class="number">38</span> CST</span><br><span class="line">The <span class="built_in">date</span> <span class="keyword">and</span> <span class="built_in">time</span> are: <span class="number">2020</span>年 <span class="number">03</span>月 <span class="number">12</span>日 星期四 <span class="number">09</span>:<span class="number">11</span>:<span class="number">38</span> CST</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例：通过命令替换获得当前日期并用它来生成唯一的文件名。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy the /usr/bin/directory listing to a log file</span></span><br><span class="line"></span><br><span class="line">today=$(date +%y%m%d)  <span class="comment"># +%y%m%d格式是告诉date命令将日期显示为两位数的年月日数字组合</span></span><br><span class="line">ls /usr/bin -al &gt; <span class="built_in">log</span>.<span class="variable">$today</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">生成log.200312日志文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令替换会创建一个子shell来运行对应的命令，由该子shell所执行命令是无法使用脚本中所创建的变量。在命令行中使用路径./运行命令时，也会创建子shell；在运行命令时不加入路径，就不会创建子shell。</p>
</li>
</ul>
<h4 id="5-重定向输入和输出"><a href="#5-重定向输入和输出" class="headerlink" title="5.重定向输入和输出"></a>5.重定向输入和输出</h4><ul>
<li>重定向目的：想要保存某个命令的输出而不仅仅是让结果输出在屏幕上。</li>
<li><p><strong>输出重定向</strong>：最基本的重定向是将命令的输出发送在一个文件中。格式如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">具体命令 &gt; 输出文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>实例如下：</p>
  <figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>date &gt; test6</span><br><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>cat test6</span><br><span class="line"><span class="number">2020</span>年 <span class="number">03</span>月 <span class="number">12</span>日 星期四 09<span class="symbol">:</span><span class="number">40</span><span class="symbol">:</span>09 CST</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如果输出文件已经存在，重定向操作符会用新的文件数据覆盖已有文件</strong>。</p>
  <figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">[njust@njust tutorials]$ who &gt; test6</span><br><span class="line">[njust@njust tutorials]$ cat test6</span><br><span class="line">njust    :0           2020<span class="string">-03</span><span class="string">-11</span> 22:28 (:0)</span><br><span class="line">njust    pts/0        2020<span class="string">-03</span><span class="string">-12</span> 08:39 (192.168.0.107)</span><br><span class="line">njust    pts/1        2020<span class="string">-03</span><span class="string">-12</span> 08:41 (:0)</span><br></pre></td></tr></table></figure>
</li>
<li><p>有时候，你并不想覆盖原始文件中的内容，而是想将命令的输出追加到已有文件中。<strong>这种情况下，可以用&gt;&gt;来追加数据</strong>。</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">[njust@njust tutorials]$ date <span class="meta">&gt;&gt; </span>test6</span><br><span class="line">[njust@njust tutorials]$ cat test6</span><br><span class="line">njust    <span class="symbol">:</span><span class="number">0</span>           <span class="number">2020</span>-<span class="number">03</span>-<span class="number">11</span> <span class="number">22</span><span class="symbol">:</span><span class="number">28</span> (<span class="symbol">:</span><span class="number">0</span>)</span><br><span class="line">njust    pts/<span class="number">0</span>        <span class="number">2020</span>-<span class="number">03</span>-<span class="number">12</span> 08<span class="symbol">:</span><span class="number">39</span> (<span class="number">192.168</span>.<span class="number">0</span>.<span class="number">107</span>)</span><br><span class="line">njust    pts/<span class="number">1</span>        <span class="number">2020</span>-<span class="number">03</span>-<span class="number">12</span> 08<span class="symbol">:</span><span class="number">41</span> (<span class="symbol">:</span><span class="number">0</span>)</span><br><span class="line"><span class="number">2020</span>年 <span class="number">03</span>月 <span class="number">12</span>日 星期四 09<span class="symbol">:</span><span class="number">43</span><span class="symbol">:</span><span class="number">41</span> CST</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输入重定向</strong>：输入重定向将文件的内容重定向到命令，而不是将命令输出重定向到文件。输入重定向的格式：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">具体命令 &lt; 输入文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体实例：wc命令可以统计文件中的数据，默认情况下会输出3个值。</p>
  <figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>wc &lt; test6</span><br><span class="line"><span class="number">4</span>  <span class="number">21</span> <span class="number">186</span>  <span class="comment"># 从左到右分别表示文本的行数、文本的词数、文本的字节数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>内联输入重定向</strong>：&lt;&lt;无需使用文件进行重定向，只需要在命令行中指定输入重定向的数据即可。注意：<strong>必须指定一个文本标记来划分输入数据的起始和结尾。任何字符串都可以作为文本标记，但数据的起始和结尾文本标记必须一致</strong>。格式：</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">具体命令 <span class="meta">&gt;&gt; </span>EOF</span><br><span class="line">data</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
</li>
<li><p>在命令行中使用内联输入重定向时，shell会用PS2变量中定义的次提示符来提示用户输入数据。</p>
  <figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[njust@njust tutorials]$ wc &lt;&lt; <span class="literal">EOF</span></span><br><span class="line">&gt; test <span class="type">string</span> <span class="number">1</span>  # &gt;表示的就是次提示符</span><br><span class="line">&gt; test <span class="type">string</span> <span class="number">2</span></span><br><span class="line">&gt; test <span class="type">string</span> <span class="number">3</span></span><br><span class="line">&gt; <span class="literal">EOF</span></span><br><span class="line"><span class="number">3</span>  <span class="number">9</span> <span class="number">42</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-管道"><a href="#6-管道" class="headerlink" title="6.管道"></a>6.管道</h4><ul>
<li>管道的目的：一个命令的输出作为另一个命令的输入。</li>
<li><p>管道被放在命令之间，将一个命令的输出重定向到另一个命令中。基本格式如下：</p>
  <figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">命令<span class="number">1</span> | 命令<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>管道串器的两个命令不是依次执行的，Linux系统实际上会同时运行这两个命令，在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送个第二个命令。数据传输不会用的任何中间文件或缓冲区。</p>
</li>
<li><p>可以在一条命令中使用任意多条管道。可以持续地将命令的输出通过管道传给其他命令来细化操作。如下例所示：</p>
  <figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">rpm -qa | <span class="built_in">sort</span> | more  <span class="comment"># 先生成已安装包的列表，再排序，最后再用more显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想更精致点，可以搭配使用重定向和管道将输出保存到文件中</span></span><br><span class="line">rpm -qa | <span class="built_in">sort</span> &gt; rpm.list</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>管道最流行的用法之一就是将产生的大量输出通过管道传给more命令，一般与ls命令结合使用</strong>。</p>
</li>
</ul>
<h4 id="7-执行数学运算"><a href="#7-执行数学运算" class="headerlink" title="7.执行数学运算"></a>7.执行数学运算</h4><ul>
<li>在shell中有两个途径进行数学运算。<ul>
<li>expr命令</li>
<li>使用方括号</li>
</ul>
</li>
<li><p><strong>expr命令允许在命令行中处理数学表达式，但特别笨拙</strong>。许多expr命令操作符在shell中另有含义，当它们出现在expr命令中时，会得到一些诡异的结果。对那些容易被shell错误解释的字符，需要使用转义字符。</p>
  <figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>expr <span class="number">5</span> * <span class="number">2</span></span><br><span class="line"><span class="symbol">expr:</span> 语法错误</span><br><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>expr <span class="number">5</span> \* <span class="number">2</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在shell脚本中expr命令也同样复杂，如下所示：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=10</span><br><span class="line">var2=20</span><br><span class="line">var3=$(expr <span class="variable">$var2</span> / <span class="variable">$var1</span>)  <span class="comment"># 要将一个数学表达式的结果赋值给一个变量var3,也需要借助命令替换。</span></span><br><span class="line"><span class="built_in">echo</span> The result is <span class="variable">$var3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">The result is 2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在bash中，在将一个数学运算结果赋给一个变量时，可以使用美元符和[]将整个表达式圈起来</strong>。</p>
  <figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>var1=<span class="variable">$[</span><span class="number">1</span>+<span class="number">34</span>]</span><br><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>echo <span class="variable">$var1</span></span><br><span class="line"><span class="number">35</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用方括号执行shell运算比用expr命令方便很多，在shell脚本中也能看出。</p>
  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">var1</span>=10</span><br><span class="line"><span class="attribute">var2</span>=20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">var3</span>=`expr <span class="variable">$var2</span> / <span class="variable">$var1</span>`</span><br><span class="line">echo the result is <span class="variable">$var3</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">var1</span>=100</span><br><span class="line"><span class="attribute">var2</span>=200</span><br><span class="line"><span class="attribute">var3</span>=45</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">var4</span>=$[<span class="variable">$var1</span> * (<span class="variable">$var3</span> - <span class="variable">$var2</span>)]</span><br><span class="line">echo final result is <span class="variable">$var4</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">the result is 2</span><br><span class="line">final result is -15500</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>bash shell数学运算符只支持整数运算</strong>，这是一个巨大的限制。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=100</span><br><span class="line">var2=45</span><br><span class="line">var3=$[<span class="variable">$var1</span> / <span class="variable">$var2</span>]</span><br><span class="line"><span class="built_in">echo</span> The final result is <span class="variable">$var3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">The final result is 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>浮点数运算的解决方案：使用内建的bash计算器bc。bash计算器允许在命令行中输入浮点表达式，然后解释并计算该表达式，返回结果。</p>
</li>
<li><p>浮动运算是由内建变量scale控制的，这个值设置为你需要保留的小数点后几位。</p>
  <figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">[njust@njust ~]$ bc -q  # -q参数表示不显示欢迎信息</span><br><span class="line"><span class="number">3.44</span> /<span class="number">5</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">scale=<span class="number">4</span></span><br><span class="line"><span class="number">3.44</span> / <span class="number">5</span></span><br><span class="line"><span class="number">.6880</span></span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
</li>
<li><p>bash计算器还支持变量，如下所示：</p>
  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">bc -q</span><br><span class="line"><span class="attribute">var1</span>=10</span><br><span class="line">var1<span class="number">*4</span></span><br><span class="line">40</span><br><span class="line"><span class="attribute">var2</span>=var1 / 5</span><br><span class="line"><span class="builtin-name">print</span> var2</span><br><span class="line">2</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在脚本中使用bc</strong>：可以使用命令替换运行bc命令，并将输出赋值给一个变量，基本格式如下：</p>
  <figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">变量名=$(echo <span class="string">"可选项; 表达式"</span> <span class="string">| bc)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实例：在脚本中使用bc，如下所示。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=$(<span class="built_in">echo</span> <span class="string">"scale=4; 3.44/5"</span> | bc)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var1</span></span><br><span class="line">.6880</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述方法适用于较短的运算，但有时候涉及更多的数字。需要进行大量的运算，在一个命令行中列出多个表达式就会麻烦。解决方法：使用内联输入重定向，它允许你直接在命令行中重定向数据。基本格式为：</p>
  <figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">变量名=$(bc &lt;&lt; <span class="built_in">EOF</span></span><br><span class="line">可选项</span><br><span class="line">语句</span><br><span class="line">表达式</span><br><span class="line"><span class="built_in">EOF</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在bash计算器中创建的变量只在bash计算器中有效，不能在shell脚本中使用。</p>
  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">var1</span>=10.46</span><br><span class="line"><span class="attribute">var2</span>=43.67</span><br><span class="line"><span class="attribute">var3</span>=33.2</span><br><span class="line"><span class="attribute">var4</span>=71</span><br><span class="line"></span><br><span class="line"><span class="attribute">var5</span>=$(bc &lt;&lt; EOF</span><br><span class="line"><span class="attribute">scale</span>=4</span><br><span class="line">a1 = (<span class="variable">$var1</span> * <span class="variable">$var2</span>)</span><br><span class="line">b1 = (<span class="variable">$var3</span> * <span class="variable">$var4</span>)</span><br><span class="line">a1 + b1</span><br><span class="line">EOF</span><br><span class="line">)</span><br><span class="line">echo final result is <span class="variable">$var5</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">final result is 2813.9882</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="8-退出脚本"><a href="#8-退出脚本" class="headerlink" title="8.退出脚本"></a>8.退出脚本</h4><ul>
<li><p>shell中运行的每个命令都使用退出状态码，shell告诉它已经运行完毕。退出状态码是一个0到255的整数值，在命令结束时由命令传给shell，可以捕捉这个值在脚本中使用。<strong>Linux专门提供了变量$?来保存上一个已执行命令的退出状态码</strong>。对于需要进行检查的命令，必须在其运行完毕后立即查看或使用$?变量。</p>
  <figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>date</span><br><span class="line"><span class="number">2020</span>年 <span class="number">03</span>月 <span class="number">12</span>日 星期四 <span class="number">10</span><span class="symbol">:</span><span class="number">39</span><span class="symbol">:</span><span class="number">19</span> CST</span><br><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>echo <span class="variable">$?</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Linux退出状态码如下：</p>
  <figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span>          命令成功结束</span><br><span class="line"><span class="symbol">1 </span>          一般性未知错误</span><br><span class="line"><span class="symbol">2 </span>          不适合的<span class="keyword">shell</span>命令</span><br><span class="line"><span class="symbol">126 </span>        命令不可执行</span><br><span class="line"><span class="symbol">127 </span>        没找到命令</span><br><span class="line"><span class="symbol">128 </span>        无效的退出参数</span><br><span class="line"><span class="symbol">130 </span>        通过CTRL+C终止的命令</span><br></pre></td></tr></table></figure>
</li>
<li><p>exit命令：默认情况下，shell脚本会以脚本中最后一个命令的退出状态码退出。<strong>用户可以改变这种默认行为，返回自己的状态码。eixt命令允许在脚本结束时指定一个退出状态码</strong>。</p>
  <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=<span class="number">10</span></span><br><span class="line">var2=<span class="number">30</span></span><br><span class="line">var3=$[<span class="variable">$var1</span> + <span class="variable">$var2</span>]</span><br><span class="line">echo The answer is <span class="variable">$var3</span></span><br><span class="line"><span class="keyword">exit</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">The answer is <span class="number">40</span></span><br><span class="line">echo $?</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以在exit命令的参数中使用变量</span></span><br><span class="line"><span class="keyword">exit</span> <span class="variable">$var3</span></span><br><span class="line"></span><br><span class="line">echo $?</span><br><span class="line"><span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：退出状态码最大为255，超过最大的255后，会通过取模运算得到最后的结果即实际值 % 256 = 最结果</span></span><br><span class="line">var1=<span class="number">10</span></span><br><span class="line">var2=<span class="number">30</span></span><br><span class="line">var3=$[<span class="variable">$var1</span> * <span class="variable">$var2</span>]</span><br><span class="line">echo The answer is <span class="variable">$var3</span></span><br><span class="line"><span class="keyword">exit</span> <span class="variable">$var3</span></span><br><span class="line"></span><br><span class="line">echo $?</span><br><span class="line"><span class="number">44</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-资料下载"><a href="#9-资料下载" class="headerlink" title="9.资料下载"></a>9.资料下载</h4><ul>
<li><a href="https://github.com/cdlwhm1217096231/Linux/tree/master/Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">笔记，欢迎star,follow,fork……</a></li>
</ul>
]]></content>
      <categories>
        <category>shell脚本编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>2020个人Flag已立，欢迎监督！</title>
    <url>/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/2020%E4%B8%AA%E4%BA%BAFlag%E5%B7%B2%E7%AB%8B%EF%BC%8C%E6%AC%A2%E8%BF%8E%E7%9B%91%E7%9D%A3%EF%BC%81/</url>
    <content><![CDATA[<h3 id="技术交流QQ群-1027579432，欢迎你的加入！"><a href="#技术交流QQ群-1027579432，欢迎你的加入！" class="headerlink" title="技术交流QQ群:1027579432，欢迎你的加入！"></a>技术交流QQ群:1027579432，欢迎你的加入！</h3><p><img src="https://upload-images.jianshu.io/upload_images/13407176-5dedc361efb3f6cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个人Flag.png"></p>
]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>2020届秋招个人总结</title>
    <url>/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/2020%E5%B1%8A%E7%A7%8B%E6%8B%9B%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="技术交流QQ群-1027579432，欢迎你的加入！"><a href="#技术交流QQ群-1027579432，欢迎你的加入！" class="headerlink" title="技术交流QQ群:1027579432，欢迎你的加入！"></a>技术交流QQ群:1027579432，欢迎你的加入！</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>本人2020届，非科班211硕士，本科普通二本。同时，也是2020届秋招大军中的一员，由于我是毕业后辞职考研上岸的，因此个人年龄比其他同届毕业生大2到3岁，所以年龄在找工作中其实也是一个劣势。秋招经历了漫长的接近4个月煎熬，终于上岸了。下面将个人面试及相关感受记录分享下来，希望对有缘人有所帮助。</li>
</ul>
<h3 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h3><ul>
<li><strong>秋招准备开始阶段</strong><ul>
<li>我的秋招其实从3月份就开始了，那时候听取了实验室师兄的建议。尽早的就开始复习数据结构、C++ Prime、剑指offer、计算机网络(第六版)、MySQL数据库、Linux常用的指令、操作系统、Git、机器学习算法和NLP相关的模型(<strong>由于前期没想过找软件开发类的工作，一心想找算法岗。事实狠狠地打了我的脸，因此才让我认识到自己是一个大菜鸡</strong>)。这种状态一直持续到6月份，这个过程中自己也会写一些技术博客记录自己学习的知识点，由于自己是非计算机专业的，我知道自己需要补更多的计算机方面的知识。于是，我反复的看大话数据结构，也会写一些排序算法的程序。但是，由于前期没有意识到<strong>leetcode</strong>的重要性，一遇到难的编程题就不想做，所以编程能力很菜！（<strong>所以，一定要提前刷题，你会问不会咋办，我推荐我学习的一个网站，不是打广告！</strong>）学习C++语言的小伙伴可以<a href="https://www.acwing.com/solution/leetcode/" target="_blank" rel="noopener">点击此处有惊喜</a>。因此，对于后面参加秋招的小伙伴，如果自己没有质量好的论文、大厂实习、含金量高的比赛，不建议找算法岗，没有任何竞争力的！今年，算法岗已经是诸神黄昏了，后面只会更难（<strong>大神可以自行忽略</strong>）。建议尽早的转软件开发岗！前期需要准备的工作如下：<ul>
<li>LeetCode前200道必做！</li>
<li>剑指offer多刷几遍，自己看到题目就会写出程序的程度</li>
<li>数据结构、C++/Java编程语言基础、操作系统、数据库、Linux常用指令、计算机网络、Git、常见的机器学习算法(保险起见)！</li>
</ul>
</li>
</ul>
</li>
<li><strong>秋招笔试、面试阶段</strong><ul>
<li>时间到了7月份了，一些公司的提前批陆续已经开始了。比如中兴、顺丰、vivo、oppo、浦发银行、流利说、科大讯飞、同程艺龙等。至于提前批要不要投，提前批会不会对正式批有影响。大部分公司是有影响的，所以建议对于vivo、oppo这样的公司看本硕学历的，建议不要投提前批；对于中兴、浦发银行等一定要投提前批，一方面是由于这类公司的招聘流程很长，建议早投，太迟了就没hc了。校招投简历可以<a href="https://www.haitou.cc/" target="_blank" rel="noopener">点击此处有惊喜</a>，还有一些51job、智联招聘、<strong>你意向公司的官网</strong>等。然后8月份各大公司的正式批也开始了如中国农业银行总行、中国邮政、电信云、华为、天翼智慧家庭等。这些公司的正式批会有好几批组织的笔试和面试，尽量早投尽早参加笔试，后面可能没hc了，只是公司为了刷kpi，不招人的。下面我将我有幸进面试的公司面经分享如下：<ul>
<li>中兴ZTE：中兴我参加的是提前批，不用参加笔试。其实，中兴正式批的笔试也很水，基本都能进面试。因为后面会有很多人违约三方，因此中兴也会大量招人。中兴面试有点水，总共两面。一面是技术面（2对1）：我前期由于面的算法岗，因此就问问项目、比赛、梯度下降算法原理等，软开岗位的话听我同学说问问排序算法、进程与线程的区别、TCP/IP这些不过都不深，不会撕代码，顶多让你说下思路。二面是hr面(2对1)：就是聊聊项目、家庭情况、个人情况、就业地点、职业方向等，很水的。中兴基本面试都能过，那么你会问他怎么招人？中兴其实是<strong>更偏爱招男生，这里不是性别歧视的意思</strong>！因为，中兴是通信公司，开发岗位居多。加班的话1 2 4加班到晚上8点半吧，周六加班半天，性价比还可以的。面试过了的话，等很长时间会收到相应部门捞你的短信或者电话，通知你去现场洽谈，今年工资的白菜价应该是13*12,第一年没年终奖。总结<strong>中兴还是看学校、论文、成绩、比赛等给工资，不看个人开发能力</strong>，因此我拒绝了。</li>
<li>浦发银行合肥研发中心：浦发银行其实我非常想进，可惜面试被刷了。由于报的提前批，提前批凉凉了就没正式批的机会了。先是笔试，提前批的笔试考的是行测、英语、计算机基础知识，题目量大都是选择题，一般都能过。接着过几天会收到面试的通知，面试各个城市开始时间不同。面试分为现场上机编程和面试。上机撕代码都是不难的题目，leetcode简单和剑指offer上的题目，三道题目50分钟完成。上机完成后，进行面试过程。面试是7对1好像是，先自我介绍，再看你的成绩单，然后问一些C++/Java基础知识，<strong>数据库很重要，他们喜欢问数据库的知识</strong>，现场最后再口述一道编程题，只说思路就好！面试结束就可以离开了。如果8月份面试过了，11月份左右会收到邮件通知，通知你去体检，<strong>总的来说周期较长</strong>！工资待遇听我别的教研室同学说很好，合肥的话大概24*9600，喜欢稳定的同学可以去银行！</li>
<li>中国邮政研发中心：中国邮政是先组织考生去某个地点统一笔试，笔试考行测、计算机基础知识、邮政行情、性格测试。由于没有最后是性格测试，我瞎选了一通，结果笔试挂了。<strong>因此，大家一定要重视性格测试</strong>！不过，邮政集团的效率很慢，比浦发银行和农业银行总行都等的久。</li>
<li>农业银行总行：农行也是先组织考生去某个大学统一笔试，这个笔试是分批次的。先投的人先笔试和面试。笔试也是行测和计算机基础知识、最后性格测试，都是选择题。笔试过了，会通知你面试。面试的话先去现场手撕一道编程题，题目不难是leetcode简单级别和剑指offer上的题目。然后等面试，面试是群面。好像是8对10，每个人逐一介绍自己，然后面试官会根据你的简历来问你问题。对你感兴趣的话，会多问你一些。<strong>主要还是看本硕学历、相关实习经历、论文和成绩</strong>，由于本科二本没啥竞争力，面试凉凉。面试通过的同学等一段时候后会收到体检的通知，体检基本没问题，然后就上岸了。</li>
<li>华为：由于喜欢华为的企业文化，8月份投了软件开发岗位的志愿，9月安排笔试，笔试三道题目。题目不难，写成一道题目就可以进入面试。10月份才安排面试，<strong>从今年开始，华为面试就有三轮，前两轮面试会现场手撕代码，最后一名是总监面，我倒在了二面，面试又凉了一家</strong>。</li>
<li>江苏移动和移动设计院：这两家的面试的是无领导小组讨论，先是9月份面的移动设计院，再是11月初面的江苏移动。移动下的子公司的面试形式不太一样，像苏小研是技术面试，然后面试过了会通知你笔试好好准备，笔试过了基本就上岸了。笔试由移动集团在11月初全国统一组织考试；</li>
<li>zoom：zoom是我9月20几号面的，笔试做的很难，居然进了面试。和面试官约的是视频面试，由于C++深层的知识没有准备好，基础问题答上来了，C++更深层的知识不牢固，一面面试凉了。</li>
<li>新华三：新华三是10月12号左右来我们学校宣讲的，我也参加了。然后第二天安排的现场的笔试。笔试考了C/Java、操作系统、行测类型的选择题，还有两道编程题。笔试过了的话，会过几天通知你去某个酒店面试。面试分三轮，一天结束。一面是技术面问的知识很广，但是不难。从编程语言到计算机网络、操作系统，还有口述一道编程题的思路、还有笔试试卷上的题目。<strong>每面都会刷人，hr如果通知你可以直接回去了说明你凉凉了。二面是hr面，hr面也挂人，主要测试你的性格</strong>。三面是总监面，问项目和自己的实习和研究课题，也会问一些简单的技术问题。三面结束后就可以回去等通知了，华三每个城市的研发中心招聘结束后，总部进行技术岗位的汇总全国排序后再统一发offer，<strong>技术岗开奖的时间很久，我大概等了20多天。别的城市宣讲早的，等的时间更长</strong>。建议有别的offer的小伙伴可以等等，像我这样的0 offer的等的风险很大，凉凉就啥也没捞到了，等待的过程中压力会很大，晚上会失眠。还好，最终等到了。<strong>建议非全的小伙伴投华三要谨慎，新华三不收非全日制的好像</strong>。</li>
<li>南京信息技术研究院：这个研究院好像工资待遇非常好，不过是保密单位。在里面工作时是限制出国的，离职三年内也不能出国。研究院当然也是看学历的，由于来我们学校宣讲的，我是抱着试试的心态投的。宣讲完结束后，大概20天左右吧短信通知你去它们研究院现场笔试。报的人简直太多了，队排的很长！笔试是所有的研发岗一张卷子，因此考的题目很杂，例如：C++比Java考的多、计算机网络、大数据、机器学习、TensorFlow、操作系统、英语短文翻译等，总共两个小时。笔试结束后等通知，一般三天左右通知你去现场面试。由于我知道自己本科学校不行，面试我就没去，现在想想还是有些后悔。</li>
<li>银联商务公司：这家公司我是在学校就业网站上看的，网申后会统一一个时间在网上进行笔试，笔试的题目很简单，基本不刷人。笔试过了，当天晚上就会通知你第二天去某酒店去面试。同样的，我的本科学校不行，不太自信我也放弃了这家公司的面试。<strong>不过，这家公司今年有点坑，随便找个你性格测试有问题的理由单方面毁了意向书，随便打发了已经拿到这家公司offer的同学，真的是个坑啊</strong>！</li>
<li>联发科技：我错过了联发科技秋招的黄金时期，10月20几号联发科技到我们学校来宣讲的，感觉是最后一站了。宣讲会结束后，进行笔试。笔试题不难，技术开发岗就C语言，考的题目不难，编程题链表考的比较多。笔试过了，第二天会通知你去某个酒店面试。由于hr说软件开发岗的offer没了，问我愿不愿意转数字IC芯片岗，我觉得岗位不太适合，拒绝了。所以，<strong>对自己有意向的公司，一定要尽快投简历，避免错过网申的最佳时间</strong>！多看看牛客网、海投网以防错过最佳的时间，<strong>互联网相关的工作机会一般是金九银十，九月很重要</strong>！</li>
<li>恒生电子：恒生电子是全国最后一站了，此时我还没有offer。决定拼一把，先网上搜索恒生电子的笔试题目，<strong>重点练习了数据库的题目</strong>。恒生也是10月20几号到我们学校来宣讲的，宣讲会结束后，进行笔试。笔试考的C++/Java可选择其中一个，然后是数据库语法，还有一道编程题和算法题。最后加上行测题和性格测试。笔试完了，一般第二天会有通知，安排去当地某酒店面试。一面是群面，主要问问项目、实习和数据库等，<strong>主要是数据库和基本的排序算法</strong>。一面结束了可以回去了，等二面通知。一般是第二天通知二面，二面是hr+总监面，就问问个人情况、手上有没有其他的offer、期望薪水、笔试的一些题目。二面结束当天晚上就会有通知，过了的话就会有签约的邮件，第三天就去通知签约。由于自己没有offer在手，就去把一些个人资料交过去了，算是有个保底的。由于一直在等新华三，所以谎称三方没有下来，等下周三签约，恒生电子的工资是16*14+450*12。<strong>由于不太清楚这个公司在杭州咋样，不敢稀里糊涂的签约，违约金很高有点担心，所以拖了几天</strong>。（还好周二的时候收的的新华三的offer，运气还算好，不枉我等了好久）。</li>
<li>其中，还有笔试完就凉凉的公司，大华、阅文集团、一加手机、小米手机、招商银行信用卡中心、科大讯飞、步步高、携程、流利说、同程艺龙、广联达等，我猜想可能是由于我岁数有点大，同时是非科班的；一些简历直接挂了，如招银网络科技、vivo、oppo、顺丰科技等；还有一些公司测评挂了，如邮政公司、海康威视。<strong>大家一定要注意性格测试啊，真的会挂人</strong>！！！</li>
<li>还有一些银行，如中国工商银行、中国银行、农业银行省分行、建设银行、交通银行、民生银行、中信银行等，考的题目类型都差不多，行测+英语+计算机基础+性格测试等。<strong>中国银行题目量最大，大家注意补充能量</strong>。银行笔试完就等通知，目前已经收到的银行面试通知有农业银行省分行、中国银行、建设银行、交通银行，由于我的三方协议已经签了，所以就没有去面试了，<strong>个人感觉银行笔试应该是不刷人，基本都能进面试，面试完刷一部分人，然后差额体检再刷一部分人。有的银行还要去基层轮岗两年，各人有各人的看法吧</strong>。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li>
</ul>
</li>
</ul>
</li>
<li>啰嗦了一大堆，感谢大家能看完，哈哈。由于自己太菜了，和大佬不能比。至于为啥我选择新华三（恒生电子给的比较高，大概多4万） ，由于考虑家里的情况，离家近些可以照顾父母。因此，没有选择恒生电子，选择回家乡发展了。<strong>最后，祝大家都能拿到自己满意的offer，生活幸福</strong>！</li>
</ul>
<h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3><ul>
<li><a href="https://github.com/cdlwhm1217096231" target="_blank" rel="noopener">所有代码，欢迎star、fork</a></li>
<li><a href="https://www.jianshu.com/u/4645adadefec" target="_blank" rel="noopener">个人博客</a></li>
<li><a href="https://pan.baidu.com/s/1gVVrBtIVa4Nrwo1BL6-VIg" target="_blank" rel="noopener">软件开发校招资料合集，提取码: fg25</a></li>
</ul>
]]></content>
      <categories>
        <category>生活感悟</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>01移动端布局基础之流式布局</title>
    <url>/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/01%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h3 id="技术交流QQ群-1027579432，欢迎你的加入！"><a href="#技术交流QQ群-1027579432，欢迎你的加入！" class="headerlink" title="技术交流QQ群:1027579432，欢迎你的加入！"></a>技术交流QQ群:1027579432，欢迎你的加入！</h3><h4 id="1-移动端基础"><a href="#1-移动端基础" class="headerlink" title="1.移动端基础"></a>1.移动端基础</h4><ul>
<li><strong>浏览器现状</strong><ul>
<li>PC端常见浏览器：360浏览器、谷歌浏览器、火狐浏览器、QQ浏览器、百度浏览器、搜狗浏览器、IE浏览器等。<br>移动端常见浏览器：UC浏览器、QQ浏览器、欧朋浏览器、百度手机浏览器等。</li>
</ul>
</li>
<li>国内的UC、QQ、百度等手机浏览器都是根据Webkit修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于安卓修改开发的一样。</li>
<li><strong>总结：兼容移动端主流浏览器，处理Webkit内核浏览器即可</strong>。</li>
<li><strong>手机屏幕现状</strong><ul>
<li>移动端设备屏幕尺寸非常多，碎片化严重；</li>
<li>Android设备有多种分辨率：480*480、480*854、720*1280、1080*1920等；</li>
<li>作为开发者无需关注这些分辨率，因为常用的尺寸单位是px；</li>
</ul>
</li>
<li><strong>常见移动端屏幕尺寸</strong><br><img src="https://upload-images.jianshu.io/upload_images/13407176-3f1ff3cf24a20445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常见移动端屏幕尺寸.png"></li>
<li><strong>移动端调试方法</strong><ul>
<li>Chrome DevTools(谷歌浏览器)的模拟手机调试；</li>
<li>搭建本地web服务器，手机和服务器在一个局域网内，通过手机访问服务器；</li>
<li>使用外网服务器，直接IP或域名访问；</li>
</ul>
</li>
</ul>
<h4 id="2-视口"><a href="#2-视口" class="headerlink" title="2.视口"></a>2.视口</h4><ul>
<li>视口：<strong>浏览器显示页面内容的屏幕区域，视口可以分为布局视口、视觉视口、理想视口</strong>。</li>
<li><strong>布局视口layout viewport</strong><br><img src="https://upload-images.jianshu.io/upload_images/13407176-495c836b80b28244.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="布局视口.png"><ul>
<li>一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期PC端页面在手机上显示的问题；</li>
<li>IOS、Android基本都将这个视口分辨率设置为980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页；</li>
</ul>
</li>
<li><strong>视觉视口visual viewport</strong><br><img src="https://upload-images.jianshu.io/upload_images/13407176-ad0439ed712c587c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="视觉视口.png"><ul>
<li>它是用户正在看到的网站的区域。注意：<strong>是网站的区域</strong>；</li>
<li>我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍然保持原来的宽度；</li>
</ul>
</li>
<li><strong>理想视口ideal viewport</strong><ul>
<li>为了使网站能在移动端有最理想的浏览和阅读宽度而设定；</li>
<li>理想视口，对设备来说，是最理论的视口尺寸；</li>
<li>需要手动添加meta视口标签通知浏览器操作；</li>
<li>meta视口标签主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，布局视口就要有多宽。</li>
</ul>
</li>
</ul>
<h4 id="3-meta视口标签"><a href="#3-meta视口标签" class="headerlink" title="3.meta视口标签"></a>3.meta视口标签</h4><ul>
<li>语法格式： <figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">&lt;meta <span class="attr">name="viewport"</span> <span class="attr">content="width=device-width,</span> <span class="attr">user-scalable=no,</span> <span class="attr">initial-scale=1.0,</span> <span class="attr">maximum-scale=1.0,</span> <span class="attr">minimum-scale=1.0"&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-e6f98453e29928a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="meta视口标签属性.png"></p>
<ul>
<li>标准的viewport设置<ul>
<li>视口宽度和设备保持一致；</li>
<li>视口的默认缩放比例1.0；</li>
<li>不允许用户自行缩放；</li>
<li>最大允许的缩放比例1.0；</li>
<li>最小允许的缩放比例1.0；</li>
</ul>
</li>
</ul>
<h4 id="4-二倍图"><a href="#4-二倍图" class="headerlink" title="4.二倍图"></a>4.二倍图</h4><ul>
<li><strong>物理像素和物理像素比</strong><ul>
<li>物理像素指的是屏幕显示的最小颗粒，是物理中真实存在的。这是厂商在出厂时就设置好了。例如苹果手机的750*1334；</li>
<li>开发时的1px不是一定等于1个物理像素的；</li>
<li>PC端页面中，1px等于1个物理像素的，但是移动端就不尽相同；</li>
<li>1px能显示的物理像素点的个数，称为物理像素比或屏幕像素比；</li>
</ul>
</li>
</ul>
<h4 id="5-多倍图"><a href="#5-多倍图" class="headerlink" title="5.多倍图"></a>5.多倍图</h4><ul>
<li>PC端和手机端的手机屏幕/普通手机屏幕：1CSS像素=1物理像素</li>
<li>Retina(视网膜屏幕)是一种显示技术，可以把更多的物理像素点压缩至一块屏幕中，从而达到更高的分辨率，并提高屏幕显示的细腻程度。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-29b015652de3f813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="视网膜屏幕显示技术.png"></li>
<li>对于一张50px*50px的图片，在手机Retina屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊；</li>
<li>在标准的viewport设置中，使用倍图来提高图片的质量，解决在高清设备中的模糊问题；</li>
<li>通常使用二倍图，因为iphone8的影响，但是现在还存在3倍图、4倍图的情况，这个根据实际开发需求；</li>
<li>背景图片，注意缩放问题；</li>
</ul>
<h4 id="6-背景缩放background-size"><a href="#6-背景缩放background-size" class="headerlink" title="6.背景缩放background-size"></a>6.背景缩放background-size</h4><ul>
<li>background-size属性规定了背景图像的尺寸；</li>
<li><p>语法格式：</p>
  <figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">background</span>-<span class="built_in">size</span>: 背景图片宽度 背景图片高度;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单位：长度或百分比或cover或contain；</p>
</li>
<li>cover把背景图像扩展足够大，从而使背景图像完全覆盖背景区域；</li>
<li>contain把背景图像扩展到最大尺寸，从而使宽度和高度完全适应内容区域；</li>
<li>多倍图切图cutterman<ul>
<li>@1*1倍图原图</li>
<li>@2*2倍图</li>
<li>@3*3倍图</li>
</ul>
</li>
</ul>
<h4 id="7-移动端开发选择"><a href="#7-移动端开发选择" class="headerlink" title="7.移动端开发选择"></a>7.移动端开发选择</h4><ul>
<li>a.单独制作移动端页面(主流)：通常情况下，网址域名前面加m(mobile)可以打开移动端。通过判断设备，如果是移动设备打开，则跳动<strong>移动端页面</strong>。<ul>
<li>京东商城手机版</li>
<li>淘宝触屏版</li>
<li>苏宁易购手机版</li>
</ul>
</li>
<li>b.<strong>响应式</strong>页面兼容移动端(其次)：通过判断屏幕宽度改变样式，以适应不同终端。缺点：制作麻烦，需要花很多精力去调<strong>兼容性</strong>问题。<ul>
<li>三星手机官网</li>
</ul>
</li>
</ul>
<h4 id="8-移动端技术解决方案"><a href="#8-移动端技术解决方案" class="headerlink" title="8.移动端技术解决方案"></a>8.移动端技术解决方案</h4><ul>
<li><strong>移动端浏览器</strong><ul>
<li>移动端浏览器基本以webkit内核为主，因此就需要考虑webkit兼容性问题；</li>
<li>可以放心使用H5标签和CSS3样式；</li>
<li>同时，我们浏览器的私有前缀只需要考虑添加webkit即可；</li>
</ul>
</li>
<li><strong>CSS样式初始化</strong>normalize.css<ul>
<li>移动端CSS初始化推荐使用normalize.css；</li>
</ul>
</li>
<li><p><strong>CSS盒子模型box-sizing</strong></p>
<ul>
<li>传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding；</li>
<li><p>CSS3盒子模型：盒子的宽度 = CSS中设置的宽度width里面包含了border和padding。即CSS3中的盒子模型，padding和border不会撑大盒子；</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS3盒子模型 --&gt;</span></span><br><span class="line">box-sizing: border-box;</span><br><span class="line"><span class="comment">&lt;!-- 传统盒子模型 --&gt;</span></span><br><span class="line">box-sizing: content-box;</span><br></pre></td></tr></table></figure>
</li>
<li><p>移动端可以全部使用CSS3盒子模型；</p>
</li>
<li>PC端如果完全需要兼容，就使用传统盒子模型；如果不考虑兼容性，就选择CSS3盒子模型；</li>
</ul>
</li>
</ul>
<h4 id="9-特殊样式"><a href="#9-特殊样式" class="headerlink" title="9.特殊样式"></a>9.特殊样式</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS盒子模型 --&gt;</span></span><br><span class="line">box-sizing: border-box;</span><br><span class="line">-webkit-box-sizing: border-box;</span><br><span class="line"><span class="comment">&lt;!-- 点击高亮我们需要清除 设置transparent完成透明 --&gt;</span></span><br><span class="line">-webkit-tap-highlight-color: transparent;</span><br><span class="line"><span class="comment">&lt;!-- 在移动端浏览器默认的外观在IOS上加上这个属性才能给按钮和输入框自定义样式 --&gt;</span></span><br><span class="line">-webkit-appearance: none;</span><br><span class="line"><span class="comment">&lt;!-- 禁止长按页面时的弹出菜单 --&gt;</span></span><br><span class="line">img,a &#123;-webkit-touch-callout: none;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-移动端常见布局"><a href="#10-移动端常见布局" class="headerlink" title="10.移动端常见布局"></a>10.移动端常见布局</h4><ul>
<li>移动端布局和PC端有所区别：<ul>
<li>a.单独制作移动端页面(主流)<ul>
<li>流式布局(百分比布局)</li>
<li>flex弹性布局(强烈推荐)</li>
<li>less+rem+媒体查询布局</li>
<li>混合布局</li>
</ul>
</li>
<li>b.<strong>响应式</strong>页面兼容移动端(其次)<ul>
<li>媒体查询</li>
<li>bootstarp</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="11-移动端布局之流式布局"><a href="#11-移动端布局之流式布局" class="headerlink" title="11.移动端布局之流式布局"></a>11.移动端布局之流式布局</h4><ul>
<li>流式布局，就是百分比布局，也称为非固定像素布局；</li>
<li>通过盒子的宽度设置成百分比来根据屏幕的宽度进行伸缩，不受固定像素的限制，内容向两侧填充；</li>
<li>流式布局方式是移动web开发中使用的比较常见的布局方式；</li>
<li>max-width 最大宽度(max-height 最大高度)</li>
<li>min-width 最小宽度 (min-height 最小高度)</li>
</ul>
<h4 id="12-资料下载"><a href="#12-资料下载" class="headerlink" title="12.资料下载"></a>12.资料下载</h4><ul>
<li><a href="https://github.com/cdlwhm1217096231/HTML_CSS_JavaScript/tree/master/CSS3/01%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80" target="_blank" rel="noopener">笔记及代码，欢迎star,follow,fork……</a></li>
</ul>
<!-- <span id="inline-blue"> 站点配置文件 </span>
<span id="inline-purple"> 主题配置文件 </span>
<span id="inline-yellow"> 站点配置文件 </span>
<span id="inline-green"> 主题配置文件 </span> -->
]]></content>
      <categories>
        <category>Web前端开发</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer第二版题解(详细版)</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88%E9%A2%98%E8%A7%A3-%E8%AF%A6%E7%BB%86%E7%89%88/</url>
    <content><![CDATA[<h4 id="1-滑动窗口的最大值（剑指offer原59题）"><a href="#1-滑动窗口的最大值（剑指offer原59题）" class="headerlink" title="1.滑动窗口的最大值（剑指offer原59题）"></a>1.滑动窗口的最大值（剑指offer原59题）</h4><ul>
<li>解题思路：<strong>其实是一个队列的问题，用一个队列去维护当前窗口中的所有元素；首先将超出窗口中的队头元素先删掉，然后将新的元素插入当前窗口中，插入时要判断新插入的元素与队尾元素的大小，如果队尾元素较小，则先删除队尾元素再插入</strong>。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)   <span class="comment">// k是窗口的大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; q.front() &lt;= i - k) q.pop_front();  <span class="comment">// 将已经划出窗口中的元素从队列中删除</span></span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; nums[q.back()] &lt;= nums[i])  nums.pop_back();   <span class="comment">// 如果在队尾插入的元素大于等于当前队尾的元素值，就可以删除队尾的元素！</span></span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) res.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！-与剑指offer60题有点差别！"><a href="#2-n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！-与剑指offer60题有点差别！" class="headerlink" title="2.n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！(与剑指offer60题有点差别！)"></a>2.n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！(与剑指offer60题有点差别！)</h4><ul>
<li><p>解题思路：每次扔骰子，最小值是1，最大值是6；所以扔n个骰子在地上后的，最小值就是n，最大值就是6*n。dfs()算法的思路：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs方法来解决：注意两点，第一是状态的表示是什么(从输出中来)？第二是按照什么顺序来计算第一步中的状态？</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numberOfDice(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt;= <span class="number">6</span> * n; i++) res.push_back(dfs(n, i));  <span class="comment">// dfs(n, s)表示的就是所要输出的结果；也就是每次求总和是s的情况下，一共投了n次骰子，一共有多少种方案</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> !sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res += dfs(n - <span class="number">1</span>, sum - i);  <span class="comment">// 热狗法：最后一次骰子点数已经确定时，则只需要计算前面投了n-1次骰子，总和是s-i的情况下，一共有多少种方案。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态规划算法dp的思路：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dp方法来解决：注意三点，第一是状态的表示是什么(从输出中来)？第二是如何计算第一步中的状态？第三是边界问题</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numberOfDice(<span class="keyword">int</span> n)&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n * <span class="number">6</span> + <span class="number">1</span>));  <span class="comment">// dp的状态表示</span></span><br><span class="line">       f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 当所有的骰子都没有扔出时，总和s=0时，只有一种方案；总和s=1, 2, 3, 4, ....都是不合法的！</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;  <span class="comment">// 先循环扔出去的次数</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i * <span class="number">6</span>; j++)&#123;      <span class="comment">// 再循环总和s是多少</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= min(j, <span class="number">6</span>); k++)&#123;  <span class="comment">// 枚举最后一次的点数是多少</span></span><br><span class="line">                    f[i][j] += f[i- <span class="number">1</span>][j - k];  <span class="comment">// 状态f[i][j]表示前i次总和是j的方案数！</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt;= n * <span class="number">6</span>; i++) res.push_back(f[n][i]);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-扑克牌的顺子-剑指offer原61题"><a href="#3-扑克牌的顺子-剑指offer原61题" class="headerlink" title="3.扑克牌的顺子(剑指offer原61题)"></a>3.扑克牌的顺子(剑指offer原61题)</h4><ul>
<li>解题思路：模拟人的想法，先将<strong>除去了大小王之外</strong>的牌拿过来，如果有相同元素，则一定不是顺子！如果没有任何两个元素相同，看一下牌中最小值与最大值的差距是否在4以内。如果满足条件，则可以将缺失的部分用大小王来进行填补。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从扑克牌中随机抽5张牌，判断是不是一个顺子。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isContinous</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nums[k]) k++;   <span class="comment">// 去掉行首的0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt; nums.size(); i++)&#123;  <span class="comment">// 去掉重复元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums.back() - nums[k] &lt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-圆圈中最后剩下的数字-剑指offer原62题-——约瑟夫环问题"><a href="#4-圆圈中最后剩下的数字-剑指offer原62题-——约瑟夫环问题" class="headerlink" title="4.圆圈中最后剩下的数字(剑指offer原62题)——约瑟夫环问题"></a>4.圆圈中最后剩下的数字(剑指offer原62题)——约瑟夫环问题</h4><ul>
<li>解题思路：f(n,m)表示总共n个数字，每次报到数字m时，就将此数字从环中删除,最后剩下的数字。f(n-1,m)表示从剩下的n-1个数字中，每次报到数字m时，就将此数字从环中删除，最后剩下的数字。观察f(n,m)与f(n-1,m)之间的关系，可知f(n,m) = (f(n-1,m) + m) % n,其中边界条件是f(n==1, m) = 0;  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (lastRemaining(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-股票的最大利润（剑指offer原63题）"><a href="#5-股票的最大利润（剑指offer原63题）" class="headerlink" title="5.股票的最大利润（剑指offer原63题）"></a>5.股票的最大利润（剑指offer原63题）</h4><ul>
<li>解题思路：找出前i天的最小值，利用一个变量minValue来存储。第i天卖出的价格是nums[i]，最大利润res是等于第i天卖出价格与前i天中价格最低时买入的价格之差，此时获得的利润是最大的。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDiff</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;   <span class="comment">// 最大利润</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, minValue = nums[<span class="number">0</span>]; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            res = max(res, nums[i] - minValue);  <span class="comment">// minValue表示前i天的最小值，nums[i]表示第i天卖出的价格！</span></span><br><span class="line">            minValue = min(minValue, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-求1-2-3-…-n，不能使用乘除法和各种循环、判断语句-剑指offer原64题"><a href="#6-求1-2-3-…-n，不能使用乘除法和各种循环、判断语句-剑指offer原64题" class="headerlink" title="6.求1+2+3+…+n，不能使用乘除法和各种循环、判断语句(剑指offer原64题)"></a>6.求1+2+3+…+n，不能使用乘除法和各种循环、判断语句(剑指offer原64题)</h4><ul>
<li>解题思路：使用递归的思路来写，但是将当中的if语句，改成&amp;&amp;运算符。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        n &gt; <span class="number">0</span> &amp;&amp; (res += getSum(n - <span class="number">1</span>));   <span class="comment">// 实际是对if(n &gt; 0) res += getSum(n - 1);语句的改写</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="7-不用加减乘除做加法-剑指offer原65题"><a href="#7-不用加减乘除做加法-剑指offer原65题" class="headerlink" title="7.不用加减乘除做加法(剑指offer原65题)"></a>7.不用加减乘除做加法(剑指offer原65题)</h4><ul>
<li>解题思路：模拟计算机中的加法A + B，结果是CD。其中C是十位，D是个位。A和B对应位上的取值有四种(0 0、0 1、1 0、1 1)，C上的结果是(0 0 0 1),D上的结果是(0 1 1 0)。可以将C上的结果看出(A对应位上的取值 &amp; B对应位上的取值)；将D上的结果看出(A对应位上的取值 ^ B对应位上的取值)。因此，可以将多位数相加A + B可以看出是A + B= A^B(无进位) + (A &amp; B &lt;&lt; 1)(A &amp; B表示的就是进位)。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num2)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 ^ num2;</span><br><span class="line">            <span class="keyword">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="8-构建乘积数组-剑指offer原66题-不能用除法、只能开一个数组"><a href="#8-构建乘积数组-剑指offer原66题-不能用除法、只能开一个数组" class="headerlink" title="8.构建乘积数组(剑指offer原66题)[不能用除法、只能开一个数组]"></a>8.构建乘积数组(剑指offer原66题)[不能用除法、只能开一个数组]</h4><ul>
<li>解题思路：B[i] = A[0] * A[1] * … * A[i-1] * A[i+1] * … * A[n-1]。可以先算i的左半边 A[0] * A[1] * … * A[i-1]，然后算i的右半边A[i+1] * … * A[n-1]，最后两部分相乘。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先算A[0]到A[i-1]的乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            B[i] = p;</span><br><span class="line">            p *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再算A[i+1]到A[n-1]的乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>, p = <span class="number">1</span>; ~i; i--)&#123;</span><br><span class="line">            B[i] *= p;</span><br><span class="line">            p *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-把字符串转换成整数-剑指offer原67题"><a href="#9-把字符串转换成整数-剑指offer原67题" class="headerlink" title="9.把字符串转换成整数(剑指offer原67题)"></a>9.把字符串转换成整数(剑指offer原67题)</h4><ul>
<li>解题思路：处理好各种边界问题！  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; str.size() &amp;&amp; str[k] == <span class="string">' '</span>) k++;  <span class="comment">// 忽略所有的行首空格！</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> is_minus = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 忽略完行首的空格后，可能有-/+的符号</span></span><br><span class="line">        <span class="keyword">if</span>(str[k] == <span class="string">'+'</span>) k++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[k] == <span class="string">'-'</span>) k++, is_minus = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k &lt; str.size() &amp;&amp; str[k] &gt;= <span class="string">'0'</span> &amp;&amp; str[k] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">            number = number * <span class="number">10</span> + str[k] - <span class="string">'0'</span>;   <span class="comment">// 字符串表示的数字转换成真正的数字</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is_minus) number *= <span class="number">-1</span>;  <span class="comment">// 处理负数的情况</span></span><br><span class="line">        <span class="keyword">if</span>(number &gt; INT_MAX) number = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(number &lt; INT_MIN) number = INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="10-树中两个结点的最低公共祖先-剑指offer原68题"><a href="#10-树中两个结点的最低公共祖先-剑指offer原68题" class="headerlink" title="10.树中两个结点的最低公共祖先(剑指offer原68题)"></a>10.树中两个结点的最低公共祖先(剑指offer原68题)</h4><ul>
<li>解题思路：给出的两个结点的位置可能有两种情况，一种是两个结点出现在一个结点的左右两个子树上；另一种是一个给定的结点出现最低公共祖先节点上，另一个给定的结点出现在左子树或右子树上！<br>具体的方法是：先遍历左子树，检查是否有给定的两个结点p、q；再遍历右子树，检查是否有给定的两个结点p、q。如果左右子树中同时出现了p、q，则当前结点就是需要返回的就是最低公共祖先结点；如果只在左子树或右子树中出现p、q，则返回值就是p、q的最低公共祖先。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 空树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> left = lowestCommonAncestor(root-&gt;left, p, q);   <span class="comment">// 检查一下左边是否有p和q</span></span><br><span class="line">        <span class="keyword">auto</span> right = lowestCommonAncestor(root-&gt;right, p, q);  <span class="comment">// 检查一下右边是否有p和q</span></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="11-数字在排序数组中出现的次数-剑指offer原53题—题目一）"><a href="#11-数字在排序数组中出现的次数-剑指offer原53题—题目一）" class="headerlink" title="11.数字在排序数组中出现的次数(剑指offer原53题—题目一）"></a>11.数字在排序数组中出现的次数(剑指offer原53题—题目一）</h4><ul>
<li>解题思路：<strong>二分法解决！</strong>就是此数字第一次出现的位置与此数字最后一次出现的位置，两者之间的数的个数就是该数字出现的次数！  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; k) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[l] != k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = l;</span><br><span class="line">        l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= k) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="12-0到n-1中缺失的数字-剑指offer原53题—-题目二"><a href="#12-0到n-1中缺失的数字-剑指offer原53题—-题目二" class="headerlink" title="12.0到n-1中缺失的数字(剑指offer原53题—-题目二)"></a>12.0到n-1中缺失的数字(剑指offer原53题—-题目二)</h4><ul>
<li>题目要求的是：长度为n的数组,将其中的一个数删掉，只剩下n-1个数了。将剩下的n-1个数作为程序的输入，找出被删除的那个数！</li>
<li>解题思路：先计算0到n-1中的n个数的和，再减去当前序列中的每个数，也就可以得到答案了。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;  <span class="comment">// nums是输入的n-1个数</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = (n - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums) res -= x;</span><br><span class="line">        <span class="keyword">return</span> res;   <span class="comment">// res就是0到n-1中缺失的那个数字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="13-数组中数值和下标相等的元素-剑指offer原53题—-题目三"><a href="#13-数组中数值和下标相等的元素-剑指offer原53题—-题目三" class="headerlink" title="13.数组中数值和下标相等的元素(剑指offer原53题—-题目三)"></a>13.数组中数值和下标相等的元素(剑指offer原53题—-题目三)</h4><ul>
<li>解题思路：因为给定的数组nums具有单调递增的性质，可以使用二分查找，时间复杂度是O(logn)。考察数组nums[i]-i是否具有单调性。即（nums[i]-i &gt;= nums[i-1] - (i-1)是否成立？）  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] - mid &gt;= <span class="number">0</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[r] - r == <span class="number">0</span>) <span class="keyword">return</span> r;  <span class="comment">// 相等元素的下标</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="14-二叉搜索树的第K个大的结点-剑指offer原54题"><a href="#14-二叉搜索树的第K个大的结点-剑指offer原54题" class="headerlink" title="14.二叉搜索树的第K个大的结点(剑指offer原54题)"></a>14.二叉搜索树的第K个大的结点(剑指offer原54题)</h4><ul>
<li>解题思路：先对二叉搜索树进行中序遍历，每遍历到一个结点后，就对K进行减一操作。直到k减小到0后，就已经找到了第K个大的结点。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        dfs(root, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;left, k);  <span class="comment">// 中序遍历</span></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(!k) ans = root;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span>) dfs(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="15-二叉树的深度-剑指offer原55题"><a href="#15-二叉树的深度-剑指offer原55题" class="headerlink" title="15.二叉树的深度(剑指offer原55题)"></a>15.二叉树的深度(剑指offer原55题)</h4><ul>
<li>解题思路：深度就是找出从根结点到叶子节点的路径最长长度！具体就是找出根节点的左右子树两者中更长者的深度+1，即二叉树的深度。左右子树的深度用递归的方法来求解，当递归到叶子节点时，递归停止！  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 递归终止条件！</span></span><br><span class="line">        <span class="keyword">return</span> max(treeDepth(root-&gt;left), treeDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="16-平衡二叉树-剑指offer原55题—题目二"><a href="#16-平衡二叉树-剑指offer原55题—题目二" class="headerlink" title="16.平衡二叉树(剑指offer原55题—题目二)"></a>16.平衡二叉树(剑指offer原55题—题目二)</h4><ul>
<li>解题思路：利用上一题的思路，求出左右子树的深度之差是否是大于1的，如果所有点的深度差都不大于1的话，则是平衡二叉树；如果任意一个结点的左右子树深度之差大于1，则一定是非平衡二叉树!  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root-&gt;left), right = dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>;  <span class="comment">// 当前结点的深度 == 当前结点左右子树的深度的更大者 + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="17-数组中只出现一次的两个数字-剑指offer原56题"><a href="#17-数组中只出现一次的两个数字-剑指offer原56题" class="headerlink" title="17.数组中只出现一次的两个数字(剑指offer原56题)"></a>17.数组中只出现一次的两个数字(剑指offer原56题)</h4><ul>
<li>原题是：一个数组中除了两个数字之外，其他数字都出现了2次。利用程序找出这两个只出现一次的数字！</li>
<li>解题思路：<ul>
<li><strong>先考虑一种简单的情况</strong>，数组中除了一个数字只出现一次外，其余数字都出现了2次，找出这个只出现一次的数字。<strong>利用异或运算的特点，所有出现两次的数字异或时都被消成0，再将异或结果与只出现一次的数字进行异或，结果就是我们要找的数字</strong>。</li>
<li>本题中只出现一次的数字有两个，如何找出这两个只出现一次的数呢?<strong>*利用上面一样的操作，对所有的数字执行异或操作，得到的结果是两个只出现一次的数字的异或，由于两个数字都只出现一次。因此，最终的异或结果肯定不等于0</strong>。因为两个只出现一次的数字的异或的结果不等于0，所以异或结果的二进制表示中肯定有一位是1。假设异或结果中的第3位是1，则两个只出现一次的数字二进制表示的第3位一定是不相同的。<strong>此时，将原始数组中所有数字划分成两个集合，划分的依据就是看数组中每个数字的第3位是0还是1。因此，两个只出现一次的数字一定不在同一个集合中！所有出现两次的数字一定在同一个集合中！此时，两个集合中的数字就转化成最开始讨论的一种简单情况的例子</strong>。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumsAppearance(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) sum ^= x;   <span class="comment">// 先求所有数字的异或和,也就是sum = x ^ y  x,y分别表示数组中只出现一次的数字</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(sum &gt;&gt; k &amp; <span class="number">1</span>)) k++;  <span class="comment">// 然后从sum中找出其二进制表示中任意一位不为0的位，k存储的就是x ^ y结果中第k位是1的那一位</span></span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;&gt; k &amp; <span class="number">1</span>)   <span class="comment">// 将x的二进制表示中第k位是1的划分到第一个集合first中！</span></span><br><span class="line">                first ^= x;  <span class="comment">// 第一个集合异或的结果first  第二个结果异或的结果first ^ sum</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;first, sum ^ first&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="18-数组中唯一只出现一次的数字-剑指offer原56题—题目2"><a href="#18-数组中唯一只出现一次的数字-剑指offer原56题—题目2" class="headerlink" title="18.数组中唯一只出现一次的数字(剑指offer原56题—题目2)"></a>18.数组中唯一只出现一次的数字(剑指offer原56题—题目2)</h4><ul>
<li>原题目：一个数组中除了一个数字只出现一次外，其他数字都出现了三次，找出那个只出现一次的数字。</li>
<li>解题思路：<strong>有限状态机原理，初始的状态是(ones=0,twos=0);输入的数字的二进制表示中某一位是1时，状态转移成(1,0),接着数字的二进制表示中某一位仍然是1时，状态转移成(0,1),接着数字的二进制表示中某一位继续是1时，状态转移成(0,0)。也就是每三个状态构成一个循环；当输入的数字的二进制表示中某一位是0时，从初始的状态是(ones=0,twos=0)转移至自身(0,0)；当所有的输入数字中某一位出现次数是%3余1时，状态就转移到(1,0)；当所有的输入数字中某一位出现次数是%3余0时，状态就转移到(0,0)状态</strong>。ones就代表了上面两种情况的结果。数组中唯一只出现一次的数字。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumberAppearingOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            ones = (ones ^ x) &amp; ~twos;</span><br><span class="line">            twos = (twos ^ x) &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="19-和为s的数字-剑指offer原57题—-题目一"><a href="#19-和为s的数字-剑指offer原57题—-题目一" class="headerlink" title="19.和为s的数字(剑指offer原57题—-题目一)"></a>19.和为s的数字(剑指offer原57题—-题目一)</h4><ul>
<li><p>解题思路1：暴力解法，先依次遍历每个数字，遍历到某个数字时，固定这个数字。再依次判断数组中其余的n-1个数字与它的和是否等于target。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力解法O(n**2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumberWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[j]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解题思路2：对第二重循环进行优化，第二重循环的目的是判断对于j &lt; i这个范围内，是否存在一个数字nums[j]使得target - nums[i] == nums[j]成立。因此，可以使用哈希表来统计数字nums[j]是否出现从而来优化，使得时间复杂度变成O(n)。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumberWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.count(target - nums[i])) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;target - nums[i], nums[i]&#125;;  <span class="comment">// hash.count(target - nums[i])就是判断nums[j]是否在j &lt; i的范围内出现！</span></span><br><span class="line">            hash.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="20-和为s的连续正数序列-剑指offer原57题—-题目二"><a href="#20-和为s的连续正数序列-剑指offer原57题—-题目二" class="headerlink" title="20.和为s的连续正数序列(剑指offer原57题—-题目二)"></a>20.和为s的连续正数序列(剑指offer原57题—-题目二)</h4><ul>
<li>原题：<strong>输入一个正数s,输出所有和为s的连续正数序列</strong>，序列中至少含有两个数。</li>
<li>解题思路：暴力方法是给出区间的起点i,再给出区间的终点j。利用求和公式计算出区间[i,j]中数字的和是否为s，时间复杂度是O(n<strong>2)。改进的方法是：假设区间[i,j]中数字的和是s，当区间左端点i向右移动到i1时，</strong>区间的右端点j也会向右移动到j1，如果右端点j向左移动到j2，则区间[i1,j2]中的数字之和一定是小于s的**。总结起来就是使用双指针算法，时间复杂度变成O(n)。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力方法：O(n**2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> sum)&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, s = <span class="number">1</span>; i &lt;= sum; i++)  <span class="comment">// s是当前序列的和</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span>(s &lt; sum) s += ++j;</span><br><span class="line">           <span class="keyword">if</span>(s == sum &amp;&amp; j - i + <span class="number">1</span> &gt; <span class="number">1</span>)&#123;  <span class="comment">// [i,j]中包含的元素个数是: j - i + 1</span></span><br><span class="line">               <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; line;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++) line.push_back(k);  <span class="comment">// line是一个一维数组，数组中存放的是区间[i,j]中和为s的数字</span></span><br><span class="line">               res.push_back(line);</span><br><span class="line">           &#125;</span><br><span class="line">           s -= i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="21-翻转单词顺序-剑指offer原58题—-题目一"><a href="#21-翻转单词顺序-剑指offer原58题—-题目一" class="headerlink" title="21.翻转单词顺序(剑指offer原58题—-题目一)"></a>21.翻转单词顺序(剑指offer原58题—-题目一)</h4><ul>
<li>原题：输入一个句子，翻转句子中单词的顺序，但每个单词内的字母顺序不变。</li>
<li>解题思路：先用双指针i和j，将整个句子的每个单词以字母为单位进行翻转；然后对句子的每个单词进行翻转。  <figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">string</span> reverseWords(<span class="keyword">string</span> s)&#123;</span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());  <span class="comment">// 等价于for(int i = 0, j = s.size() - 1; i &lt; j; i++, j--) swap(s[i], s[j]); 第一步首先对整个句子进行翻转</span></span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;  <span class="comment">// 对第一步中翻转后的每个单词进行翻转，下面是从一段字符串中提取出一个单词的操作！</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="built_in">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] != <span class="string">' '</span>) j++;</span><br><span class="line">            reverse(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + j);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="22-左旋转字符串-剑指offer原58题—-题目二"><a href="#22-左旋转字符串-剑指offer原58题—-题目二" class="headerlink" title="22.左旋转字符串(剑指offer原58题—-题目二)"></a>22.左旋转字符串(剑指offer原58题—-题目二)</h4><ul>
<li>原题是：将字符串中的前面的前n位移动到字符串的尾部。</li>
<li>解题思路：和上一题一样的思路，先对整个字符串进行翻转。然后将翻转后的结果分成两个部分：前str.size() - n个字符和倒数n个字符，然后分别对上面的两部分进行翻转即可。  <figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">string</span> leftRotateString(<span class="keyword">string</span> str, <span class="keyword">int</span> n)&#123;</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>() + str.<span class="built_in">size</span>() - n);</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>() + str.<span class="built_in">size</span>() - n, str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="23-数字序列中某一位的数字-剑指offer原44题"><a href="#23-数字序列中某一位的数字-剑指offer原44题" class="headerlink" title="23.数字序列中某一位的数字(剑指offer原44题)"></a>23.数字序列中某一位的数字(剑指offer原44题)</h4><ul>
<li>解题思路：<ul>
<li>1.确定是几位数（n - 10*1 - 90*2 - 900*3 - …）</li>
<li>2.确定是几位数的第几个数</li>
<li>3.确定那个数的第几位</li>
</ul>
</li>
<li>详细过程：首先要确定第n位对应的数字在什么范围内，也就是确定第n位对应的数字是几位数。因为一位数有10个，占10位，两位数有90个，占180位，三位数有900个，占2700位。假设输入的是第1000位，则第1000位对应的应该是一个三位数（因为1000-10-180 = 720 &lt; 2700）；然后确定第1000位对应的是哪个三位数上的某一位。因为经过上一步的分析可知，输入的第1000位出现在两位数之后的第720位，因为三位数每个数占3位，所以输入的第1000位对应的应该是第240个三位数中的某一位！由于三位数从100开始，所以第240个三位数是100 + 240 - 1 = 339；最后确定对应是339中的哪一位（因为720 / 3 = 240，所以应该对应339的最后一位9）  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>, s = <span class="number">9</span>, base = <span class="number">1</span>;  <span class="comment">// i是几位数  s是几位数的个数  base是几位数的开始第一个数字</span></span><br><span class="line">        <span class="comment">// 确定n对应是几位数</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; i * s)&#123;</span><br><span class="line">            n -= i * s;</span><br><span class="line">            i++;</span><br><span class="line">            s *= <span class="number">10</span>;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定是几位数中的哪个数</span></span><br><span class="line">        <span class="keyword">int</span> number = base + (n + i - <span class="number">1</span>) / i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 确定那个数的第几位</span></span><br><span class="line">        <span class="keyword">int</span> r = n % i ? n % i : i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - r; j++) number /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="24-把数组排成最小的数-剑指offer原45题"><a href="#24-把数组排成最小的数-剑指offer原45题" class="headerlink" title="24.把数组排成最小的数(剑指offer原45题)"></a>24.把数组排成最小的数(剑指offer原45题)</h4><ul>
<li>解题思路：首先在数组中定义两个数字之间的小于&lt;关系：即a &lt; b等价于ab &lt; ba。然后将原始的输入数组按照定义的小于关系重新排序，一次拼接派好序后的数组中的数字即可。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> as = to_string(a), bs = to_string(b);</span><br><span class="line">        <span class="keyword">return</span> as + bs &lt; bs + as;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">printMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end(), cmp);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) res += to_string(x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="25-把数字翻译成字符串-剑指offer原46题"><a href="#25-把数字翻译成字符串-剑指offer原46题" class="headerlink" title="25.把数字翻译成字符串(剑指offer原46题)"></a>25.把数字翻译成字符串(剑指offer原46题)</h4><ul>
<li>解题思路：<strong>大部分计数的问题，可以看成是动态规划的问题</strong>。问题的关键是<strong>a.状态表示 b.状态如何计算 c.边界怎么定义</strong>。f(i)表示前i位数字一共有多少种翻译方式，f(i)<br>如何计算？如果将第i位数字单独翻译成一个字母，则f(i)可表示为前i-1位数字一共有多少种翻译方式；如果将第i位和第i-1位数字翻译成两个个字母，则f(i)可表示为前i-2为数字一共有多少种翻译方式。综合上述两种情况,f(i) = f(i-1) + f(i-2)。<strong>注意第二种情况：f(i-2)是将第i和第i-1位数字联合起来翻译成字母，因此必须有约束,范围是[10,25]之间</strong>。最后，考虑边界f(0) = 1。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTranslationCount</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n+<span class="number">1</span>);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>];   <span class="comment">// 第一种情况</span></span><br><span class="line">            <span class="keyword">int</span> t = (s[i<span class="number">-2</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + s[i<span class="number">-1</span>] - <span class="string">'0'</span>;  <span class="comment">// 第二种情况</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">25</span>) f[i] += f[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="26-礼物的最大价值-剑指offer原47题"><a href="#26-礼物的最大价值-剑指offer原47题" class="headerlink" title="26.礼物的最大价值(剑指offer原47题)"></a>26.礼物的最大价值(剑指offer原47题)</h4><ul>
<li>解题思路：<strong>经典的边界问题，还是要考虑三个问题，状态怎么表示；状态的计算问题；怎么定义边界</strong>。f[i,j]表示从左上角出发，到达当格子获得的最大价值。状态计算[i, j] = max(f[i-1, j],f[i, j-1]) + gifts[i,j]；边界f[i,0] = f[0, j] = 0。所要求的答案是f[n,m]。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                f[i][j] = max(f[i <span class="number">-1</span>][j], f[i][j<span class="number">-1</span>]) + grid[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="27-最长不含重复字符的子字符串-剑指offer原48题"><a href="#27-最长不含重复字符的子字符串-剑指offer原48题" class="headerlink" title="27.最长不含重复字符的子字符串(剑指offer原48题)"></a>27.最长不含重复字符的子字符串(剑指offer原48题)</h4><ul>
<li>解题思路：双指针i、j算法，当j指针每向后移动一位时，判断i到j中是否有重复字符，如果出现了重复字符，就将i指向的重复字符删除，同时i指针向后移动一次。当j移动到字符串末尾时，j-i+1的距离就是不含重复字符的子字符串。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthLongestSubString</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">            hash[s[j]]++;</span><br><span class="line">            <span class="keyword">while</span>(hash[s[j]] &gt; <span class="number">1</span>) hash[s[i++]]--;</span><br><span class="line">            res = max(res, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="28-丑数-剑指offer原49题-———求第n个丑数的值"><a href="#28-丑数-剑指offer原49题-———求第n个丑数的值" class="headerlink" title="28.丑数(剑指offer原49题)———求第n个丑数的值"></a>28.丑数(剑指offer原49题)———求第n个丑数的值</h4><ul>
<li>解题思路：丑数：一个数的质因子中只包含2 3 5的数！首先将1加入丑数集合中去，然后分别用三个i,j,k指针指向1.。其中i表示2，j表示3，k表示5；然后用1分别与i、j、k三个指针相乘，取相乘后所有结果中的最小值放在1的下一个位置。同时，将指针向后移动一个位置。<strong>当有多个相等的最小值出现时，需要将多个指针分别向后移动一个位置</strong>。依次循环下去，就可以找到整个丑数组成的集合了。（实际上是3路归并排序，将包含因子2的排好序丑数放入一个数组、包含因子3的排好序丑数放入一个数组、包含因子5的排好序丑数放入一个数组；<strong>前面的三个数组中，是不包含因子1</strong>。然后将三个数组分别除以数字2 数字3 数字5得到的结果仍然是一个丑数序列，将得到的3个丑数序列合并后进行判重处理，就得到了最终结果）  <figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">int</span> getUglyNumber(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; <span class="string">q(1, 1)</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(--n)&#123;  <span class="regexp">//</span> 循环n-<span class="number">1</span>次    <span class="keyword">while</span>(n--)&#123;&#125;是循环n次</span><br><span class="line">            <span class="keyword">int</span> t = min(<span class="string">q[i]</span> * <span class="number">2</span>, min(<span class="string">q[j]</span> * <span class="number">3</span>, <span class="string">q[k]</span> * <span class="number">5</span>));</span><br><span class="line">            q.push_back(t);</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">q[i]</span> * <span class="number">2</span> == t) i++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">q[j]</span> * <span class="number">3</span> == t) j++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">q[k]</span> * <span class="number">5</span> == t) k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="29-字符串中第一个只出现一次的字符-剑指offer原50题—-题目一"><a href="#29-字符串中第一个只出现一次的字符-剑指offer原50题—-题目一" class="headerlink" title="29.字符串中第一个只出现一次的字符(剑指offer原50题—-题目一)"></a>29.字符串中第一个只出现一次的字符(剑指offer原50题—-题目一)</h4><ul>
<li>解题思路：先定义一个hash表，统计每个字符出现多少次，然后从前往后遍历hash表，扫描到第一个值是1对应的key，也就是最终的结果  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) hash[c]++;  <span class="comment">// 统计字符串s中每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">char</span> res = <span class="string">'#'</span>;  <span class="comment">// 无解的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">            <span class="keyword">if</span>(hash[c] == <span class="number">1</span>)&#123;</span><br><span class="line">                res = c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="30-字符流中第一个只出现一次的字符-剑指offer原50题—-题目二"><a href="#30-字符流中第一个只出现一次的字符-剑指offer原50题—-题目二" class="headerlink" title="30.字符流中第一个只出现一次的字符(剑指offer原50题—-题目二)"></a>30.字符流中第一个只出现一次的字符(剑指offer原50题—-题目二)</h4><ul>
<li>解题思路：每次输入字符时，将输入的字符流中出现次数大于1的字符删除。使用队列的数据结构来存储插入的字符！  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入字符到一个队列queue中</span></span><br><span class="line">    <span class="comment">// 利用hash表判断当前正在插入的字符是否出现在当前的队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(++hash[ch] &gt; <span class="number">1</span>)&#123;  <span class="comment">// 插入的字符已经出现在队列中</span></span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; hash[q.front()] &gt; <span class="number">1</span>) q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> q.push(ch); <span class="comment">// 插入的字符没有出现在队列中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstAppearingOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="31-数组中的逆序对-剑指offer原51题）"><a href="#31-数组中的逆序对-剑指offer原51题）" class="headerlink" title="31.数组中的逆序对(剑指offer原51题）"></a>31.数组中的逆序对(剑指offer原51题）</h4><ul>
<li>解题思路：暴力做法的时间复杂度是O(n**2)，考虑能否使用归并排序的方法来优化算法为O(nlogn)。首先分别对统计同时在左右两个子序列中一共有多少个逆序对（递归方法）；然后计算逆序对不在同一个子序列时，对第二个序列中的每一个数a[j]，计算第一个序列中一共有多少个数a[i]比a[j]要大。因此一共有r-i+1个数比a[j]]要大！最后的结果是上面三个部分的和。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = merge(nums, l, mid) + merge(nums, mid + <span class="number">1</span>, r);  <span class="comment">// 第一和第二部分</span></span><br><span class="line">        <span class="comment">// 第三个部分</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j]) temp.push_back(nums[i++]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp.push_back(nums[j++]);</span><br><span class="line">                res += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= mid) temp.push_back(nums[i++]);</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= r) temp.push_back(nums[j++]);</span><br><span class="line">            i = l;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : temp) nums[i++] = x;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">inversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="32-两个链表的第一个公共结点-剑指offer原52题）"><a href="#32-两个链表的第一个公共结点-剑指offer原52题）" class="headerlink" title="32.两个链表的第一个公共结点(剑指offer原52题）"></a>32.两个链表的第一个公共结点(剑指offer原52题）</h4><ul>
<li>思路：使用两个指针p和q，p指针指向第一个链表的头结点，q指针指向第二个链表的头结点。当p指针遍历到第一个链表的末尾时，接着回到第二链表的头结点位置；当q指针遍历到第二个链表的末尾时，接着回到第一链表的头结点位置。<strong>注意两个指针所走的总距离是相等的</strong>！当进行了多次循环后，两个指针一定会在某个结点处相遇，即公共结点。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">findFirstCommonNode</span><span class="params">(ListNode* headA, ListNode* headB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = headA, q = headB;</span><br><span class="line">        <span class="keyword">while</span>(p != q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p) p = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p = headB;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(q) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> q = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="33-二叉搜索树的后序遍历序列-剑指offer原33题"><a href="#33-二叉搜索树的后序遍历序列-剑指offer原33题" class="headerlink" title="33.二叉搜索树的后序遍历序列(剑指offer原33题)"></a>33.二叉搜索树的后序遍历序列(剑指offer原33题)</h4><ul>
<li>题目：给定一个数组，判断此数组是否是某二叉搜索树的后序遍历结果！</li>
<li>解题思路：先找出数组中的最后一个元素作为树根root，然后找到二叉搜索树的左子树的最后一个位置（左子树中的结点值均小于root，右子树的结点值均大于root）。接着找到二叉搜索树的右子树的最后一个位置。判断结点的值是否满足二叉搜索树的定义！  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifySequenceOFBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span></span>&#123;</span><br><span class="line">        seq = sequence;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, seq.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> root = seq[r];</span><br><span class="line">        <span class="keyword">int</span> k = l;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; r &amp;&amp; seq[k] &lt; root) k++;  <span class="comment">// 二叉搜索树的左子树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; r; i++)&#123;  <span class="comment">// 判断二叉搜索树的右子树是否合法</span></span><br><span class="line">            <span class="keyword">if</span>(seq[i] &lt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(l, k<span class="number">-1</span>) &amp;&amp; dfs(k+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="34-二叉树中和为某一值的路径-剑指offer原34题"><a href="#34-二叉树中和为某一值的路径-剑指offer原34题" class="headerlink" title="34.二叉树中和为某一值的路径(剑指offer原34题)"></a>34.二叉树中和为某一值的路径(剑指offer原34题)</h4><ul>
<li>解题思路：直接遍历一遍二叉树，当遍历到叶节点时，判断从根节点到当前节点的路径上的节点值之和是否等于给定值。如果等于的话，就记录当前的路径。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findPath(TreeNode* root, <span class="keyword">int</span> sum)&#123;</span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;  <span class="comment">// 当前节点是空的，就不是叶子节点</span></span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="comment">// 如果当前节点的左右子树都是空的，则当前节点是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !sum) ans.push_back(path);</span><br><span class="line">        <span class="comment">// 递归处理左右子树</span></span><br><span class="line">        dfs(root-&gt;left, sum);</span><br><span class="line">        dfs(root-&gt;right, sum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="35-复杂链表的复制-剑指offer原35题"><a href="#35-复杂链表的复制-剑指offer原35题" class="headerlink" title="35.复杂链表的复制(剑指offer原35题)"></a>35.复杂链表的复制(剑指offer原35题)</h4><ul>
<li>解题思路：第一步将每个节点复制出来，然后将当前节点的next指针指向复制出来的节点；第二步将原先节点p的random指针指向第3个节点；那么，被复制出来的p节点是p-&gt;next，其random指针即p-&gt;next-&gt;random指向p-&gt;random-&gt;next节点。最后将复制出来的节点全部连接起来！  <figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next, *random;</span><br><span class="line">    ListNode(int x): val(x), next(nullptr), random(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* copyRandomList(ListNode* head)&#123;</span><br><span class="line">        <span class="comment">// 第一步复制所有的节点，并将当前节点指向复制出来的节点</span></span><br><span class="line">        <span class="keyword">for</span>(auto p = head; p;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">auto</span> np = new ListNode(p-&gt;</span>val);  <span class="comment">// 复制出来的新节点</span></span><br><span class="line">            <span class="function"><span class="title">auto</span> next = p-&gt;</span><span class="function"><span class="title">next</span>;   // 备份一下p-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>next = np;   <span class="comment">// 复制出来的点接在当前节点的后面</span></span><br><span class="line">            <span class="function"><span class="title">np</span>-&gt;</span>next = next;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二步复制random指针</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(auto p = head; p; p = p-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next)&#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(p-&gt;</span>random)</span><br><span class="line">                <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">random</span> = p-&gt;</span><span class="function"><span class="title">random</span>-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第三步将所有复制出来的节点连接起来</span></span><br><span class="line">        auto dummy = new ListNode(-<span class="number">1</span>);</span><br><span class="line">        auto cur = dummy;   <span class="comment">// 当前新链表的尾节点</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(auto p = head; p; p = p-&gt;</span>next)&#123;</span><br><span class="line">            <span class="function"><span class="title">cur</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">cur</span> = cur-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">return</span> dummy-&gt;</span>next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="36-二叉搜索树与双向链表-剑指offer原36题"><a href="#36-二叉搜索树与双向链表-剑指offer原36题" class="headerlink" title="36.二叉搜索树与双向链表(剑指offer原36题)"></a>36.二叉搜索树与双向链表(剑指offer原36题)</h4><ul>
<li>解题思路：首先获取根节点；然后分别递归左右子树，左右子树分别返回一个首尾节点(即当前子树中最左边的节点和当前子树中最右边的节点)；接着将三部分拼接起来；最后将左子树的最左侧和右子树的最右侧节点返回就是最后的答案。  <figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">using</span> namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* <span class="built_in">left</span>;</span><br><span class="line">    TreeNode* <span class="built_in">right</span>;</span><br><span class="line">    TreeNode(int x): val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* convert(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> nullptr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">auto</span> sides = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> sides.<span class="built_in">first</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;TreeNode*, TreeNode*&gt; dfs(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;<span class="built_in">left</span> &amp;&amp; !root-&gt;<span class="built_in">right</span>) <span class="keyword">return</span> &#123;root, root&#125;;  // 当前节点是叶子节点</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> &amp;&amp; root-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="built_in">auto</span> lsides = dfs(root-&gt;<span class="built_in">left</span>), rsides = dfs(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">            lsides.second-&gt;<span class="built_in">right</span> = root, root-&gt;<span class="built_in">left</span> = lsides.second;</span><br><span class="line">            root-&gt;<span class="built_in">right</span> = rsides.<span class="built_in">first</span>, rsides.<span class="built_in">first</span>-&gt;<span class="built_in">left</span> = root;</span><br><span class="line">            <span class="keyword">return</span> &#123;lsides.<span class="built_in">first</span>, rsides.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>)&#123;</span><br><span class="line">            <span class="built_in">auto</span> lsides = dfs(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">            lsides.second-&gt;<span class="built_in">right</span> = root, root-&gt;<span class="built_in">left</span> = lsides.second;</span><br><span class="line">            <span class="keyword">return</span> &#123;lsides.<span class="built_in">first</span>, root&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="built_in">auto</span> rsides = dfs(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">            root-&gt;<span class="built_in">right</span> = rsides.<span class="built_in">first</span>, rsides.<span class="built_in">first</span>-&gt;<span class="built_in">left</span> = root;</span><br><span class="line">            <span class="keyword">return</span> &#123;root, rsides.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="37-序列化二叉树-剑指offer原37题"><a href="#37-序列化二叉树-剑指offer原37题" class="headerlink" title="37.序列化二叉树(剑指offer原37题)"></a>37.序列化二叉树(剑指offer原37题)</h4><ul>
<li>题目：确保二叉树可以序列化为字符串；并且可以将此字符串反序列化为原始树结构。</li>
<li>解题思路：利用二叉树的前序遍历实现从二叉树到字符串的序列化操作；反序列化实现的是从字符串到二叉树的转换，注意将字符串类型的数字转成整数的方法！  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        dfs_s(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历实现序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            res += <span class="string">"null "</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += to_string(root-&gt;val) + <span class="string">' '</span>;</span><br><span class="line">        dfs_s(root-&gt;left, res);</span><br><span class="line">        dfs_s(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs_d(data, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_d</span><span class="params">(<span class="built_in">string</span> data, <span class="keyword">int</span>&amp; u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == data.size()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> k = u;</span><br><span class="line">        <span class="keyword">while</span>(data[k] != <span class="string">' '</span>) k++;</span><br><span class="line">        <span class="keyword">if</span>(data[u] == <span class="string">'n'</span>)&#123; <span class="comment">// 'n'是null的开始字符</span></span><br><span class="line">            u = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = u; i &lt; k; i++) val = val * <span class="number">10</span> + data[i] - <span class="string">'0'</span>;  <span class="comment">// 将字符串整数"123"转换成整数123</span></span><br><span class="line">        u = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root-&gt;left = dfs_d(data, u);</span><br><span class="line">        root-&gt;right = dfs_d(data, u);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="38-数字排列—-（与剑指offer38题不同）"><a href="#38-数字排列—-（与剑指offer38题不同）" class="headerlink" title="38.数字排列—-（与剑指offer38题不同）"></a>38.数字排列—-（与剑指offer38题不同）</h4><ul>
<li>题目：输入一组数字(可能包含重复数字)，输出其所有的全排列</li>
<li>解题思路：先对输入的数字进行排序，然后开辟与输入一组数字相同长度的数组，接着从输入数字中按顺序取一个数字放在数组的任意一个位置上。<strong>接下来，取第二个数字放在数组中剩下空间的任意一个位置上，如果第二个数字与第一个数字值是相同的，则规定第二个数字只能放在第一个数字的后面的位置</strong>，依次将输入的数字放入数组中，直到数组的各位都已经占满为止。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permutation(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        path.resize(nums.size());   <span class="comment">// 开辟的数组空间大小</span></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">// 用一个二进制位来表示哪些位置是空的</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> u, <span class="keyword">int</span> start, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">        <span class="comment">// u:当前枚举的位置   start: 当前这个数应该从哪个位置开始枚举？（即上一个数的后一个位置开始枚举）</span></span><br><span class="line">        <span class="comment">// state: 存储的是状态，表示哪些数被用过</span></span><br><span class="line">        <span class="keyword">if</span>(u == nums.size())&#123;</span><br><span class="line">            ans.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!u || nums[u] != nums[u<span class="number">-1</span>]) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(state &gt;&gt; i &amp; <span class="number">1</span>))&#123;   <span class="comment">// state &gt;&gt; i &amp; 1：看一下state的二进制表示中第i位是否表示为1</span></span><br><span class="line">                path[i] = nums[u];</span><br><span class="line">                dfs(nums, u + <span class="number">1</span>, i + <span class="number">1</span>, state + (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="39-数组中出现次数超过一半的数字（寻找数组中的众数）-剑指offer原39题"><a href="#39-数组中出现次数超过一半的数字（寻找数组中的众数）-剑指offer原39题" class="headerlink" title="39.数组中出现次数超过一半的数字（寻找数组中的众数）(剑指offer原39题)"></a>39.数组中出现次数超过一半的数字（寻找数组中的众数）(剑指offer原39题)</h4><ul>
<li>解题思路：初始化一个计数变量count = 0，然后遍历数组中的每个元素，当val等于第一个元素时，count加1。接着遍历第二个元素，如果第二个元素的值与第一个元素的值相同时，则count加1；如果第二个元素的值与第一个元素的值不同时，count减1；最后遍历完整个数组后，最终结果存储在val变量中。<strong>摩尔投票法原理</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">moreThanHalfNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, val = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt) val = x, cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x == val) cnt++;</span><br><span class="line">                <span class="keyword">else</span> cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="40-最小的k个数-剑指offer原40题"><a href="#40-最小的k个数-剑指offer原40题" class="headerlink" title="40.最小的k个数(剑指offer原40题)"></a>40.最小的k个数(剑指offer原40题)</h4><ul>
<li>解题思路：维护一个大顶堆，当最小的k个数存放在大顶堆中。遍历输入数组中的每个元素，然后将每个元素与大顶堆中的堆顶元素进行比较，如果比堆顶元素小，就更新堆顶元素。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : input)</span><br><span class="line">        &#123;</span><br><span class="line">            heap.push(x);</span><br><span class="line">            <span class="keyword">if</span>(heap.size() &gt; k) heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(heap.size()) res.push_back(heap.top()), heap.pop();  <span class="comment">// heap存放的是从大到小的顺序</span></span><br><span class="line">        reverse(res.rbegin(), res.rend());  <span class="comment">// 翻转一下变成从小到大</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="41-数据流中的中位数-剑指offer原41题"><a href="#41-数据流中的中位数-剑指offer原41题" class="headerlink" title="41.数据流中的中位数(剑指offer原41题)"></a>41.数据流中的中位数(剑指offer原41题)</h4><ul>
<li>题目：如果从数据流中读出奇数个数值，则中位数就是所有数值排序后位于中间的数值；如果从数据流中读出偶数个数值，则中位数就是所有数值排序之后中间两个数的平均值。</li>
<li>解题思路：将当前所有的数维护成两个集合，第一个集合是一个小顶堆，存的是比较大的那一部分数；第二个集合是一个大顶堆，存的是比较小的那一部分数。<strong>可以发现，大顶堆的堆顶元素和小顶堆的堆顶元素实际就是输入数据流中间的两个数</strong>。规定，数据流中读出的是奇数个数值时，大顶堆比小顶堆中的元素多一个。如何维护这个结构？<strong>每次插入一个新的元素到大顶堆中，如果下面大顶堆的堆顶元素比上面小顶堆的堆顶元素的大（即逆序了），则交换；如果下面大顶堆中的元素太多了，就要直接转移当中的一个元素到小顶堆中</strong>。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; max_heap;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; min_heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        max_heap.push(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(min_heap.size() &amp;&amp; max_heap.top() &gt; min_heap.top())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> maxv = max_heap.top(), minv = min_heap.top();</span><br><span class="line">            max_heap.pop(), min_heap.pop();</span><br><span class="line">            max_heap.push(minv), min_heap.push(maxv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(max_heap.size() &gt; min_heap.size() + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            min_heap.push(max_heap.top());</span><br><span class="line">            max_heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(max_heap.size() + min_heap.size() &amp; <span class="number">1</span>) <span class="keyword">return</span> max_heap.top();   <span class="comment">// 数据流中是奇数个数值</span></span><br><span class="line">        <span class="keyword">return</span> (max_heap.top() + min_heap.top()) / <span class="number">2.0</span>;    <span class="comment">// 数据流中是偶数个数值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="42-连续子数组的最大和-剑指offer原42题"><a href="#42-连续子数组的最大和-剑指offer原42题" class="headerlink" title="42.连续子数组的最大和(剑指offer原42题)"></a>42.连续子数组的最大和(剑指offer原42题)</h4><ul>
<li>解题思路：s表示遍历到当前数x前一个位置为结尾的子数组的和最大值，s如何更新？当s &gt; 0时，s = s + x；当s &lt;= 0时，s = x；  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s &lt; <span class="number">0</span>) s = <span class="number">0</span>;</span><br><span class="line">            s += x;</span><br><span class="line">            res = max(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="43-从1到n整数中1出现的次数-剑指offer原43题"><a href="#43-从1到n整数中1出现的次数-剑指offer原43题" class="headerlink" title="43.从1到n整数中1出现的次数(剑指offer原43题)"></a>43.从1到n整数中1出现的次数(剑指offer原43题)</h4><ul>
<li>解题思路：假设输入13015，则万位上的1个数：10000-13015共3016个；千位上的1个数：1000-1999,11000-11999，一共有2000个；百位上的1个数：情况有很多种！十位上的1个数：情况有很多种！总结出的一般规律：输入的数字是abcedf，第一种情况：假设c位置上的数字是1，则ab位置上的取值范围是00到ab-1；def位置上的取值范围是000到999，则总方案数是ab*1000。第二种情况：最高位恰好取到ab时，分两种情况讨论。1.c位等于0时，就只有0个1；2.c位等于1时，则def的取值范围是0到def，一共有def+1种方案；3.c大于1时，def位置上的取值范围是000到999，则总方案数是1000！  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfBetween1AndN</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; number;</span><br><span class="line">        <span class="comment">// 取出n中的每位数字放入number中</span></span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            number.push_back(n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = number.size() -  <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="number">0</span>, right = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = number.size() - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                left = left * <span class="number">10</span> + number[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                right = right * <span class="number">10</span> + number[j];</span><br><span class="line">                t *= <span class="number">10</span>;  <span class="comment">// t表示右边一共有多少位数</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res += left * t;</span><br><span class="line">            <span class="keyword">if</span>(number[i] == <span class="number">1</span>) res += right + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(number[i] &gt; <span class="number">1</span>) res += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="44-反转链表-剑指offer原24题"><a href="#44-反转链表-剑指offer原24题" class="headerlink" title="44.反转链表(剑指offer原24题)"></a>44.反转链表(剑指offer原24题)</h4><ul>
<li>解题思路：因为反转的是一个单向链表，所以无法直接遍历当前节点的前驱结点，因此利用一个变量pre记录当前节点的前驱结点。然后从头开始遍历给定的单向链表，直到遍历到空结点为止。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;   <span class="comment">// 记录当前结点的前驱结点</span></span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = cur-&gt;next;    <span class="comment">// 用next变量缓存cur-&gt;next，用来使得cur向后移动一位</span></span><br><span class="line">            cur-&gt;next = pre;                   <span class="comment">// 每次遍历时，将当前结点的next指针指向其前驱结点</span></span><br><span class="line">            pre = cur;        <span class="comment">// 将pre指针向后移动一位，此时pre指向cur</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;                 <span class="comment">// pre就是反转后链表的头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="45-合并两个排序的链表-剑指offer原25题"><a href="#45-合并两个排序的链表-剑指offer原25题" class="headerlink" title="45.合并两个排序的链表(剑指offer原25题)"></a>45.合并两个排序的链表(剑指offer原25题)</h4><ul>
<li>解题思路：<strong>归并排序的方法来实现即可！</strong>  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;   <span class="comment">// 因为往合并后的链表中添加元素时，是尾部插入的。因此，需要一个cur指针来记录当前链表的尾结点在哪。</span></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将两个链表中更长者中剩余的部分链接到已合并链表的末尾</span></span><br><span class="line">        <span class="keyword">if</span>(l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="46-树的子结构—-树的匹配-剑指offer原26题"><a href="#46-树的子结构—-树的匹配-剑指offer原26题" class="headerlink" title="46.树的子结构—-树的匹配(剑指offer原26题)"></a>46.树的子结构—-树的匹配(剑指offer原26题)</h4><ul>
<li>解题思路：类比字符串匹配的方法，从根结点root开始枚举，看一下树根root是否是子树的根节点；不是的话，判断树的左孩子结点是否是子树的树根结点；不是的话，判断树的右孩子结点是否是子树的树根结点。然后利用前序遍历树和子树即可。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasSubTree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot1 || !pRoot2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 前序遍历树pRoot1，然后与pRoot2结点进行对比</span></span><br><span class="line">        <span class="keyword">if</span>(isPart(pRoot1, pRoot2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasSubTree(pRoot1-&gt;left, pRoot2) || hasSubTree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPart</span><span class="params">(TreeNode* p1, TreeNode* p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p1 || p1-&gt;val != p2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isPart(p1-&gt;left, p2-&gt;left) &amp;&amp; isPart(p1-&gt;right, p2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="47-二叉树的镜像-剑指offer原27题"><a href="#47-二叉树的镜像-剑指offer原27题" class="headerlink" title="47.二叉树的镜像(剑指offer原27题)"></a>47.二叉树的镜像(剑指offer原27题)</h4><ul>
<li>解题思路：所有结点的左右孩子结点都交换了一下，遍历树中的所有结点，每次遍历完后，将每个结点的左右孩子结点交换一下就可以了。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mirror</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        mirror(root-&gt;left);</span><br><span class="line">        mirror(root-&gt;right);</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="48-对称的二叉树-剑指offer原28题"><a href="#48-对称的二叉树-剑指offer原28题" class="headerlink" title="48.对称的二叉树(剑指offer原28题)"></a>48.对称的二叉树(剑指offer原28题)</h4><ul>
<li>解题思路：除了根节点之外，其他的每个结点它的左边的结点和右边的结点是对应的！并且左边结点的左孩子和右边结点的右孩子是对称的，左边结点的右孩子和右边结点的左孩子是对称的！  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> !p &amp;&amp; !q;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="49-顺时针打印矩阵-剑指offer原29题"><a href="#49-顺时针打印矩阵-剑指offer原29题" class="headerlink" title="49.顺时针打印矩阵(剑指offer原29题)"></a>49.顺时针打印矩阵(剑指offer原29题)</h4><ul>
<li>解题思路：顺时针定义四个方向：右 下 左 上；先按右的方向走，走到不能走为止；然后向下移动一个位置，按下的方向走，走到不能走为止；再向左移动一个位置，按左的方向走，走到不能走为止；最后向上移动一个位置，按上的方向走，走到不能走为止！直到总完n<em>m步就完成了！不能走的定义是：<em>*要么走出了边界，要么你已经走过了这个格子了</em></em>。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>));   <span class="comment">// 二维数组记录每个格子是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;   <span class="comment">// 上 右 下 左</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">1</span>;  <span class="comment">// 起始方向是向右移动，故d = 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(matrix[x][y]);</span><br><span class="line">            st[x][y] = <span class="literal">true</span>;   <span class="comment">// 当前点被标记成已经访问</span></span><br><span class="line">            <span class="keyword">int</span> a = x + dx[d], b = y + dy[d];  <span class="comment">// 下一个点的坐标</span></span><br><span class="line">            <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || st[a][b])&#123;  <span class="comment">// 当前点已经出界或者被访问过</span></span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;   <span class="comment">// d向下移动</span></span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="50-包含min函数的栈-剑指offer原30题"><a href="#50-包含min函数的栈-剑指offer原30题" class="headerlink" title="50.包含min函数的栈(剑指offer原30题)"></a>50.包含min函数的栈(剑指offer原30题)</h4><ul>
<li>题目：设计一个支持push pop top等操作并可以在O(1)的时间复杂度内检索出最小元素的堆栈。</li>
<li>解题思路：利用一个辅助栈(<strong>单调栈</strong>)来操作。单调栈：即栈中的元素是单调的！维护一个单调栈，单调栈中的元素大小是单独变化的，当插入一个新的元素到主栈中时，将其与单调栈中的栈顶元素进行比较，当插入的元素比单调栈中的栈顶元素大，则不会将新的元素插入到主栈中；<strong>当插入的元素比单调栈中的栈顶元素小或者与单调栈中的栈顶元素相等时，则将新的元素插入到主栈中去</strong>。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk, min_stk;   <span class="comment">// stk是主栈  min_stk是单调栈</span></span><br><span class="line"></span><br><span class="line">    MinStack()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        stk.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min_stk.empty() || min_stk.top() &gt;= x) min_stk.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.top() == min_stk.top()) min_stk.pop();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="51-栈的压入与弹出序列-剑指offer原31题"><a href="#51-栈的压入与弹出序列-剑指offer原31题" class="headerlink" title="51.栈的压入与弹出序列(剑指offer原31题)"></a>51.栈的压入与弹出序列(剑指offer原31题)</h4><ul>
<li>解题思路：模拟一遍整个过程，每次往栈里面加一个元素，加完后判断当前栈顶元素是否是当前弹出序列的元素。如果是，则将栈顶元素弹出。当栈里面已经是空时，弹出序列就是合法的，否则就是不合法的!  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(popV.size() != pushV.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushV.size(); i++)&#123;</span><br><span class="line">            s.push(pushV[i]);</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() == popV[index])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="52-不分行从上往下打印二叉树-层序遍历-剑指offer原32题—-题目一"><a href="#52-不分行从上往下打印二叉树-层序遍历-剑指offer原32题—-题目一" class="headerlink" title="52.不分行从上往下打印二叉树[层序遍历](剑指offer原32题—-题目一)"></a>52.不分行从上往下打印二叉树[层序遍历](剑指offer原32题—-题目一)</h4><ul>
<li>解题思路：宽度优先搜索BFS，利用队列这个数据结构来实现  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printFromTopToBottom(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(q.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            res.push_back(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="53-分行从上往下打印二叉树-剑指offer原32题—-题目二"><a href="#53-分行从上往下打印二叉树-剑指offer原32题—-题目二" class="headerlink" title="53.分行从上往下打印二叉树(剑指offer原32题—-题目二)"></a>53.分行从上往下打印二叉树(剑指offer原32题—-题目二)</h4><ul>
<li>解题思路：在队列中增加一个null标记，表示当前层的结点已经全部遍历结束。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; printFromTopToBottom(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;   <span class="comment">// 辅助的数组表示每层中有多少个结点</span></span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();  <span class="comment">// 队首元素</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t)  <span class="comment">// t为空时，表示已经遍历完一层</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(level.empty()) <span class="keyword">break</span>;  <span class="comment">// level数组为空时，表示已经遍历完所有的结点，就直接返回</span></span><br><span class="line">                res.push_back(level);</span><br><span class="line">                level.clear();</span><br><span class="line">                q.push(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            level.push_back(t-&gt;val);  <span class="comment">// t不为空时，将当前的点加入到level中，进行扩展</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="54-之字形打印二叉树-剑指offer原32题—-题目三"><a href="#54-之字形打印二叉树-剑指offer原32题—-题目三" class="headerlink" title="54.之字形打印二叉树(剑指offer原32题—-题目三)"></a>54.之字形打印二叉树(剑指offer原32题—-题目三)</h4><ul>
<li>解题思路：在上一题的基础上增加一个布尔类型的变量zigzag，当zigzag为true时，表示从右到左打印；zigzag为false时，表示从左到右打印！  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; printFromTopToBottom(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;   <span class="comment">// 辅助的数组表示每层中有多少个结点</span></span><br><span class="line">        <span class="keyword">bool</span> zigzag = <span class="literal">false</span>;   <span class="comment">// 表示从左到右打印</span></span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();  <span class="comment">// 队首元素</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t)  <span class="comment">// t为空时，表示已经遍历完一层</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(level.empty()) <span class="keyword">break</span>;  <span class="comment">// level数组为空时，表示已经遍历完所有的结点，就直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(zigzag) reverse(level.begin(), level.end());</span><br><span class="line">                res.push_back(level);</span><br><span class="line">                level.clear();</span><br><span class="line">                q.push(<span class="literal">nullptr</span>);</span><br><span class="line">                zigzag = !zigzag;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            level.push_back(t-&gt;val);  <span class="comment">// t不为空时，将当前的点加入到level中，进行扩展</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="55-机器人的运动范围-剑指offer原13题"><a href="#55-机器人的运动范围-剑指offer原13题" class="headerlink" title="55.机器人的运动范围(剑指offer原13题)"></a>55.机器人的运动范围(剑指offer原13题)</h4><ul>
<li>解题思路：一般考虑使用宽度优先遍历BFS，不建议使用深度优先遍历DFS。因为深度优先遍历在数据范围比较大时，可能会出现栈溢出！从(0,0)点开始遍历，每次将<strong>符合要求</strong>的格子加入到队列中去。最后一共遍历完多少个合法的格子，就是我们最终的结果。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 算出一个数字的各个位置上的数字之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_single_sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            s += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 算出一个格子中的各个位置上数字之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get_single_sum(p.first) + get_single_sum(p.second);    <span class="comment">// p.first是x坐标   p.second是y坐标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingcount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!rows || !cols) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st(rows, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (cols, <span class="literal">false</span>));   <span class="comment">// 全部初始化成false，记录每个格子是否已经被访问</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);  <span class="comment">// 初始坐标初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;    <span class="comment">// 顺时针来记忆 上 右 下 左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(get_sum(t) &gt; threshold || st[t.first][t.second]) <span class="keyword">continue</span>;</span><br><span class="line">            res++;</span><br><span class="line">            st[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols)&#123;</span><br><span class="line">                    q.push(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="56-剪绳子-剑指offer原14题"><a href="#56-剪绳子-剑指offer原14题" class="headerlink" title="56.剪绳子(剑指offer原14题)"></a>56.剪绳子(剑指offer原14题)</h4><ul>
<li>题目：给定一个正整数，将此整数划分成若干个更小的正整数的和<br><strong>使得划分出来的若干个正整数的乘积最大</strong></li>
<li>解题思路：目标：假设输入的正整数是N，拆分成尽可能多的3！。分下面几种情况：1.如果N % 3 == 0，则拆分成若干个3；2.如果N % 3 == 1，则先将N拆分成两个2，剩下的全部拆分成3；3.如果N % 3 == 2，则先将N拆分成一个2，剩下的全部拆分成3；</li>
<li>证明上面的三种情况：N &gt; 0，N = n1 + n2 + n3 + …+ nk 1.假设ni &gt;= 5，3 * (ni - 3) &gt;= ni(即3*ni-9 &gt;= ni得到2ni &gt;= 9)是否成立？2.ni = 4， 4 = 2 * 2。<strong>由前面的1和2得到拆分出来的数字一定不包含4和大于等于5的数字</strong>；因此可知所有拆分出来的ni不是2就是3。接下来证明拆分出来的数字中，最多只有两个2（因为2*2*2 &lt; 3*3）。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">1</span>) res *= <span class="number">4</span>, n -= <span class="number">4</span>;  <span class="comment">// 拆成出来两个2</span></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">2</span>) res *= <span class="number">2</span>, n -= <span class="number">2</span>;  <span class="comment">// 拆出来一个2</span></span><br><span class="line">        <span class="keyword">while</span>(n) res *= <span class="number">3</span>, n -= <span class="number">3</span>;    <span class="comment">// 拆出来全部都是3</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="57-二进制中1的个数-剑指offer原15题"><a href="#57-二进制中1的个数-剑指offer原15题" class="headerlink" title="57.二进制中1的个数(剑指offer原15题)"></a>57.二进制中1的个数(剑指offer原15题)</h4><ul>
<li>解题思路：s += n &amp; 1是先统计n中个位上是数字1的个数，n&gt;&gt;1则是统计完n中个位的结果后，移除n的个位上的数字来进行更新。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOf1</span><span class="params">(<span class="keyword">int</span> _n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> n = _n;  <span class="comment">// 将有符号数转换成无符号数，为了下面的循环</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            s += n &amp; <span class="number">1</span>;  <span class="comment">// 每次将n的个位取出来，判断是否是1，是1的话就s++</span></span><br><span class="line">            n &gt;&gt; <span class="number">1</span>;  <span class="comment">// 然后将n的个位移除，即n右移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="58-数值的整数次方-剑指offer原16题"><a href="#58-数值的整数次方-剑指offer原16题" class="headerlink" title="58.数值的整数次方(剑指offer原16题)"></a>58.数值的整数次方(剑指offer原16题)</h4><ul>
<li>解题思路：注意处理次方是负数的情况即可！  <figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span>(<span class="params"><span class="keyword">double</span> <span class="keyword">base</span>, <span class="keyword">int</span> exponent</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; abs(exponent); i++)&#123;</span><br><span class="line">            res *= <span class="keyword">base</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>) res = <span class="number">1</span> / res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="59-在O-1-的时间复杂度内删除链表结点（剑指offer原18题—题目一）"><a href="#59-在O-1-的时间复杂度内删除链表结点（剑指offer原18题—题目一）" class="headerlink" title="59.在O(1)的时间复杂度内删除链表结点（剑指offer原18题—题目一）"></a>59.在O(1)的时间复杂度内删除链表结点（剑指offer原18题—题目一）</h4><ul>
<li>解题思路：此题不能使用常规方法！因为要删除的结点不是链表的最后一个结点，所以下一个结点一定不是空结点。删除的方法是：<strong>用下一个结点的值去覆盖当前结点的值，然后将下一个结点的值删掉</strong>。这种方法就不需要用到前驱结点了。  <figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(int x): val(x), next(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void deleteNode(ListNode* <span class="keyword">node</span><span class="title">)&#123;</span></span><br><span class="line"><span class="title">        node-</span>&gt;val = <span class="keyword">node</span><span class="title">-&gt;next-</span>&gt;val;</span><br><span class="line">        <span class="keyword">node</span><span class="title">-&gt;next</span> = <span class="keyword">node</span><span class="title">-&gt;next-</span>&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="60-删除链表中重复的结点（剑指offer原18题—题目二）"><a href="#60-删除链表中重复的结点（剑指offer原18题—题目二）" class="headerlink" title="60.删除链表中重复的结点（剑指offer原18题—题目二）"></a>60.删除链表中重复的结点（剑指offer原18题—题目二）</h4><ul>
<li>解题思路：<strong>建议凡是可能会把头结点删掉的链表问题，一般来说都会增加一个虚拟头结点来简化代码</strong>。使用两个指针，第一个指针p指向上一次保留的结点的最后一个位置，q指向的是下一段的第一个结点，q用来扫描下一段的所有结点。  <figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* <span class="keyword">next</span>;</span><br><span class="line">    ListNode(int x): val(x), <span class="keyword">next</span>(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)&#123;</span><br><span class="line">        auto dummy = new ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy-&gt;<span class="keyword">next</span> = head;</span><br><span class="line"></span><br><span class="line">        auto p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;<span class="keyword">next</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            auto q = p-&gt;<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">while</span>(q &amp;&amp; p-&gt;<span class="keyword">next</span>-&gt;val == q-&gt;val)&#123;</span><br><span class="line">                q = q-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            if(p-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span> == q) p = p-&gt;<span class="keyword">next</span>;   <span class="regexp">//</span> 下一段的长度是<span class="number">1</span>，没有重复结点，不用删</span><br><span class="line">            else p-&gt;<span class="keyword">next</span> = q;   <span class="regexp">//</span> 下一段的长度超过<span class="number">1</span>，则删除重复结点</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="61-正则表达式的匹配（剑指offer原19题）"><a href="#61-正则表达式的匹配（剑指offer原19题）" class="headerlink" title="61.正则表达式的匹配（剑指offer原19题）"></a>61.正则表达式的匹配（剑指offer原19题）</h4><ul>
<li>题目：实现一个函数用来匹配包括.和*的正则表达式。字符.表示任意一个字符；字符*表示它前面的字符可以出现任意次（含0次）。</li>
<li>解题思路：<strong>动态规划问题</strong>。状态表示f[i][j]:s[i,…]和p[j,…]是相匹配的；状态转移：情况1：如果p[j]是正常字符，则f[i][j] = s[i] == p[j] &amp;&amp; f[i + 1][j + 1]；情况2：p[j]是.，f[i][j] = f[i + 1][j + 1]；情况3：p[j + 1] = *，*表示的字符是0次或*表示的字符匹配1次，则f[i][j] = f[i][j + 2] || f[i + 1][j]；边界问题：f[n][m] = true  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f;</span><br><span class="line">    <span class="built_in">string</span> s, p;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">inMatch</span><span class="params">(<span class="built_in">string</span> _s, <span class="built_in">string</span> _p)</span></span>&#123;</span><br><span class="line">        s = _s, p = _p;</span><br><span class="line">        n = s.size(), m = p.size();</span><br><span class="line">        f = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">        <span class="keyword">if</span>(y == m)</span><br><span class="line">            <span class="keyword">return</span> f[x][y] = x == n;</span><br><span class="line">        <span class="keyword">bool</span> first_match = x &lt; n &amp;&amp; (p[y] == <span class="string">'.'</span> || s[x] == p[y]);  <span class="comment">// 情况1和情况2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(y + <span class="number">1</span> &lt; m &amp;&amp; p[y + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;  <span class="comment">// 情况3</span></span><br><span class="line">            f[x][y] = dp(x, y + <span class="number">2</span>) || dp(x + <span class="number">1</span>, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[x][y] = first_match &amp;&amp; dp(x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="62-表示数值的字符串（剑指offer原20题）"><a href="#62-表示数值的字符串（剑指offer原20题）" class="headerlink" title="62.表示数值的字符串（剑指offer原20题）"></a>62.表示数值的字符串（剑指offer原20题）</h4><ul>
<li>解题思路：分各种情况讨论  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    bool isNumber(string s)&#123;</span><br><span class="line">        int i = <span class="number">0</span>, j = s.size();</span><br><span class="line">        /<span class="regexp">/ 删除字符串s中的前后空格</span></span><br><span class="line"><span class="regexp">        while(i &lt;= j &amp;&amp; s[i] == ' ') i++;</span></span><br><span class="line"><span class="regexp">        while(i &lt;= j &amp;&amp; s[j] == ' ') j--;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        if(i &gt; j) return false;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        s = s.substr(i, j - i + 1);</span></span><br><span class="line"><span class="regexp">        if(s[0] == '+' || s[0] == '-') s = s.substr(1);</span></span><br><span class="line"><span class="regexp">        if(s.empty() || (s[0] == '.' &amp;&amp; s.size() == 1)) return false;  /</span><span class="regexp">/ + - .</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        int dot = 0, e = 0;   /</span><span class="regexp">/ 统计有多少个.和e</span></span><br><span class="line"><span class="regexp">        for(int i = 0; i &lt; s.size(); i++)&#123;</span></span><br><span class="line"><span class="regexp">            if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9');</span></span><br><span class="line"><span class="regexp">            else if(s[i] == '.')&#123;</span></span><br><span class="line"><span class="regexp">                dot++;</span></span><br><span class="line"><span class="regexp">                if(dot &gt; 1 || e) return false;  /</span><span class="regexp">/ 3434.23232.4343, 23232e23232.2323</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            else if(s[i] == 'e' || s[i] == 'E')&#123;</span></span><br><span class="line"><span class="regexp">                e++;</span></span><br><span class="line"><span class="regexp">                if(!i || i + 1 == s.size() || e &gt; 1 || s[i - 1] == '.' &amp;&amp; i == 1) return false; /</span><span class="regexp">/ e1223233, 11232e, 1212e32323e</span></span><br><span class="line"><span class="regexp">                if(s[i + 1] == '+' || s[i + 1] == '-')&#123;</span></span><br><span class="line"><span class="regexp">                    if(i + 2 == s.size()) return false;   /</span><span class="regexp">/ 12341e+</span></span><br><span class="line"><span class="regexp">                    i++;</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            else return false;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        return true;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="63-调整数组顺序使奇数位于偶数前面（剑指offer原21题）"><a href="#63-调整数组顺序使奇数位于偶数前面（剑指offer原21题）" class="headerlink" title="63.调整数组顺序使奇数位于偶数前面（剑指offer原21题）"></a>63.调整数组顺序使奇数位于偶数前面（剑指offer原21题）</h4><ul>
<li>题目：输入一个数组，实现数组中数字的顺序，使得所有的奇数位于数组的前半部分；所有的偶数位于后半部分。</li>
<li>解题思路：使用双指针，一个指针从前往后，另一个指针从后往前。保证第一个指针前面全部是奇数，第二个指针前面全部是偶数。  <figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">class</span> Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">        int <span class="keyword">first</span> = <span class="number">0</span>, <span class="keyword">second</span> = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">first</span> &lt;= <span class="keyword">second</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">first</span> &lt;= <span class="keyword">second</span> &amp;&amp; nums[<span class="keyword">first</span>] % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">first</span>++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">first</span> &lt;= <span class="keyword">second</span> &amp;&amp; nums[<span class="keyword">second</span>] % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">second</span><span class="comment">--;</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">first</span> &lt; <span class="keyword">second</span>) swap(nums[<span class="keyword">first</span>], nums[<span class="keyword">second</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="64-链表中倒数第k个节点（剑指offer原22题）"><a href="#64-链表中倒数第k个节点（剑指offer原22题）" class="headerlink" title="64.链表中倒数第k个节点（剑指offer原22题）"></a>64.链表中倒数第k个节点（剑指offer原22题）</h4><ul>
<li>解题思路：由于单链表不能从后往前遍历的，只能从前往后遍历。因此首先求出整个链表的长度n，求倒数第k个节点相当于求正序的n-k+1个节点，然后从前往后遍历到n-k+1个节点就可以了。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">findKthToTail</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next) n++;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k; i++) p = p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="65-链表中环的入口节点（剑指offer原23题）"><a href="#65-链表中环的入口节点（剑指offer原23题）" class="headerlink" title="65.链表中环的入口节点（剑指offer原23题）"></a>65.链表中环的入口节点（剑指offer原23题）</h4><ul>
<li>解题思路：<strong>使用快慢指针算法，用两个指针first和second分别从起点开始走，first每次走一步，second每次走两步。如果过程中second走到null，则说明不存在环；否则当first和second相遇后，让first返回起点，second待在原地不动，然后两个指针每次分别走一步，当相遇时，相遇点就是环的入口</strong>。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">entryNodeOfLoop</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i = head, j = head; <span class="comment">// i是慢指针，每次走一步;j是快指针，每次走两步</span></span><br><span class="line">        <span class="keyword">while</span>(i &amp;&amp; j)&#123;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">            j = j-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(j) j = j-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;  <span class="comment">// i和j相遇了</span></span><br><span class="line">                i = head;  <span class="comment">// 慢指针i回到起点</span></span><br><span class="line">                <span class="keyword">while</span>(i != j)&#123; <span class="comment">// 慢指针和快指针同时向后移动一个位置</span></span><br><span class="line">                    i = i-&gt;next;</span><br><span class="line">                    j = j-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> i;   <span class="comment">// 环入口的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 无环存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="66-找出数组中重复的数字（剑指offer原3题—-题目一）"><a href="#66-找出数组中重复的数字（剑指offer原3题—-题目一）" class="headerlink" title="66.找出数组中重复的数字（剑指offer原3题—-题目一）"></a>66.找出数组中重复的数字（剑指offer原3题—-题目一）</h4><ul>
<li>解题思路：从前往后遍历整个数组中的每个元素，如果元素的取值不在0到n-1范围内，就直接返回-1；如果元素的取值在0到n-1范围内时，检查数组下标是取值为该元素时的数组位置上存储的是哪个数字；如果存储的数字与其在数组中对应的下标相等，则找出了重复的数字，否则将两个位置上的数字进行交换，重复此步骤，直到存储的数字与其在数组中对应的下标相等为止。  <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int duplicateInArray(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(auto x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; nums.<span class="built_in">size</span>(); <span class="built_in">i</span>++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">i</span> != nums[<span class="built_in">i</span>] &amp;&amp; nums[nums[<span class="built_in">i</span>]] != nums[<span class="built_in">i</span>]) swap(nums[<span class="built_in">i</span>], nums[nums[<span class="built_in">i</span>]]);</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">i</span>] != <span class="built_in">i</span> &amp;&amp; nums[nums[<span class="built_in">i</span>]] == nums[<span class="built_in">i</span>]) <span class="keyword">return</span> nums[<span class="built_in">i</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="67-不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）"><a href="#67-不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）" class="headerlink" title="67.不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）"></a>67.不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）</h4><ul>
<li>解题思路：<strong>根据抽屉原理</strong>，至少有2个数字会重复！利用递归的思想，将这个数组一分为二，分别计算左右子数组两边的长度和元素的个数，至少有一边元素的个数会大于子数组的长度。递归上面的过程即可！  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duplicateInArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;  <span class="comment">// [l, mid], [mid + 1, r]</span></span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;  <span class="comment">// 统计元素的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) s += x &gt;= l &amp;&amp; x &lt;= mid;</span><br><span class="line">            <span class="keyword">if</span>(s &gt; mid - l + <span class="number">1</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="68-二维数组中的查找（剑指offer原4题）"><a href="#68-二维数组中的查找（剑指offer原4题）" class="headerlink" title="68.二维数组中的查找（剑指offer原4题）"></a>68.二维数组中的查找（剑指offer原4题）</h4><ul>
<li>解题思路：从二维数组右上角的位置开始查找，如果要查找的目标数字比右上角的数字要大，则目标数字出现在二维数组的右下角位置；如果要查找的目标数字比右上角的数字要小，则目标数字出现在二维数组的左上角位置。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty() || <span class="built_in">array</span>[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">array</span>[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="built_in">array</span>.size() &amp;&amp; j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &gt; target) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="69-替换空格（剑指offer原5题）"><a href="#69-替换空格（剑指offer原5题）" class="headerlink" title="69.替换空格（剑指offer原5题）"></a>69.替换空格（剑指offer原5题）</h4><ul>
<li>解题思路：开一个新的字符串，遍历原始的字符串，如果遇到空格字符，就将20%存储在新字符串中；否则，直接存储在新字符串中。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpaces</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : str)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="string">' '</span>)</span><br><span class="line">                res += <span class="string">"20%"</span>;</span><br><span class="line">            <span class="keyword">else</span> res += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="70-从尾到头打印链表（剑指offer原6题）"><a href="#70-从尾到头打印链表（剑指offer原6题）" class="headerlink" title="70.从尾到头打印链表（剑指offer原6题）"></a>70.从尾到头打印链表（剑指offer原6题）</h4><ul>
<li>解题思路：先将整个链表遍历一遍，然后将整个链表翻转一下即可。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListReversingly(ListNode* head)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res.rbegin(), res.rend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="71-重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）"><a href="#71-重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）" class="headerlink" title="71.重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）"></a>71.重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）</h4><ul>
<li>解题思路：首先，根据前序遍历确定当前区间的根节点是哪个；然后，根据已经确定的根节点，从中序遍历中找到根节点的位置在哪，从而确定二叉树的左右子树中分别包含的数字；最后，在已经确定的左右子树中递归执行前面的两个步骤，即可重建二叉树。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;   <span class="comment">// 开一个hash表，记录每个节点在数组中的位置</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder, inorder;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; _preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; _inorder)</span></span>&#123;</span><br><span class="line">        preorder = _preorder, inorder = _inorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); i++)&#123;</span><br><span class="line">            hash[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, preorder.size() - <span class="number">1</span>, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl &gt; pr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(preorder[pl]);</span><br><span class="line">        <span class="keyword">int</span> k = hash[inorder[root-&gt;val]];</span><br><span class="line">        <span class="keyword">auto</span> left = dfs(pl + <span class="number">1</span>, pl + <span class="number">1</span> + k - il - <span class="number">1</span>, il, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> right = dfs(pl + k - il + <span class="number">1</span>, pr, k + <span class="number">1</span>, ir);</span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="72-二叉树的下一个节点（剑指offer原8题）"><a href="#72-二叉树的下一个节点（剑指offer原8题）" class="headerlink" title="72.二叉树的下一个节点（剑指offer原8题）"></a>72.二叉树的下一个节点（剑指offer原8题）</h4><ul>
<li>题目：给定二叉树中的一个节点，找出<strong>中序遍历序列</strong>的下一个节点</li>
<li>解题思路：分情况进行讨论，情况1：如果给定的节点是存在右子树的，则下一个节点是右子树中最左边的节点；情况2：如果给定的节点是不存在右子树的，又分两种情况讨论：a.如果给定的节点存在父节点，并且给定的节点是父节点的左儿子的话，则下一个节点是给定节点的父节点；b.如果给定的节点存在父节点，并且给定的节点是父节点的右儿子的话，此时沿着父节点向上找，直到找到第一个节点是当前父节点的左儿子时停止，返回父节点。  <figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* inorderSuccessor(TreeNode* p)&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span>right)&#123;  <span class="comment">// 情况1</span></span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">left</span>) p = p-&gt;</span>left;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况2</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">father</span> &amp;&amp; p == p-&gt;</span><span class="function"><span class="title">father</span>-&gt;</span><span class="function"><span class="title">right</span>) p = p-&gt;</span>father;</span><br><span class="line">        <span class="function"><span class="title">return</span> p-&gt;</span>father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="73-用两个栈实现一个队列（剑指offer原9题）"><a href="#73-用两个栈实现一个队列（剑指offer原9题）" class="headerlink" title="73.用两个栈实现一个队列（剑指offer原9题）"></a>73.用两个栈实现一个队列（剑指offer原9题）</h4><ul>
<li>解题思路：先将元素依次压入栈1中，然后逐个弹出栈1中的元素，将每个元素依次压入栈2中。此时，<strong>栈2中的栈顶元素就是栈1中的栈底元素</strong>，再依次弹出栈2中的元素时，就实现了队列的先进先出功能（最先进入栈1中的元素，最先从栈2中弹出）。  <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stk, cache;</span><br><span class="line"></span><br><span class="line">    MyQueue()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        stk.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">copy</span>(stack&lt;<span class="keyword">int</span>&gt;&amp; a, stack&lt;<span class="keyword">int</span>&gt;&amp; b)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a.<span class="keyword">size</span>())&#123;</span><br><span class="line">            b.<span class="keyword">push</span>(a.top());</span><br><span class="line">            a.<span class="keyword">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">pop</span>()&#123;</span><br><span class="line">        <span class="keyword">copy</span>(stk, cache);</span><br><span class="line">        <span class="keyword">int</span> res = cache.top();</span><br><span class="line">        cache.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">copy</span>(cache, stk);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> peak()&#123;</span><br><span class="line">        <span class="keyword">copy</span>(stk, cache);</span><br><span class="line">        <span class="keyword">int</span> res = cache.top();</span><br><span class="line">        <span class="keyword">copy</span>(cache, stk);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty()&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="74-斐波那契数列数列（剑指offer原10题）"><a href="#74-斐波那契数列数列（剑指offer原10题）" class="headerlink" title="74.斐波那契数列数列（剑指offer原10题）"></a>74.斐波那契数列数列（剑指offer原10题）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = a + b;</span><br><span class="line">            a = b, b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="75-旋转数组的最小数字（剑指offer原11题）"><a href="#75-旋转数组的最小数字（剑指offer原11题）" class="headerlink" title="75.旋转数组的最小数字（剑指offer原11题）"></a>75.旋转数组的最小数字（剑指offer原11题）</h4><ul>
<li>解题思路：利用<strong>画图法</strong>来解决。输入数组是0 1 2 2 2 2 3 4 5,则旋转后的数组是2 2 3 4 5 0 1 2 2。将旋转数组分成两部分2 2 3 4 5和0 1 2 2，两部分是单调的增加。首先将后半部分相同值删除，然后观察剩下的结果可知，所有的元素都比前半部分的第一个元素小。前半部分中后面的值都大于或等于第一个元素。<strong>下面就可以使用二分法，找出后半部分中第一个比前半部分第一个元素小的那个数字，就是我们要找的最小数字</strong>。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span> &amp;&amp; nums[n] == nums[<span class="number">0</span>]) n--;  <span class="comment">// 去掉后半部分相等的数值</span></span><br><span class="line">        <span class="keyword">if</span>(nums[n] &gt;= nums[<span class="number">0</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="76-矩阵中的路径（剑指offer原12题）"><a href="#76-矩阵中的路径（剑指offer原12题）" class="headerlink" title="76.矩阵中的路径（剑指offer原12题）"></a>76.矩阵中的路径（剑指offer原12题）</h4><ul>
<li>解题思路：先枚举所有起点，然后枚举方向。直到走到不能走为止，这样就得到所有的路径。  <figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPath(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;char&gt;&gt;&amp; <span class="keyword">matrix</span>, <span class="keyword">string</span> str)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">matrix</span>.<span class="keyword">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(<span class="keyword">matrix</span>, str, <span class="number">0</span>, i, j))  <span class="comment">// 枚举所有起点i, j，从字符串str第0个字符串开始枚举</span></span><br><span class="line">                    <span class="keyword">return</span> true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool dfs(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;char&gt;&gt;&amp; <span class="keyword">matrix</span>, <span class="keyword">string</span>&amp; str, <span class="keyword">int</span> u, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="comment">// 当前字符串str中的第几个字符u，x和y是当前路径的坐标</span></span><br><span class="line">        <span class="keyword">if</span>(u == str.<span class="keyword">size</span>()) <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">matrix</span>[x][y] != str[u]) <span class="keyword">return</span> false;</span><br><span class="line">        <span class="comment">// 枚举四个方向</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        char t = <span class="keyword">matrix</span>[x][y];  <span class="comment">// 已经访问过的字符，不能重新访问</span></span><br><span class="line">        <span class="keyword">matrix</span>[x][y] = <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = x + dx[i], b = y + dx[i];</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="keyword">matrix</span>.<span class="keyword">size</span>() &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; <span class="keyword">matrix</span>[a].<span class="keyword">size</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(<span class="keyword">matrix</span>, str, u + <span class="number">1</span>, a, b)) <span class="keyword">return</span> true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">matrix</span>[x][y] = t;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的基本变量类型介绍</title>
    <url>/C/C-%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="1-cpp变量类型"><a href="#1-cpp变量类型" class="headerlink" title="1.cpp变量类型"></a>1.cpp变量类型</h3><ul>
<li>变量实际上是存储空间的名称，cpp中每个变量都有指定的类型，类型决定变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可以作用在变量上。</li>
<li>变量名可以是字母 数字 下划线组成，必须以字母或下划线开头。区分大小写</li>
<li>几种基本的变量类型：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni0xNjBmODg4YzdlMDJiNGZjLnBuZw" alt="基本的变量类型.png"><h3 id="2-cpp中的变量定义"><a href="#2-cpp中的变量定义" class="headerlink" title="2.cpp中的变量定义"></a>2.cpp中的变量定义</h3></li>
<li><p>变量定义就是<strong>告诉编译器在何处创建变量的存储，以及如何创建变量的存储</strong>。变量的定义指定一个数据类型，并包含该类型的一个或多个变量的列表，例如：</p>
  <figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">格式：<span class="keyword">type</span> variable_list;</span><br></pre></td></tr></table></figure>
</li>
<li><p>type必须是基本数据类型或用户自定义的数据类型(如 类)，variable_list可以由一个或多个标识符名称组成，<strong>多个标识符之间用逗号分隔</strong>，例如：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, k;  <span class="comment">// 声明并定义了变量i, j, k,指示编译器创建类型为int的名为i,j,k的变量</span></span><br><span class="line"><span class="keyword">char</span> c, d, e;</span><br><span class="line"><span class="keyword">float</span> f, ss;</span><br><span class="line"><span class="keyword">double</span> d;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量可以在声明的时候被初始化，初始化器由一个等号后跟一个常量表达式组成,例如：</p>
  <figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">格式:  type variable_name = <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> d = <span class="number">3</span>, f = <span class="number">6</span>;  <span class="comment">// d 和 f 的声明</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">3</span>, f = <span class="number">5</span>;  <span class="comment">// 定义并初始化 d 和 f</span></span><br><span class="line"><span class="keyword">byte</span> z = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">char</span> x = <span class="string">'x'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的</p>
<h3 id="3-cpp中的变量声明"><a href="#3-cpp中的变量声明" class="headerlink" title="3.cpp中的变量声明"></a>3.cpp中的变量声明</h3></li>
<li>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。<strong>变量声明只在编译时有它的意义</strong>，在程序连接时编译器需要实际的变量声明。</li>
<li><p>当使用多个文件且<strong>只在其中一个文件中定义变量时</strong>（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 变量的定义</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="comment">// 实际初始化</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量的声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 变量的定义</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="comment">// 实际初始化</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="keyword">int</span> i = func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-cpp中的左值和右值"><a href="#4-cpp中的左值和右值" class="headerlink" title="4.cpp中的左值和右值"></a>4.cpp中的左值和右值</h3><ul>
<li>cpp中的两种类型的表达式：<ul>
<li>左值：<strong>指向内存位置的表达式被称为左值（lvalue）表达式</strong>。左值可以出现在赋值号的左边或右边。</li>
<li>右值：<strong>存储在内存中某些地址的数值</strong>。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li>
</ul>
</li>
<li>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">int g = <span class="number">20</span>;</span><br><span class="line"><span class="number">10</span> = <span class="number">20</span>;  报错！</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-变量的类型转换"><a href="#5-变量的类型转换" class="headerlink" title="5.变量的类型转换"></a>5.变量的类型转换</h3><ul>
<li><p>变量的类型间是可以互相转换的，转换又分为自动转换和强制转换。</p>
<ul>
<li><p>自动转换规则</p>
<ul>
<li>若参与运算量的类型不同，则先转换成同一类型，然后进行运算。</li>
<li>转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int型转成long型后再进行运算。<ul>
<li>a、若两种类型的字节数不同，转换成字节数高的类型</li>
<li>b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型</li>
</ul>
</li>
<li>所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。</li>
<li>char型和short型参与运算时，必须先转换成int型。</li>
<li>在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> aa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> bb = <span class="number">2.1</span>;</span><br><span class="line">aa = bb;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"aa = "</span> &lt;&lt; aa &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为 2，丢失小数部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为a + b = 3.1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>强制转换规则</p>
<ul>
<li>强制类型转换是通过类型转换运算来实现的。其一般形式为：<strong>（类型说明符）表达式</strong>其功能是把表达式的运算结果强制转换成类型说明符所表示的类型<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt; a + (<span class="keyword">int</span>)b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为a + b = 3</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-变量定义与声明的区别"><a href="#6-变量定义与声明的区别" class="headerlink" title="6.变量定义与声明的区别"></a>6.变量定义与声明的区别</h3><ul>
<li>定义包含了声明，但是声明不包含定义,<strong>变量声明是不会为变量开辟内存空间的</strong>,只有当声明也是定义时，声明才可以有初始化，初始化必须有存储空间来进行初始化。如：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;     <span class="comment">//定义并声明了变量 a</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;  <span class="comment">//只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的基本数据类型介绍</title>
    <url>/C/C-%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h3 id="1-cpp中的基本内置数据类型（7种）"><a href="#1-cpp中的基本内置数据类型（7种）" class="headerlink" title="1.cpp中的基本内置数据类型（7种）"></a>1.cpp中的基本内置数据类型（7种）</h3><ul>
<li>bool  char  int float double void(无类型) wchar_t(宽字符型)：typedef wchar_t short int;</li>
<li>一个基本类型可以被一个或多个类型修饰符来修饰。<ul>
<li>signed</li>
<li>unsigned</li>
<li>short</li>
<li>long</li>
</ul>
</li>
<li>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值(<strong>变量的大小会根据编译器和所使用的电脑而有所不同</strong>)<br><img src="https://upload-images.jianshu.io/upload_images/13407176-b102c5b08a016185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本数据类型.png"><h3 id="2-typedef声明"><a href="#2-typedef声明" class="headerlink" title="2.typedef声明"></a>2.typedef声明</h3></li>
<li><p>使用typedef为已有的类型取一个新的名字，语法如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">格式：typedef<span class="built_in"> type </span>name;</span><br><span class="line">例如：typedef int feet;  feet是int的另一个名称</span><br><span class="line">     feet distance;  创建一个整型变量distance</span><br></pre></td></tr></table></figure>
</li>
<li><p>typedef 可以声明各种类型名，但不能用来定义变量。用 typedef 可以声明数组类型、字符串类型，使用比较方便。</p>
</li>
<li>用typedef只是对已经存在的类型增加一个类型名，而没有创造新的类型。</li>
<li>当在不同源文件中用到同一类型数据（尤其是像数组、指针、结构体、共用体等类型数据）时，常用 typedef 声明一些数据类型，把它们单独放在一个头文件中，然后在需要用到它们的文件中用 ＃include 命令把它们包含进来，以提高编程效率。</li>
<li>使用 typedef 有利于程序的通用与移植。有时程序会依赖于硬件特性，用 typedef 便于移植。</li>
<li><p>typedef 与 #define 的区别</p>
<ul>
<li><p>2.1 执行时间不同</p>
<ul>
<li>关键字 typedef 在编译阶段有效，由于是在编译阶段，因此 typedef 有类型检查的功能。</li>
<li>#define 则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    UINT value = <span class="string">"abc"</span>;  <span class="comment">// 类型检测，将会报错</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) x*x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>, b = <span class="number">2</span>, c;</span><br><span class="line">    c = f(a) / f(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2.2 功能上的差异</p>
<ul>
<li>typedef 用来定义类型的别名，定义与平台无关的数据类型，与 struct 的结合使用等。</li>
<li>#define 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</li>
</ul>
</li>
<li><p>2.3 作用域不同</p>
<ul>
<li>#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而 typedef 有自己的作用域。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宏的作用域</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> HW <span class="meta-string">"helloworld"</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = HW;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// typedef的作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// UNIT uvalue = 5;  报错！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">        UINT uvalueA;</span><br><span class="line">        A(): uvalueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">        <span class="comment">// UINT uvalueB;  报错</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 在B类中使用UINT会出错，因为UINT只在类A的作用域中。</span></span><br><span class="line">    <span class="comment">// 此外，在类中用typedef定义的类型别名还具有相应的访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AA</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">        UINT valueA;</span><br><span class="line">        AA(): valueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// AA::UINT i = 1;报错，在typedef前加上public权限则可以</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>2.4 对指针的操作——二者修饰指针类型时，作用不同</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* pint;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINT int*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> pint p1 = &amp;i1;  <span class="comment">// 等价于int * const p;指针常量:指针p是一个常量,p不可更改，p指向的内容可以更改</span></span><br><span class="line"><span class="keyword">const</span> PINT p2 = &amp;i2;  <span class="comment">// 等价于const int *p/int const *p，p可以更改，p指向的内容不可更改，常量指针</span></span><br><span class="line"></span><br><span class="line">pint s1, s2;  <span class="comment">// s1 和 s2都是int类型指针</span></span><br><span class="line">PINT s3, s4;  <span class="comment">// 相当于 int * s3, s4;只有一个是指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// p1 = &amp;i2; 指针常量p1不能被修改</span></span><br><span class="line">    *p1 = <span class="number">5</span>;   <span class="comment">// 但是p1指向的内容可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// *p2 = 5; 常量指针p2能被修改</span></span><br><span class="line">    p2 = &amp;i1;   <span class="comment">// 但是p2指向的内容不可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-枚举类型"><a href="#3-枚举类型" class="headerlink" title="3.枚举类型"></a>3.枚举类型</h3><ul>
<li>枚举类型是cpp中的一种派生数据类型，是由用户定义的若干枚举常量的集合</li>
<li>如果一个变量只有几种可能的值，可以定义为枚举类型。“枚举”就是将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</li>
<li><p>创建枚举，需要用到关键字enum，枚举类型的一般形式为:</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名&#123;</span></span><br><span class="line">    标识符[=整型常量];</span><br><span class="line">    标识符[=整型常量];</span><br><span class="line">    ....</span><br><span class="line">    标识符[=整型常量];</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果枚举没有初始化，即省略掉’=整型常数’时,则从第一个标识开始，如下面的例子，变量c的类型是color,最后被赋值为blue。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>&#123;</span></span><br><span class="line">    red, green, blue</span><br><span class="line">&#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认情况下，第一个名称的值是0，第二个名称的值是1，第三个名称的值是2，依次类推。可以在定义枚举类型时，对枚举元素赋值。此时，赋值的枚举值为所赋的值，而其他没有赋值的枚举值在为前一个枚举值加1，例如下面：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>&#123;</span></span><br><span class="line">    red, greed = <span class="number">5</span>, blue</span><br><span class="line">&#125;;</span><br><span class="line">blue = <span class="number">6</span>,默认情况下，每个名称都会比前一个名称大，但red的值仍然是<span class="number">0</span>.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-相关代码"><a href="#4-相关代码" class="headerlink" title="4.相关代码"></a>4.相关代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"limits"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x)  x*x  <span class="comment">// 宏定义</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 typedef执行时间不同</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// UINT value = "abc";  类型检测，将出错</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; value &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 作用域不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> HW <span class="meta-string">"helloworld"</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = HW;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// typedef的作用域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// UNIT uvalue = 5;  报错！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">    UINT uvalueA;</span><br><span class="line">    A(): uvalueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="comment">// UINT uvalueB;  报错</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在B类中使用UINT会出错，因为UINT只在类A的作用域中。</span></span><br><span class="line"><span class="comment">// 此外，在类中用typedef定义的类型别名还具有相应的访问权限</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">    UINT valueA;</span><br><span class="line">    AA(): valueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// AA::UINT i = 1;报错，在typedef前加上public权限则可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 对指针的操作---二者修饰指针类型时，作用不同</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* pint;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINT int*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> pint p1 = &amp;i1;  <span class="comment">// 等价于int * const p;指针常量:指针p是一个常量,p不可更改，p指向的内容可以更改</span></span><br><span class="line"><span class="keyword">const</span> PINT p2 = &amp;i2;  <span class="comment">// 等价于const int *p/int const *p，p可以更改，p指向的内容不可更改，常量指针</span></span><br><span class="line"></span><br><span class="line">pint s1, s2;  <span class="comment">// s1 和 s2都是int类型指针</span></span><br><span class="line">PINT s3, s4;  <span class="comment">// 相当于 int * s3, s4;只有一个是指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// p1 = &amp;i2; 指针常量p1不能被修改</span></span><br><span class="line">    *p1 = <span class="number">5</span>;   <span class="comment">// 但是p1指向的内容可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// *p2 = 5; 常量指针p2能被修改</span></span><br><span class="line">    p2 = &amp;i1;   <span class="comment">// 但是p2指向的内容不可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> color&#123;</span><br><span class="line">    red, green, blue=<span class="number">5</span>, yellow</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bool: "</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"char: "</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed char: "</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"short int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned short int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed short int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">short</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed long  int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned long  int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"float: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"double: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long double: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"wchar_t: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> feet;   <span class="comment">// typedef声明,但typedef int feet = 100;错误！</span></span><br><span class="line">    feet distance;</span><br><span class="line">    <span class="comment">// 1 宏定义执行时间不同</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>, b = <span class="number">6</span>, c;</span><br><span class="line">    c = f(a) / f(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TestPointer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"red = "</span> &lt;&lt; red &lt;&lt; <span class="string">" yellow = "</span> &lt;&lt; yellow &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 枚举类型举例</span></span><br><span class="line">    <span class="keyword">enum</span> days&#123;</span><br><span class="line">        one, two, three</span><br><span class="line">    &#125;day;</span><br><span class="line">    day = one;</span><br><span class="line">    <span class="keyword">switch</span>(day)&#123;</span><br><span class="line">        <span class="keyword">case</span> one:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"one"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> two:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"two"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"默认输出"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的参数传递方式：传值、传地址、传引用总结</title>
    <url>/C/C-%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BC%A0%E5%80%BC%E3%80%81%E4%BC%A0%E5%9C%B0%E5%9D%80%E3%80%81%E4%BC%A0%E5%BC%95%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ul>
<li>指针：指针是一个变量，只不过这个变量中存储的是一个地址，指向内存中的一个单元。</li>
<li>引用：引用和原变量是同一个东西，只不过是原变量的一个别名。  <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">int a = <span class="number">10</span><span class="comment">;  定义一个整型变量a</span></span><br><span class="line">int *p = &amp;a<span class="comment">;  定义一个指向整型变量的指针变量p，该指针指向a的存储单元，即p的值是a存储单元的地址</span></span><br><span class="line">int &amp;<span class="keyword">b </span>= a<span class="comment">;   定义一个整型变量a的引用，a和b是同一个东西，在内存中占用同一个存储单元</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="一、引用的特性："><a href="#一、引用的特性：" class="headerlink" title="一、引用的特性："></a>一、引用的特性：</h3><ul>
<li>引用在定义时必须初始化</li>
<li>一个变量可以有多个引用</li>
<li>引用一旦绑定某个实体，就不能再是其他变量的引用。</li>
</ul>
<h3 id="二、引用和指针的区别与联系："><a href="#二、引用和指针的区别与联系：" class="headerlink" title="二、引用和指针的区别与联系："></a>二、引用和指针的区别与联系：</h3><ul>
<li>1.相同点：<ul>
<li>底层的实现方式相同，都是按照指针的方式实现的</li>
</ul>
</li>
<li>2.不同点：<ul>
<li>引用定义的时候必须初始化，指针可以不用初始化；</li>
<li>引用一旦初始化为指向一个对象，就不能再指向其他对象，而指针可以在任何时候指向任何一个同类型的对象；</li>
<li>没有空引用，但是有空指针；</li>
<li>在sizeof中的含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节的个数(在32为平台下，指针求sizeof永远是4)；</li>
<li>引用++改变的是变量的内容，指针++改变的是指针的指向；</li>
<li>有多级指针，没有多级引用；</li>
<li>引用使用起来比指针安全；</li>
<li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；<h3 id="三、传值、传地址、传引用的区别，哪个更高效？"><a href="#三、传值、传地址、传引用的区别，哪个更高效？" class="headerlink" title="三、传值、传地址、传引用的区别，哪个更高效？"></a>三、传值、传地址、传引用的区别，哪个更高效？</h3></li>
</ul>
</li>
<li>1.传值<ul>
<li>这种传递方式中，实参和形参是两个不同的地址空间，参数传递的实质是将原函数中变量的值，复制到被调用函数形参所在的存储空间中，这个形参的地址空间在函数执行完毕后，会被回收掉。整个被调用函数对形参的操作，只影响形参对应的地址空间，不影响原函数中变量的值，因为这两个不是同一个存储空间。<br><strong>即使形参的值在函数中发生了变化，实参的值也完全不会受到影响，仍为调用前的值。</strong></li>
</ul>
</li>
<li>2.传地址<ul>
<li>这种传递方式中，实参是变量的地址，形参是指针类型的变量，在函数中对指针变量的操作，就是对实参（变量地址）所对应的变量的操作，函数调用结束后，原函数中的变量的值将会发生改变。<br><strong>被调用函数中对形参指针所指向的地址中内容的任何改变都会影响到实参。</strong></li>
</ul>
</li>
<li>3.传引用<ul>
<li>这种传递方式中，形参是引用类型变量，其实就是实参的一个别名，在被调用函数中，对引用变量的所有操作等价于对实参的操作。这样，整个函数执行完毕后，原先的实参的值将会发生改变。<br><strong>被调函数对形参做的任何操作都影响了主调函数中的实参变量。</strong></li>
</ul>
</li>
<li>4.哪种更高效？<ul>
<li>在内置类型当中三种传递方式的效率上都差不多；</li>
<li>在自定义类型当中，传引用方式效率的更高效一些，因为它没有对形参进行一次拷贝<h3 id="四、常引用"><a href="#四、常引用" class="headerlink" title="四、常引用"></a>四、常引用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;  等价于 <span class="keyword">int</span> *<span class="keyword">const</span> b = a;即引用是一个指针常量（又称常指针，即一个常量，其类型是指针）</span><br><span class="line">常引用：<span class="keyword">const</span> <span class="keyword">int</span> &amp;a=b;等价于<span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> a=b;不仅仅是a这个地址不可修改，而且其指向的内存空间也不可修改。</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="五、引用的使用场景"><a href="#五、引用的使用场景" class="headerlink" title="五、引用的使用场景"></a>五、引用的使用场景</h3><ul>
<li><p>1.给变量起别名</p>
  <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">int a<span class="comment">;</span></span><br><span class="line">int &amp;<span class="keyword">b </span>= a<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.将引用作为函数的参数</p>
<ul>
<li>使用引用类型就不必在swap中声明形参是指针变量，指针变量要另外开辟内存单元，其内容是地址。而引用变量不是一个独立的变量，不单独占内存单元。而且在调用swap函数时，只需要传值即可，将引用作为函数的形参更加简单、直观、方便。  <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">void <span class="keyword">swap(int </span>&amp;a, int &amp;<span class="keyword">b)</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   int temp<span class="comment">;</span></span><br><span class="line">    temp = a<span class="comment">;</span></span><br><span class="line">    a = <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">b </span>= temp<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>3.返回值</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> _iLeft, <span class="keyword">int</span> _iRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _iLeft + _iRight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引用返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp; _iLeft, <span class="keyword">int</span>&amp; _iRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> iResult = _iLeft + _iRight;</span><br><span class="line"><span class="keyword">return</span> iResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="六、代码实例"><a href="#六、代码实例" class="headerlink" title="六、代码实例"></a>六、代码实例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_value</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_pointer</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_reference</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++的函数参数传递方式，可以是传值方式，也可以是传引用方式。</span></span><br><span class="line"><span class="comment">传值的本质是：形参是实参的一份复制。</span></span><br><span class="line"><span class="comment">传引用的本质是：形参和实参是同一个东西。</span></span><br><span class="line"><span class="comment">传值和传引用，对大多数常见类型都是适用的。指针、数组，它们都是数据类型的一种，没啥特殊的</span></span><br><span class="line"><span class="comment">因此,指针作为函数参数传递时，也区分为传值和传引用两种方式。</span></span><br><span class="line"><span class="comment">void fun_1(int a); int类型，传值(复制产生新的变量)</span></span><br><span class="line"><span class="comment">void fun_2(int &amp;a); int类型，传引用(形参和实参是同一个东西)</span></span><br><span class="line"><span class="comment">void fun_3(int *pi); 指针类型，传值(复制产生新的变量)</span></span><br><span class="line"><span class="comment">void fun_4(int *&amp;pi); 指针类型，传引用(形参和实参是同一个东西)</span></span><br><span class="line"><span class="comment">如果希望通过将参数传递到函数中，从而来改变变量的值（比如变量是T a，T表示类型)，</span></span><br><span class="line"><span class="comment">则可以有这2种方式选择：</span></span><br><span class="line"><span class="comment">    1.传a的引用： void my_fun(T &amp;a);</span></span><br><span class="line"><span class="comment">    2.传a的地址： void my_fun(T *a);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 值传递</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">形参意思是被调用函数的参数/变量，实参意思是主调函数中放到括号中的参数/变量。</span></span><br><span class="line"><span class="comment">传值方式下，形参是实参的拷贝：重新建立了变量，变量取值和实参一样。</span></span><br><span class="line"><span class="comment">即实参a和b的值为20和10,形参x和y的值都是20和10；而a与x的地址、b与y的地址并不相同</span></span><br><span class="line"><span class="comment">表明形参x和y是新建的变量，也即实参a, b是从形参复制了一份</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap_by_value(a, b); <span class="comment">// 值传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*-------------------------分界线1------------------*/</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap_by_pointer(&amp;a, &amp;b); <span class="comment">// 值传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*-------------------------分界线2------------------*/</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap_by_reference(a, b); <span class="comment">// 引用传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_value</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 传指针(地址),实质还是传值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_pointer</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 传引用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传引用，传递的是实参本身，而不是实参的一个拷贝，形参的修改就是实参的修改,即值相同，地址也相同</span></span><br><span class="line"><span class="comment">相比于传值，传引用的好处是省去了复制，节约了空间和时间。</span></span><br><span class="line"><span class="comment">假如不希望修改变量的值，那么请选择传值而不是传引用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_reference</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 总结</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">“引用”类型变量的声明方式：变量类型 &amp;变量名;   int &amp;b;</span></span><br><span class="line"><span class="comment">“指针”类型的声明方式：基类型 *变量名;  int *pi;</span></span><br><span class="line"><span class="comment">“指针的引用类型”应当这样声明：基类型 *&amp;变量名   int *&amp;pi;</span></span><br><span class="line"><span class="comment">指针类型，也是有传值、传引用两种函数传参方式的：</span></span><br><span class="line"><span class="comment">    1.指针的传值方式</span></span><br><span class="line"><span class="comment">        void my_fun(int *a, int n);</span></span><br><span class="line"><span class="comment">    2.指针的传引用方式</span></span><br><span class="line"><span class="comment">        void my_fun(int *&amp;pi, int n);</span></span><br><span class="line"><span class="comment">// 普通类型，以int a为例</span></span><br><span class="line"><span class="comment">void myfun(int a)    //传值，产生复制</span></span><br><span class="line"><span class="comment">void myfun(int &amp;a)   //传引用，不产生复制</span></span><br><span class="line"><span class="comment">void myfun(int *a)   //传地址，产生复制，本质上是一种传值，这个值是地址</span></span><br><span class="line"><span class="comment">// 指针类型，以int *a为例</span></span><br><span class="line"><span class="comment">void myfun(int *a)   //传值，产生复制</span></span><br><span class="line"><span class="comment">void myfun(int *&amp;a)  //传引用，不产生复制</span></span><br><span class="line"><span class="comment">void myfun(int **a)   //传地址，产生复制，本质上是一种传值，这个值是指针的地址</span></span><br><span class="line"><span class="comment">// 数组类型，以int a[10]为例</span></span><br><span class="line"><span class="comment">void myfun(int a[], int n) //传值，产生复制</span></span><br><span class="line"><span class="comment">void myfun(int* a, int n) //传值，产生复制，传递的数组首地址</span></span><br><span class="line"><span class="comment">void myfun(int (&amp;arr)[10]) //传引用，不产生复制。需要硬编码数组长度</span></span><br><span class="line"><span class="comment">template&lt;size_t size&gt; void myfun(int (&amp;arr)[size]) //传引用，不产生复制。不需要硬编码数组长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="七、参考博客"><a href="#七、参考博客" class="headerlink" title="七、参考博客"></a>七、参考博客</h3><p><a href="http://www.cnblogs.com/zjutzz" target="_blank" rel="noopener">1.Chris的技术博客</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>常引用、常量指针、指针常量、指向常量的常指针、空指针与野指针解释</title>
    <url>/C/%E5%B8%B8%E5%BC%95%E7%94%A8%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E3%80%81%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E3%80%81%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E5%B8%B8%E6%8C%87%E9%92%88%E3%80%81%E7%A9%BA%E6%8C%87%E9%92%88%E4%B8%8E%E9%87%8E%E6%8C%87%E9%92%88%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h3 id="1、一-基础知识"><a href="#1、一-基础知识" class="headerlink" title="1、一.基础知识"></a>1、一.基础知识</h3><ul>
<li>引用并非对象</li>
<li>引用必须初始化</li>
<li>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</li>
<li><p>类型要严格匹配</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">10</span>;             <span class="comment">//错误：引用类型的初始值必须是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;              <span class="comment">//错误：此处引用类型的初始值必须是int型对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针本身就是对象</p>
</li>
<li>指针的类型要和它指向的对象严格匹配<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"><span class="keyword">double</span> *pd = &amp;dval;      <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">double</span> *pd2 = pd;        <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi = pd;            <span class="comment">//错误：指针pi的类型和pd的类型不匹配</span></span><br><span class="line">pi = &amp;dval;              <span class="comment">//错误：试图把double型对象的地址赋给int型指针</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二-常量引用"><a href="#二-常量引用" class="headerlink" title="二.常量引用"></a>二.常量引用</h3><ul>
<li>初始化常量引用时允许用任意表达式作为初始值<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;       <span class="comment">//正确：允许将const int &amp; 绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;      <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>;        <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;    <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;</span><br><span class="line">r1 = <span class="number">0</span>;                  <span class="comment">//正确</span></span><br><span class="line">r2 = <span class="number">0</span>;                  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="三-常量指针"><a href="#三-常量指针" class="headerlink" title="三.常量指针"></a>三.常量指针</h3><ul>
<li>定义： 又叫常指针，可以理解为常量的指针，也即这个是指针，但指向的是个常量，这个常量是指针的值（地址），而不是地址指向的值。</li>
<li>关键点：<ul>
<li>1.常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改；</li>
<li>2.常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值；指针指向的地址可以改变，但指针指向的地址所对应的内容不可以改变</li>
<li>3.指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；</li>
</ul>
</li>
<li>代码形式：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;  <span class="keyword">const</span> <span class="keyword">int</span>* p;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="四-指针常量"><a href="#四-指针常量" class="headerlink" title="四.指针常量"></a>四.指针常量</h3><ul>
<li>定义：本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。</li>
<li>关键点：<ul>
<li>1.指针常量的值是指针，这个值是常量，不能被修改；指向的地址不可以改变，但指向的地址所对应的内容可以改变</li>
<li>2.指针本身是常量，指针指向的地址不可以变化,但是指针指向的地址所对应的内容可以变化；</li>
</ul>
</li>
<li>代码形式:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="五-指向常量的常指针"><a href="#五-指向常量的常指针" class="headerlink" title="五.指向常量的常指针"></a>五.指向常量的常指针</h3><ul>
<li>定义：指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。</li>
<li>关键点：<ul>
<li>1.一个指针常量，指向的是一个指针对象；</li>
<li>2.它指向的指针对象且是一个常量，即它指向的对象不能变化；</li>
</ul>
</li>
<li>代码形式：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="六-那如何区分这几类呢"><a href="#六-那如何区分这几类呢" class="headerlink" title="六.那如何区分这几类呢?"></a>六.那如何区分这几类呢?</h3><ul>
<li><p>带两个const的肯定是指向常量的常指针，很容易理解，主要是如何区分常量指针和指针常量.</p>
<ul>
<li><p>一种方式是看 * 和 const 的排列顺序，比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;    <span class="comment">//const * 即常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;    <span class="comment">//const * 即常量指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;    <span class="comment">//* const 即指针常量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>还一种方式是看const离谁近，即从右往左看，比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;    <span class="comment">//const修饰的是*p，即*p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改；</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;    <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;    <span class="comment">//const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>实例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------常量指针-------</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line">a = <span class="number">300</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line"><span class="comment">//*p1 = 56;  //Error,*p1是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">p1 = &amp;b;     <span class="comment">//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针常量-------//</span></span><br><span class="line"><span class="keyword">int</span>*  <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">a = <span class="number">500</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line">*p2 = <span class="number">400</span>;   <span class="comment">//OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</span></span><br><span class="line"><span class="comment">//p2 = &amp;b;     //Error,因为p2是const 指针，因此不能改变p2指向的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指向常量的常量指针-------//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">//*p3 = 1;    //Error</span></span><br><span class="line"><span class="comment">//p3 = &amp;b;    //Error</span></span><br><span class="line">a = <span class="number">5000</span>;    <span class="comment">//OK,仍然可以通过原来的声明修改值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在实际应用中，常量指针要比指针常量用的多，比如常量指针经常用在函数传参中，以避免函数内部修改内容。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>* src); <span class="comment">//常量指针，src的值不可改变；</span></span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> b[] = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">size_t</span> a1 = <span class="built_in">strlen</span>(a);</span><br><span class="line"><span class="keyword">size_t</span> b1 = <span class="built_in">strlen</span>(b);</span><br><span class="line">虽然a、b是可以修改的，但是可以保证在<span class="built_in">strlen</span>函数内部不会修改a、b的内容。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="七-空指针与野指针"><a href="#七-空指针与野指针" class="headerlink" title="七.空指针与野指针"></a>七.空指针与野指针</h3><ul>
<li>空指针就是保存地址为空的指针，使用指针时必须先判断是否空指针，很多问题都是这一步导致的。</li>
<li>野指针是在delete掉指针之后，没有置0，导致指针随意指向了一个内存地址，如果继续使用，会造成不可预知的内存错误。另外指针的误用很容易造成BUG或者内存泄漏。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------空指针-------//</span></span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//printf("%d",*p4); //运行Error，使用指针时必须先判断是否空指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------野指针（悬浮、迷途指针）-------//</span></span><br><span class="line"><span class="keyword">int</span> *p5 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">delete</span> p5;</span><br><span class="line">p5 = <span class="literal">NULL</span>; <span class="comment">//一定要有这一步</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*p5);  <span class="comment">//隐藏bug，delete掉指针后一定要置0，不然指针指向位置不可控，运行中可导致系统挂掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针的内存泄漏-------//</span></span><br><span class="line"><span class="keyword">int</span> *p6 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">6</span>);</span><br><span class="line">p6 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">7</span>); <span class="comment">//p6原本指向的那块内存尚未释放，结果p6又指向了别处，原来new的内存无法访问，也无法delete了，造成memory leak</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="八-参考资料"><a href="#八-参考资料" class="headerlink" title="八.参考资料"></a>八.参考资料</h3><ul>
<li><a href="http://www.runoob.com/w3cnote/c-constant-pointer.html" target="_blank" rel="noopener">1.菜鸟教程</a></li>
<li><a href="http://www.cnblogs.com/lizhenghn/p/3630405.html" target="_blank" rel="noopener">2.C++中指针常量和常量指针的区别</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++实现斐波那契数列</title>
    <url>/C/C-%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方法和循环方法的对比</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归方法代码实现比较简洁，但是性能不如循环方法，还会出现栈溢出的问题，优先采用递归的方法！</span></span><br><span class="line"><span class="comment">搜索路径的题目：一般使用回溯法，回溯法很适合使用递归方法的代码来实现！当要求不能使用递归实现的时候，考虑使用栈模拟递归的过程</span></span><br><span class="line"><span class="comment">求某个问题的最优解时，并且该问题可以拆分为多个子问题时：可以尝试使用动态规划的方法！在使用自上而下的递归思路去分析动态规划问题时，会发现子问题之间存在重叠</span></span><br><span class="line"><span class="comment">的更小的子问题。为了避免不必要的重复计算，使用自下而上的循环代码来实现，即把子问题的最优解先计算出来并用数组保存下来，然后基于子问题的解计算大问题的解。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特殊情况：在分解子问题的时候存在某个特殊的选择，采用这个特殊的选择将一定那个得到最优解，则此题目可能适用于贪心算法！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FibByRecursive</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> FibByRecursive(n<span class="number">-1</span>) + FibByRecursive(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first=<span class="number">0</span>, second=<span class="number">1</span>, third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            second = first;</span><br><span class="line">            third = second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的文件读写操作(4)</title>
    <url>/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-4/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sstream"</span>    <span class="comment">// 使用istringstream所需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">string头文件定义了三个类型来支持内存IO:</span></span><br><span class="line"><span class="comment">    istringstream向string读取数据</span></span><br><span class="line"><span class="comment">    ostringstrream向string写入数据</span></span><br><span class="line"><span class="comment">    stringstream既可以从string读数据也可以向string写数据，就像string是一个IO流一样</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// istringstream的用法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"hello world! I am Lee."</span>;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(is &gt;&gt; s)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的文件读写操作(3)</title>
    <url>/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-3/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 如果源文件中的每行数据数量不一样，demo2中的方法就不行了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Num_3, Num_2;</span><br><span class="line">    <span class="keyword">int</span> v, w, weight;</span><br><span class="line">    ifstream infile;  <span class="comment">// 读操作,输入流</span></span><br><span class="line">    ofstream outfile; <span class="comment">// 写操作，输出流</span></span><br><span class="line">    infile.open(<span class="string">"E:\\C++\\cpp_Code\\data1.txt"</span>, ios::in);</span><br><span class="line">    <span class="keyword">if</span> (!infile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件操作失败...\n"</span>;</span><br><span class="line">    infile &gt;&gt; Num_3 &gt;&gt; Num_2;  <span class="comment">// 先读取第一行</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>!=Num_3)&#123;  <span class="comment">// 读取第3个数据</span></span><br><span class="line">        infile &gt;&gt; v &gt;&gt; w &gt;&gt; weight;</span><br><span class="line">        cost[v][w] = weight;</span><br><span class="line">        cost[w][v] = weight;</span><br><span class="line">        Num_3--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>!=Num_2)&#123;  <span class="comment">// 读取第2个数据</span></span><br><span class="line">        infile &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        cost[v][w] = <span class="number">100</span>;</span><br><span class="line">        cost[w][v] = <span class="number">100</span>;</span><br><span class="line">        Num_2--;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    outfile.open(<span class="string">"E:\\C++\\cpp_Code\\result1.txt"</span>, ios::out);</span><br><span class="line">    <span class="keyword">if</span>(!outfile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败\n"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">10</span>;j++)&#123;</span><br><span class="line">            outfile &lt;&lt; i &lt;&lt; <span class="string">"\t"</span> &lt;&lt; j &lt;&lt; <span class="string">"\t"</span> &lt;&lt; cost[i][j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的文件读写操作(2)</title>
    <url>/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-2/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo1中是向文件中写入string类型，下面是向文件中写入int类型</span></span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v, w, weight;</span><br><span class="line">    ifstream infile;  <span class="comment">// 读操作</span></span><br><span class="line">    ofstream outfile;  <span class="comment">// 写操作</span></span><br><span class="line">    infile.open(<span class="string">"E:\\C++\\cpp_Code\\data.txt"</span>, ios::in);</span><br><span class="line">    <span class="keyword">if</span> (! infile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(!infile.eof())&#123;</span><br><span class="line">        infile &gt;&gt; v &gt;&gt; w &gt;&gt; weight;</span><br><span class="line">        cost[v][w] = weight;</span><br><span class="line">        cost[w][v] = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line"></span><br><span class="line">    outfile.open(<span class="string">"E:\\C++\\cpp_Code\\result.txt"</span>, ios::app);</span><br><span class="line">    <span class="keyword">if</span>(!outfile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j!=<span class="number">10</span>;++j)&#123;</span><br><span class="line">            outfile &lt;&lt; i &lt;&lt; <span class="string">"\t"</span> &lt;&lt; j &lt;&lt; <span class="string">"\t"</span> &lt;&lt; cost[i][j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的文件读写操作(1)</title>
    <url>/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-1/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">ofstream  文件写操作，内存写入存储设备</span></span><br><span class="line"><span class="comment">ifstream  文件读操作，存储设备读取到内存中</span></span><br><span class="line"><span class="comment">fstream   读写操作，对打开的文件可进行读写操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件打开模式：</span></span><br><span class="line"><span class="comment">    ios::in   只读</span></span><br><span class="line"><span class="comment">    ios::out  只写</span></span><br><span class="line"><span class="comment">    ios::app  从文件末尾开始写，防止丢失文本中原有的内容，追加模式</span></span><br><span class="line"><span class="comment">    ios::binary 二进制模式</span></span><br><span class="line"><span class="comment">    ios::nocreate 打开一个文件时，如果文件不存在，不创建</span></span><br><span class="line"><span class="comment">    ios::noreplace 打开一个文件时，如果文件不存在，创建该文件</span></span><br><span class="line"><span class="comment">    ios::trunc   打开一个文件时，然后清空内容</span></span><br><span class="line"><span class="comment">    ios::ate     打开一个文件时，将位置移动到文件末尾</span></span><br><span class="line"><span class="comment">文件指针位置的C++中的用法：</span></span><br><span class="line"><span class="comment">    ios::beg   文件开头</span></span><br><span class="line"><span class="comment">    ios::end   文件末尾</span></span><br><span class="line"><span class="comment">    ios::cur   文件当前位置</span></span><br><span class="line"><span class="comment">    举个例子：</span></span><br><span class="line"><span class="comment">        file.seekg(0, ios::beg)  让文件指针定位到文件开头</span></span><br><span class="line"><span class="comment">        file.seekg(0, ios::end)  让文件指针定位到文件末尾</span></span><br><span class="line"><span class="comment">        file.seekg(10, ios::cur) 让文件指针从当前位置向文件末尾方向移动10个字节</span></span><br><span class="line"><span class="comment">        file.seekg(-10, ios::cur) 让文件指针从当前位置向文件开始方向移动10个字节</span></span><br><span class="line"><span class="comment">        file.seekg(10,ios::beg)   让文件指针定位到离文件开头10个字节的位置</span></span><br><span class="line"><span class="comment">常用的错误判断方法:</span></span><br><span class="line"><span class="comment">    good()   如果文件打开成功</span></span><br><span class="line"><span class="comment">    bad()    打开文件时发生错误</span></span><br><span class="line"><span class="comment">    eof()    到达文件尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取hello.txt文件中的字符串，写入out.txt中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"E:\\C++\\cpp_Code\\hello.txt"</span>)</span></span>;  <span class="comment">// 读操作</span></span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"E:\\C++\\cpp_Code\\out.txt"</span>)</span></span>;   <span class="comment">// 写操作</span></span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(! infile.is_open())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(getline(infile, temp))&#123;  </span><br><span class="line">        outfile &lt;&lt; temp;</span><br><span class="line">        outfile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">getline()函数的作用：从输入字节流中读入字符，存到string变量中</span></span><br><span class="line"><span class="comment">直到遇到下面的情况停止：</span></span><br><span class="line"><span class="comment">    读入了文件结束标志</span></span><br><span class="line"><span class="comment">    读到一个新行</span></span><br><span class="line"><span class="comment">    达到字符串的最大穿长度</span></span><br><span class="line"><span class="comment">    如果getline没有读入字符，将返回false，用于判断文件是否结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>复习07统计学习方法(支持向量机SVM)---图片版</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A007%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM-%E5%9B%BE%E7%89%87%E7%89%88/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-e4c4763e681374ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-c1ff663b44869d2d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-de40ae539a1594b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-06a7b0733b4a897f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-9e0578690b11ea48.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5.jpg"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复习06统计学习方法(Logistic回归与最大熵模型)---图片版</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A006%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-Logistic%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B-%E5%9B%BE%E7%89%87%E7%89%88/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-23330af289b7990d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-c546a04832004463.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-43f59ed14e078287.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-f62301a284aa666e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.jpg"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复习05统计学习方法(决策树算法Decision Tree)---图片版</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A005%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95Decision-Tree-%E5%9B%BE%E7%89%87%E7%89%88/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-949bf3d21a6cd513.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-89551868a0657f58.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-db3b56affe58f09f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-fb1b2f4fd7c44637.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-15c3694d44fe89d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5.jpg"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复习04统计学习方法(朴素贝叶斯算法Naive Bayes)---图片版</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A004%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95Naive-Bayes-%E5%9B%BE%E7%89%87%E7%89%88/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-6db2674e97151f85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-9ca54696ca36e9db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复习03统计学习方法(K近邻算法KNN)---图片版</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A003%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95KNN-%E5%9B%BE%E7%89%87%E7%89%88/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-a32e76e75c8fe185.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KNN"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的距离函数总结</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="1-距离函数总结"><a href="#1-距离函数总结" class="headerlink" title="1.距离函数总结"></a>1.距离函数总结</h4><ul>
<li><strong>闵可夫斯基距离</strong>：<script type="math/tex; mode=display">
\text { distance( }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left(\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{p}\right)^{1 / p}</script></li>
<li>当p=2时，闵可夫斯基距离就是<strong>欧式距离</strong>：<script type="math/tex; mode=display">
\operatorname{distance}\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{2}=\sqrt{\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{2}}</script></li>
<li>当p=1时，闵可夫斯基距离就是<strong>曼哈顿距离</strong>：<script type="math/tex; mode=display">
\text { distance }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{1}=\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|</script></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复习01统计学习方法(机器学习中的重要概念)---图片版</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A001%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5-%E5%9B%BE%E7%89%87%E7%89%88/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-f39bf23781f1aac2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-fa87d164d7048479?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法岗面试常见问题大集合</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E5%B2%97%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%A7%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h4 id="1-参考博客"><a href="#1-参考博客" class="headerlink" title="1.参考博客"></a>1.参考博客</h4><ul>
<li><a href="https://www.nowcoder.com/ta/review-ml?query=&amp;asc=true&amp;order=&amp;page=1" target="_blank" rel="noopener">算法岗面试常见问题大集合</a></li>
<li><a href="http://www.huaxiaozhuan.com/" target="_blank" rel="noopener">算法工程师手册</a></li>
</ul>
<h4 id="2-模型过拟合的解决方法"><a href="#2-模型过拟合的解决方法" class="headerlink" title="2.模型过拟合的解决方法"></a>2.模型过拟合的解决方法</h4><ul>
<li>L1/L2正则化（原理奥卡姆剃刀）:L2正则化也叫作权重衰减，目标函数中增加所有权重w参数的平方之和，迫使所有w可能趋向0但不为0；L1正则化在损失函数中加入所有权重参数w的绝对值之和，迫使更多的w为0，使特征变得稀疏。</li>
<li>Batch Normalization（对神经网络中下一层的输入进行归一化处理，使得输入量的均值为0，方差为1，即通过特征归一化，加速模型的训练）</li>
<li>shortcut-connect(使用残差网络Residual network)</li>
<li>数据增强(增加样本的数量)</li>
<li>early stopping</li>
<li>Dropout：在训练过程中，让神经元以超参数p的概率被激活(也就是说1-p的概率被设置为0)，类似于bagging算法</li>
</ul>
<h4 id="3-如何解决样本类别的不均衡问题？"><a href="#3-如何解决样本类别的不均衡问题？" class="headerlink" title="3.如何解决样本类别的不均衡问题？"></a>3.如何解决样本类别的不均衡问题？</h4><ul>
<li>a.过采样/上采样：增加类别少的样本数量实现样本数量的均衡。具体是通过复制类别上的样本构成多条数据。此方法的缺点是当样本的特征很少时，容易出现过拟合。需要对过采样方法进行改进，改进的方法是：在类别少的样本中加入噪声、干扰数据或通过一定的规则产生新合成的样本，如smote算法。</li>
<li>b.欠采样/下采样：减少类别多的样本数量，一般的方法是随机地去掉一些类别多的样本。</li>
<li>c.调整正负样本的惩罚权重：对类别少的样本赋予高的权重，对类别多的样本赋予低的权重。</li>
<li>d.通过集成学习的方法：每次生成训练集时，使用所有类别少的样本，同时从类别多的样本中随机抽取数据与类别少的样本合并起来，构成一个新的训练集。</li>
<li>e.使用特征选择：一般样本不均衡也会导致特征不均衡。但如果类别少的样本量具有一定的规模时，则意味着其特征的分布较为均匀，可以选择出具有显著特征配合参与解决样本不均衡的问题。</li>
</ul>
<h4 id="4-在神经网络训练过程中，为什么会出现梯度消失的问题？如何防止？"><a href="#4-在神经网络训练过程中，为什么会出现梯度消失的问题？如何防止？" class="headerlink" title="4.在神经网络训练过程中，为什么会出现梯度消失的问题？如何防止？"></a>4.在神经网络训练过程中，<strong>为什么会出现梯度消失的问题？如何防止</strong>？</h4><ul>
<li>原因：使用了不合适的激活函数，例如sigmoid函数。此时，当神经网络的层数很深时，利用链式求导法则计算梯度时，损失函数的梯度连乘，导致乘积会变得越来越小接近于0，从而神经网络无法学习到新的信息。</li>
<li>解决方法：<ul>
<li>预训练加微调</li>
<li>梯度剪切</li>
<li>权重正则化</li>
<li>使用不同的激活函数</li>
<li>使用Batch Normalization</li>
<li>使用残差网络ResNet</li>
<li>使用LSTM网络</li>
</ul>
</li>
</ul>
<h4 id="5-介绍一下TensorFlow中的计算图"><a href="#5-介绍一下TensorFlow中的计算图" class="headerlink" title="5.介绍一下TensorFlow中的计算图"></a>5.介绍一下TensorFlow中的计算图</h4><ul>
<li>TensorFlow是一个通过计算图的形式来表述计算的编程系统，计算图也叫作数据流图。可以把计算图看做是一种有向图，TensorFlow中的每个节点都是计算图上的一个张量Tensor，而节点之间的边描述了计算之间的依赖关系和数学运算。</li>
</ul>
<h4 id="6-K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。"><a href="#6-K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。" class="headerlink" title="6.K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。"></a>6.K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。</h4><ul>
<li>欧式距离最常见的是两个或多个点之间的距离表示法，又称为欧几里得距离。也就是通常所说的L2范数，公式如下。欧式距离的缺点是它将样本的不同属性之间的差别等同看待，这一点有时候不能满足实际要求。<script type="math/tex; mode=display">
d(x, y) :=\sqrt{\left(x_{1}-y_{1}\right)^{2}+\left(x_{2}-y_{2}\right)^{2}+\cdots+\left(x_{n}-y_{n}\right)^{2}}=\sqrt{\sum_{i=1}^{n}\left(x_{i}-y_{i}\right)^{2}}</script></li>
<li>曼哈顿距离，也就是欧式空间中的在直角坐标系上两个点所形成的线段对轴产生的投影的距离总和。也就是我们所说的L1距离。例如，坐标(x1,y1)的点P1与坐标(x2, y2)的点P2的曼哈顿距离计算公式为：<script type="math/tex; mode=display">
\left|x_{1}-x_{2}\right|+\left|y_{1}-y_{2}\right|</script></li>
</ul>
<h4 id="7-参数模型与非参数模型"><a href="#7-参数模型与非参数模型" class="headerlink" title="7.参数模型与非参数模型"></a>7.参数模型与非参数模型</h4><ul>
<li>参数模型：根据预先设计的规则，例如方差损失最小，进行学习，参数模型例子：回归（线性回归、逻辑回归）模型；最好可以看一下或者直接进行一下相关的推导；根据规则，拥有少部分数据就可以；</li>
<li>非参数模型：不需要事先假设规则，直接挖掘潜在数据中的规则；非参数模型例子：KNN，决策树，挖掘数据潜在的特征，所以比较灵活；</li>
</ul>
<h4 id="8-生成模型与判别模型"><a href="#8-生成模型与判别模型" class="headerlink" title="8.生成模型与判别模型"></a>8.生成模型与判别模型</h4><ul>
<li>生成模型：根据数据学习联合概率分布P(x,y)，从而计算出条件概率分布P(y|x)作为预测的模型。常用于含有隐变量的模型，例如HMM，朴素贝叶斯算法、高斯混合模型GMM、文档主题生成模型LDA、限制玻尔兹曼机等</li>
<li>判别模型：根据数据直接学习条件概率分布P(x|y)或者决策函数Y=f(X)作为预测模型。例如：逻辑回归、RF、SVM、神经网络、感知机、KNN、CRF等</li>
<li>两者的对比：<ul>
<li>使用生成式方法得到的模型，可以还原出模型的联合概率分布，而判别模型不可以；</li>
<li>生成式方法得到的模型收敛速度更快。当样本数增加时，生成式方法得到的模型能更快的收敛到真实模型；</li>
<li>存在隐变量时，只能使用生成模型；</li>
<li>使用判别式方法学习得到的模型，直接面对预测，学习的准确率通常更高，可以简化学习问题。</li>
</ul>
</li>
</ul>
<h4 id="9-LR和SVM的联系和区别？"><a href="#9-LR和SVM的联系和区别？" class="headerlink" title="9.LR和SVM的联系和区别？"></a>9.LR和SVM的联系和区别？</h4><ul>
<li>联系：<ul>
<li>LR和SVM都可以处理分类问题，且一般都用于处理线性二分类问题</li>
<li>两个方法都可以增加不同的正则化项，如L1、L2正则化项</li>
</ul>
</li>
<li>区别：<ul>
<li>LR是参数模型，SVM是非参数模型</li>
<li>从损失函数来看，LR使用的是交叉熵损失函数，SVM使用的hinge损失函数，这两个损失函数的目的都是增加对分类影响较大的样本点的权重，减小与分类关系比较小的数据点的权重。</li>
<li>SVM的处理方法只考虑支持向量，也就是只考虑和分类最相关的少数样本点来学习分类器。而逻辑回归通过非线性映射，大大减小了离分离超平面远的样本点权重，相对提升了与分类最相关的样本点的权重。</li>
<li>LR模型相对来说简单好理解，一般用于大规模的线性分类。SVM的理解和优化比较复杂，在处理复制非线性分类时，使用核技巧来计算优势明显。</li>
<li>LR能做的SVM也能做，但可能准确率是上有问题，但SVM能做的LR做不了。</li>
</ul>
</li>
</ul>
<h4 id="10-神经网络中参数量parameters和FLOPs计算"><a href="#10-神经网络中参数量parameters和FLOPs计算" class="headerlink" title="10.神经网络中参数量parameters和FLOPs计算"></a>10.神经网络中参数量parameters和FLOPs计算</h4><ul>
<li>CNN中的parameters分为两种：W和b，<strong>对于某一个卷积层，它的parameters的个数为</strong>:<script type="math/tex; mode=display">
\left(K_{h} * K_{w} * C_{i n}\right) * C_{o u t}+C_{o u t}</script>其中，$K<em>{h}$是卷积核的高度，$K</em>{w}$是卷积核的宽度,$C<em>{in}$是输入的通道数，$C</em>{out}$是输出的通道数</li>
<li><strong>对于某个全连接层</strong>，如果输入的数据有$N<em>{in}$个节点，输出的数据有$N</em>{out}$个节点，它的参数个数为：<script type="math/tex; mode=display">
N_{i n} * N_{o u t}+N_{o u t}</script></li>
<li>FLOPs：<strong>全称是floating point operations per second，指的是每秒浮点运算次数，即用来衡量硬件的计算性能</strong></li>
<li><strong>对于某个卷积层</strong>,它的FLOPs数量是：<script type="math/tex; mode=display">
\left[\left(K_{h} * K_{w} * C_{i n}\right) * C_{o u t}+C_{o u t}\right] *(H * W)=n u m_{-} \text { params } *(H * W)</script>其中，$num_{params}$表示该层参数的数量，H是输出图片的高，W是输出图片的宽</li>
<li><strong>例题1：假设你的输入是一个300×300的彩色（RGB）图像，而你没有使用卷积神经网络。 如果第一个隐藏层有100个神经元，每个神经元与输入层进行全连接，那么这个隐藏层有多少个参数（包括偏置参数）</strong>？</li>
<li>A1：因为输入的节点数量是300*300*3,输出的节点数量是100。然后加上偏置项b，因为隐藏层有100个节点，每个节点都有一个偏置，所以b=100。利用上面计算全连接网络的公式，故3*300*300*100+100</li>
<li><strong>例题2：假设你的输入是300×300彩色（RGB）图像，并且你使用卷积层和100个过滤器，每个过滤器都是5×5的大小，请问这个隐藏层有多少个参数（包括偏置参数）</strong>？</li>
<li>A2：首先，参数和输入的图片大小是没有关系的，无论你给的图像像素有多大，参数值都是不变的，在这个题中，参数值只与过滤器有关。单个过滤器的大小是5*5,由于输入的是RGB图像，所以输入通道数目是3。因此一个过滤器的组成是5*5*3,每一过滤器只有一个偏置项b,因此一个过滤器所拥有的参数是5*5*3+1=76，一共用了100个过滤器，所以隐藏层含有76*100=7600个参数。其实，也就是上面的公式计算CNN的参数量。</li>
</ul>
<h4 id="11-SVM中常见的几种核函数"><a href="#11-SVM中常见的几种核函数" class="headerlink" title="11.SVM中常见的几种核函数"></a>11.SVM中常见的几种核函数</h4><ul>
<li>线性核函数：内积公式<script type="math/tex; mode=display">
\kappa\left(x_{1}, x_{2}\right)=\left\langle x_{1}, x_{2}\right\rangle</script></li>
<li>多项式核函数<script type="math/tex; mode=display">
K(x, z)=(x \cdot z+1)^{p}</script></li>
<li>高斯核函数<script type="math/tex; mode=display">
K(x, z)=\exp \left(-\frac{\|x-z\|^{2}}{2 \sigma^{2}}\right)</script></li>
<li>字符串核函数：详见李航统计学习方法</li>
</ul>
<h4 id="12-逻辑回归与线性回归的联系与区别"><a href="#12-逻辑回归与线性回归的联系与区别" class="headerlink" title="12.逻辑回归与线性回归的联系与区别"></a>12.逻辑回归与线性回归的联系与区别</h4><ul>
<li>联系：逻辑回归和线性回归首先都是广义的线性回归；逻辑回归的模型本质上是一个对数线性回归模型，逻辑回归都是以线性回归为理论支持的。但线性回归模型无法做到sigmoid的非线性形式，sigmoid可以轻松处理0/1分类问题。</li>
<li>区别：<ul>
<li>线性模型的优化目标函数是最小二乘，而逻辑回归则是似然函数</li>
<li>线性回归在整个实数域范围内进行预测，敏感度一致；而分类范围，需要在[0,1]。逻辑回归就是一种减小预测范围，将预测值限定为[0,1]间的一种回归模型，因而对于这类问题来说，逻辑回归的鲁棒性比线性回归的要好。</li>
</ul>
</li>
</ul>
<h4 id="13-XGBoost为什么要用泰勒公式展开，优势在哪"><a href="#13-XGBoost为什么要用泰勒公式展开，优势在哪" class="headerlink" title="13.XGBoost为什么要用泰勒公式展开，优势在哪?"></a>13.XGBoost为什么要用泰勒公式展开，优势在哪?</h4><ul>
<li>XGBoost使用了一阶和二阶偏导, 二阶导数有利于梯度下降的更快更准。使用泰勒展开取得二阶倒数形式, 可以在不选定损失函数具体形式的情况下用于算法优化分析.本质上也就把损失函数的选取和模型算法优化和参数选择分开了，这种去耦合增加了XGBoost的适用性。</li>
</ul>
<h4 id="14-XGBoost如何寻找最优特征？是有放回还是无放回？"><a href="#14-XGBoost如何寻找最优特征？是有放回还是无放回？" class="headerlink" title="14.XGBoost如何寻找最优特征？是有放回还是无放回？"></a>14.XGBoost如何寻找最优特征？是有放回还是无放回？</h4><ul>
<li>XGBoost在训练过程中给各个特征的增益评分，最大增益的特征会被选出来作为分裂的依据，从而记忆了每个特征对在模型训练时的重要性。XGBoost属于boosting的集成学习方法，样本是无放回的，因此每轮计算样本不重复。XGBoost支持子采样，即每轮计算不使用全部样本，以减少过拟合。</li>
</ul>
<h4 id="15-决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？"><a href="#15-决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？" class="headerlink" title="15.决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？"></a>15.决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？</h4><ul>
<li>bagging与boosting的区别：<ul>
<li>bagging方法有放回的采样相同数量样本训练学习器，然后再一起投票。学习器之间不存在强的依赖关系，学习器可以并行训练生成。集成方式一般为投票法。随机森林属于Bagging的代表，放回抽样，每个学习器随机选择部分特征去优化。</li>
<li>Boosting方法使用全部样本，依次训练每个学习器，迭代集成。学习器之间不存在强依赖关系，学习器可并行训练生成，集成方式为加权和；Adaboost属于Boosting，采用指数损失函数代替原本分类任务中的0-1损失函数；GBDT属于Boosting的优秀代表，对函数残差近似值进行梯度下降，用CRAT树作为基本的学习器，集成模型为回归模型。XGBoost属于Boosting的集大成者，对函数残差近似值进行梯度下降，迭代时利用二阶梯度信息，集成模型可用于分类也可以用于回归。</li>
</ul>
</li>
<li>决策树的学习过程：从根开始建立树，也就是如何选择特征进行分裂。ID3算法使用信息增益、C4.5使用信息增益比、CART树采用基尼系数计算最优分类点，XGBoost使用二阶泰勒展开系数计算最优分裂点。</li>
</ul>
<h4 id="16-GBDT与XGBoost的对比，XGBoost的优点"><a href="#16-GBDT与XGBoost的对比，XGBoost的优点" class="headerlink" title="16.GBDT与XGBoost的对比，XGBoost的优点"></a>16.GBDT与XGBoost的对比，XGBoost的优点</h4><ul>
<li>损失函数用泰勒展开二项逼近，而不是像GBDT中用的就是一阶导数</li>
<li>对树的结构进行了正则化约束，防止模型过于复杂，降低了过拟合的可能性</li>
<li>节点的分裂方式不同，GBDT使用的是基尼系数，XGBoost使用的是经过优化推导后的算法(穷举法选择最佳的分裂节点、通过加权分位数方法近似选择最佳的分裂节点、针对稀疏特征的分裂点选择法)</li>
</ul>
<h4 id="17-L1和L2范数的区别"><a href="#17-L1和L2范数的区别" class="headerlink" title="17.L1和L2范数的区别"></a>17.L1和L2范数的区别</h4><ul>
<li>L1 norm:向量中各个元素绝对值之和，也称为稀疏规则算子，L1范数可以使权重稀疏，方便特征提取；L1正则化先验服从拉普拉斯分布</li>
<li>L2 norm:向量中各个元素平方和的1/2次方，又称为Frobenius范数，L2范数可以防止过拟合，提升模型的泛化能力；L2正则化先验服从高斯分布</li>
</ul>
<h4 id="18-阐述Adaboost算法的流程，并写出权重更新的公式"><a href="#18-阐述Adaboost算法的流程，并写出权重更新的公式" class="headerlink" title="18.阐述Adaboost算法的流程，并写出权重更新的公式"></a>18.阐述Adaboost算法的流程，并写出权重更新的公式</h4><ul>
<li><a href="https://www.jianshu.com/p/aae31290189e" target="_blank" rel="noopener">详细原理</a></li>
</ul>
<h4 id="19-LSTM的结构推导，为什么比普通的RNN好？"><a href="#19-LSTM的结构推导，为什么比普通的RNN好？" class="headerlink" title="19.LSTM的结构推导，为什么比普通的RNN好？"></a>19.LSTM的结构推导，为什么比普通的RNN好？</h4><ul>
<li><a href="https://www.jianshu.com/p/7c429d049b09" target="_blank" rel="noopener">详细原理</a></li>
</ul>
<h4 id="20-为什么朴素贝叶斯算法如此朴素？"><a href="#20-为什么朴素贝叶斯算法如此朴素？" class="headerlink" title="20.为什么朴素贝叶斯算法如此朴素？"></a>20.为什么朴素贝叶斯算法如此朴素？</h4><ul>
<li>因为它假设所有的特征在数据集中的作用都是同样重要的，而且相互独立的。这个假设在现实中基本上是不存在的，但特征相关性很小的实际情况还很多，岁月这个模型还可以工作的很好。</li>
</ul>
<h4 id="21-EM算法原理说明"><a href="#21-EM算法原理说明" class="headerlink" title="21.EM算法原理说明"></a>21.EM算法原理说明</h4><ul>
<li>有时候样本的产生和隐含变量有关(隐变量是不能观察的)，而求模型的参数时一般都采用极大似然估计，由于含有隐变量，所以对似然函数的参数求导数是求不出来的，这时候用EM算法来求模型的参数，典型的用法是用在GMM和HMM中。步骤如下：<ul>
<li>E步：选择一组参数，求出在此参数下隐变量的条件概率值<script type="math/tex; mode=display">
  Q_{i}\left(z^{(i)}\right) :=p\left(z^{(i)} | x^{(i)} ; \theta\right)</script></li>
<li>M步：结合E步求出的隐变量的条件概率值，求出似然函数的下界函数(即某个期望函数)最大值。<script type="math/tex; mode=display">
  \theta :=\arg \max _{\theta} \sum_{i} \sum_{z^{(i)}} Q_{i}\left(z^{(i)}\right) \log \frac{p\left(x^{(i)}, z^{(i)} ; \theta\right)}{Q_{i}\left(z^{(i)}\right)}</script></li>
<li>重复进行上面的两步，直至收敛为止。</li>
</ul>
</li>
<li>M步中下界函数的推导过程：<script type="math/tex; mode=display">
\begin{aligned} \sum_{i} \log p\left(x^{(i)} ; \theta\right) &=\sum_{i} \log \sum_{z^{(i)}} p\left(x^{(i)}, z^{(i)} ; \theta\right) \\ &=\sum_{i} \log \sum_{z^{(i)}} Q_{i}\left(z^{(i)}\right) \frac{p\left(x^{(i)}, z^{(i)} ; \theta\right)}{Q_{i}\left(z^{(i)}\right)} \\ & \geq \sum_{i} \sum_{z^{(i)}} Q_{i}\left(z^{(i)}\right) \log \frac{p\left(x^{(i)}, z^{(i)} ; \theta\right)}{Q_{i}\left(z^{(i)}\right)} \end{aligned}</script></li>
</ul>
<h4 id="22-GMM算法原理说明"><a href="#22-GMM算法原理说明" class="headerlink" title="22.GMM算法原理说明"></a>22.GMM算法原理说明</h4><ul>
<li>EM算法的常用例子是高斯混合模型GMM，每个样本都有可能由K个高斯模型产生，只不过每个高斯模型的产生概率不同，因此每个样本都有对应的高斯分布(K个模型中的一个)，此时的隐变量就是每个样本对应的某个高斯分布。<ul>
<li>GMM算法的E步(计算每个样本对应每个高斯模型的概率)<script type="math/tex; mode=display">
  w_{j}^{(i)} :=p\left(z^{(i)}=j | x^{(i)} ; \phi, \mu, \Sigma\right)</script>具体的计算公式为：<script type="math/tex; mode=display">
  p\left(z^{(i)}=j | x^{(i)} ; \phi, \mu, \Sigma\right)=\frac{p\left(x^{(i)} | z^{(i)}=j ; \mu, \Sigma\right) p\left(z^{(i)}=j ; \phi\right)}{\sum_{l=1}^{k} p\left(x^{(i)} | z^{(i)}=l ; \mu, \Sigma\right) p\left(z^{(i)}=l ; \phi\right)}</script></li>
<li>M步计算公式(计算每个高斯模型的权重，均值，方差3个参数)：<script type="math/tex; mode=display">
  \begin{aligned} \phi_{j} & :=\frac{1}{m} \sum_{i=1}^{m} w_{j}^{(i)} \\ \mu_{j} & :=\frac{\sum_{i=1}^{m} w_{j}^{(i)} x^{(i)}}{\sum_{i=1}^{m} w_{j}^{(i)}} \\ \Sigma_{j} & :=\frac{\sum_{i=1}^{m} w_{j}^{(i)}\left(x^{(i)}-\mu_{j}\right)\left(x^{(i)}-\mu_{j}\right)^{T}}{\sum_{i=1}^{m} w_{j}^{(i)}} \end{aligned}</script></li>
</ul>
</li>
</ul>
<h4 id="23-KNN算法中K是如何选择的"><a href="#23-KNN算法中K是如何选择的" class="headerlink" title="23.KNN算法中K是如何选择的?"></a>23.KNN算法中K是如何选择的?</h4><ul>
<li>如果选择较小的K值，就相当于用较小的邻域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大。换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；</li>
<li>如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。</li>
<li>K=N，此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的累，模型过于简单，忽略了训练实例中大量有用信息。</li>
<li>实际中，使用交叉验证的方法选择最优的K的取值。</li>
</ul>
<h4 id="24-机器学习中，为什么经常需要对数据进行归一化？"><a href="#24-机器学习中，为什么经常需要对数据进行归一化？" class="headerlink" title="24.机器学习中，为什么经常需要对数据进行归一化？"></a>24.机器学习中，为什么经常需要对数据进行归一化？</h4><ul>
<li>归一化能提高梯度下降算法求解的速度</li>
<li>归一化有可能提高精度</li>
</ul>
<h4 id="25-神经网络中的批量归一化Batch-Normalization-BN-原理"><a href="#25-神经网络中的批量归一化Batch-Normalization-BN-原理" class="headerlink" title="25.神经网络中的批量归一化Batch Normalization(BN)原理"></a>25.神经网络中的批量归一化Batch Normalization(BN)原理</h4><ul>
<li><a href="https://blog.csdn.net/cdlwhm1217096231/article/details/95391398" target="_blank" rel="noopener">详细原理</a></li>
</ul>
<h4 id="26-哪些机器学习算法不需要进行归一化操作？"><a href="#26-哪些机器学习算法不需要进行归一化操作？" class="headerlink" title="26.哪些机器学习算法不需要进行归一化操作？"></a>26.哪些机器学习算法不需要进行归一化操作？</h4><ul>
<li>概率模型不需要做归一化操作，因为它们不关心变量的值，而关心的是变量分布和变量之间的条件概率，如决策树。但是，像Adaboost、SVM、LR、KNN、Kmeans等最优化问题就需要归一化。</li>
</ul>
<h4 id="27-为什么树形结构不需要归一化？"><a href="#27-为什么树形结构不需要归一化？" class="headerlink" title="27.为什么树形结构不需要归一化？"></a>27.为什么树形结构不需要归一化？</h4><ul>
<li>数值缩放，不影响分裂点位置。因为第一步都是按照特征值进行排序的，排序的顺序不变，那么所属的分支以及分裂点就不会变。对于线性模型，比如说LR，假设有两个特征，一个是(0,1)的，一个是(0,10000)的，这样运用梯度下降时候，损失等高线是一个椭圆的形状，这样想迭代到最优点，就需要很多次迭代，但是如果进行了归一化，那么等高线就是圆形的，那么SGD就会往原点迭代，需要的迭代次数较少。另外，注意树模型是不能进行梯度下降的，因为树模型是阶跃的，阶跃点是不可导的，并且求导没意义，所以树模型（回归树）寻找最优点是通过寻找最优分裂点完成的。</li>
</ul>
<h4 id="28-一个完整机器学习项目的流程"><a href="#28-一个完整机器学习项目的流程" class="headerlink" title="28.一个完整机器学习项目的流程"></a>28.一个完整机器学习项目的流程</h4><ul>
<li>抽象成数学问题、获取数据、特征预处理与特征选择、训练模型与调优、模型诊断、模型融合、上线运行</li>
</ul>
<h4 id="29-条件随机场CRF模型相对于HMM模型-隐马尔科夫模型-和MEMM模型-最大熵隐马尔科夫模型-的优势。"><a href="#29-条件随机场CRF模型相对于HMM模型-隐马尔科夫模型-和MEMM模型-最大熵隐马尔科夫模型-的优势。" class="headerlink" title="29.条件随机场CRF模型相对于HMM模型(隐马尔科夫模型)和MEMM模型(最大熵隐马尔科夫模型)的优势。"></a>29.条件随机场CRF模型相对于HMM模型(隐马尔科夫模型)和MEMM模型(最大熵隐马尔科夫模型)的优势。</h4><ul>
<li>HMM模型中一个最大的缺点即其输出独立性假设，由于输出独立性假设的缺点导致HMM模型不能考虑上下文的特征，限制了特征的选择。</li>
<li>MEMM模型则解决了HMM模型的最大的缺点，可以任意选择特征，但是由于其每一个节点都要进行归一化，所以只能找到局部最优值。同时，也带来了标记偏见的问题即凡是在训练语料库中未出现的情况都被忽略掉了。CRF模型很好的解决了这个问题，它并不在每一节点进行归一化，而是所有特征进行全局归一化，因此可以求出全局的最优值。</li>
</ul>
<h4 id="30-什么是熵？"><a href="#30-什么是熵？" class="headerlink" title="30.什么是熵？"></a>30.什么是熵？</h4><ul>
<li>熵的定义：离散随机事件的出现概率。一个系统越是有序，信息熵就越低。信息熵可以被认为是系统有序化程度的一个度量。</li>
</ul>
<h4 id="31-BP反向传播算法推导及python实现"><a href="#31-BP反向传播算法推导及python实现" class="headerlink" title="31.BP反向传播算法推导及python实现"></a>31.BP反向传播算法推导及python实现</h4><p><img src="https://upload-images.jianshu.io/upload_images/13407176-4e2c5d2d7e253c9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-bc9a950264c79a8c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-d451c71b72960fc2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p>
<ul>
<li>python代码实现：<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">import numpy <span class="keyword">as</span> np</span><br><span class="line">import matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">class MLP():</span><br><span class="line">    def __init__(<span class="keyword">self</span>, name=<span class="symbol">'nn</span>', layer_structure=[], task_model=<span class="literal">None</span>, batch_size=<span class="number">1</span>, load_model=<span class="literal">None</span>):</span><br><span class="line">        <span class="string">""</span><span class="string">"layer_number : 神经网络的层数</span></span><br><span class="line"><span class="string">           layer_structure = [输入的特征个数，第1层神经元个数，第2层神经元个数，...，最后一层神经元个数输出层特征个数]，</span></span><br><span class="line"><span class="string">           如网络层数设为layer_number=3, layer_structure=[20,10,5,1]：输入特征是20个，第一层有10个神经元，第二层5个，第三层1个.</span></span><br><span class="line"><span class="string">           output_model = 'regression'/'logistic'</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.layer_number = len(layer_structure) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.layer_structure = layer_structure</span><br><span class="line">        <span class="keyword">self</span>.task_model = task_model</span><br><span class="line">        <span class="keyword">self</span>.W = []</span><br><span class="line">        <span class="keyword">self</span>.B = []</span><br><span class="line">        <span class="keyword">self</span>.batch_size = batch_size</span><br><span class="line">        <span class="keyword">self</span>.total_loss = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.task_model == <span class="symbol">'logistic</span>' or <span class="keyword">self</span>.task_model == <span class="symbol">'multi</span>':</span><br><span class="line">            <span class="keyword">self</span>.total_accuracy = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> load_model == <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">"Initializing the network from scratch ..."</span>)</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">                <span class="keyword">self</span>.W.append(np.random.randn(<span class="keyword">self</span>.layer_structure[index], <span class="keyword">self</span>.layer_structure[index+<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">self</span>.B.append(np.random.randn(<span class="number">1</span>, <span class="keyword">self</span>.layer_structure[index+<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Initializing the network from trained model ..."</span>)</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">                <span class="keyword">self</span>.W.append(np.loadtxt(load_model + <span class="keyword">self</span>.name + <span class="string">"_layer_"</span> + <span class="built_in">str</span>(index) + <span class="string">"_W.txt"</span>).reshape(<span class="keyword">self</span>.layer_structure[index], <span class="keyword">self</span>.layer_structure[index+<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">self</span>.B.append(np.loadtxt(load_model + <span class="keyword">self</span>.name + <span class="string">"_layer_"</span> + <span class="built_in">str</span>(index) + <span class="string">"_B.txt"</span>).reshape(<span class="number">1</span>, <span class="keyword">self</span>.layer_structure[index+<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    def normal_parameters(<span class="keyword">self</span>, means, sigmas):</span><br><span class="line">        <span class="keyword">self</span>.means = means</span><br><span class="line">        <span class="keyword">self</span>.sigams = sigmas</span><br><span class="line"></span><br><span class="line">    def sigmoid(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line">    def sigmoid_gradient(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.sigmoid(x)*(<span class="number">1</span>-<span class="keyword">self</span>.sigmoid(x))</span><br><span class="line"></span><br><span class="line">    def softmax(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="keyword">return</span> np.exp(x)/np.sum(np.exp(x), axis = <span class="number">1</span>, keepdims = True)</span><br><span class="line"></span><br><span class="line">    def forward(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            intput : x = [batch_size, features]</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.before_activation = []</span><br><span class="line">        <span class="keyword">self</span>.activations = [x]</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="keyword">self</span>.layer_number - <span class="number">1</span>:</span><br><span class="line">                Z = np.dot(<span class="keyword">self</span>.activations[index], <span class="keyword">self</span>.W[index]) + <span class="keyword">self</span>.B[index]</span><br><span class="line">                <span class="keyword">self</span>.before_activation.append(Z)</span><br><span class="line">                <span class="keyword">self</span>.activations.append(<span class="keyword">self</span>.sigmoid(Z))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.task_model == <span class="symbol">'logistic</span>':</span><br><span class="line">                    Z = np.dot(<span class="keyword">self</span>.activations[index], <span class="keyword">self</span>.W[index]) + <span class="keyword">self</span>.B[index]</span><br><span class="line">                    <span class="keyword">self</span>.before_activation.append(Z)</span><br><span class="line">                    <span class="keyword">self</span>.activations.append(<span class="keyword">self</span>.sigmoid(Z))</span><br><span class="line">                elif <span class="keyword">self</span>.task_model == <span class="symbol">'regression</span>':</span><br><span class="line">                    Z = np.dot(<span class="keyword">self</span>.activations[index], <span class="keyword">self</span>.W[index]) + <span class="keyword">self</span>.B[index]</span><br><span class="line">                    <span class="keyword">self</span>.before_activation.append(Z)</span><br><span class="line">                    <span class="keyword">self</span>.activations.append(Z)</span><br><span class="line">                elif <span class="keyword">self</span>.task_model == <span class="symbol">'multi</span>':</span><br><span class="line">                    Z = np.dot(<span class="keyword">self</span>.activations[index], <span class="keyword">self</span>.W[index]) + <span class="keyword">self</span>.B[index]</span><br><span class="line">                    <span class="keyword">self</span>.before_activation.append(Z)</span><br><span class="line">                    <span class="keyword">self</span>.activations.append(<span class="keyword">self</span>.softmax(Z))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.activations[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    def __call__(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.forward(x)</span><br><span class="line"></span><br><span class="line">    def lossfunction(<span class="keyword">self</span>, inputs, target):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.task_model == <span class="symbol">'regression</span>':</span><br><span class="line">            <span class="keyword">return</span>(np.mean(np.sum((inputs - target)**<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line">        elif <span class="keyword">self</span>.task_model == <span class="symbol">'logistic</span>':</span><br><span class="line">            <span class="keyword">return</span> np.mean(np.sum(-target*np.log(inputs+<span class="number">1e-14</span>) - (<span class="number">1</span>-target)*np.log(<span class="number">1</span>-inputs+<span class="number">1e-14</span>), <span class="number">1</span>))</span><br><span class="line">        elif <span class="keyword">self</span>.task_model == <span class="symbol">'multi</span>':</span><br><span class="line">            <span class="keyword">return</span> np.mean(np.sum(-target*np.log(inputs+<span class="number">1e-14</span>), <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    def back_forward(<span class="keyword">self</span>, targets=<span class="literal">None</span>, loss=<span class="literal">None</span>, regularization=False):</span><br><span class="line">        <span class="keyword">self</span>.dWs = []</span><br><span class="line">        <span class="keyword">self</span>.dBs = []</span><br><span class="line">        <span class="keyword">self</span>.dAs = []</span><br><span class="line">        W_reverse = <span class="keyword">self</span>.W[::-<span class="number">1</span>]</span><br><span class="line">        activations_reverse = <span class="keyword">self</span>.activations[::-<span class="number">1</span>]</span><br><span class="line">        before_activation_reverse = <span class="keyword">self</span>.before_activation[::-<span class="number">1</span>]</span><br><span class="line">        # 从最后一层开始往回传播</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">if</span> loss == <span class="symbol">'MSE</span>' or loss == <span class="symbol">'CE</span>' or loss == <span class="symbol">'BE</span>':</span><br><span class="line">                    dZ = activations_reverse[k] - targets</span><br><span class="line">                    dW = <span class="number">1</span>/<span class="keyword">self</span>.batch_size*np.dot(activations_reverse[k+<span class="number">1</span>].T, dZ)</span><br><span class="line">                    dB = <span class="number">1</span>/<span class="keyword">self</span>.batch_size*np.sum(dZ, axis = <span class="number">0</span>, keepdims = True)</span><br><span class="line">                    dA_before = np.dot(dZ, W_reverse[k].T)</span><br><span class="line">                    <span class="keyword">self</span>.dWs.append(dW)</span><br><span class="line">                    <span class="keyword">self</span>.dBs.append(dB)</span><br><span class="line">                    <span class="keyword">self</span>.dAs.append(dA_before)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dZ = <span class="keyword">self</span>.dAs[k-<span class="number">1</span>]*<span class="keyword">self</span>.sigmoid_gradient(before_activation_reverse[k])</span><br><span class="line">                dW = <span class="number">1</span>/<span class="keyword">self</span>.batch_size*np.dot(activations_reverse[k+<span class="number">1</span>].T,dZ)</span><br><span class="line">                dB = <span class="number">1</span>/<span class="keyword">self</span>.batch_size*np.sum(dZ, axis = <span class="number">0</span>, keepdims = True)</span><br><span class="line">                dA_before = np.dot(dZ, W_reverse[k].T)</span><br><span class="line">                <span class="keyword">self</span>.dWs.append(dW)</span><br><span class="line">                <span class="keyword">self</span>.dBs.append(dB)</span><br><span class="line">                <span class="keyword">self</span>.dAs.append(dA_before)</span><br><span class="line">        <span class="keyword">self</span>.dWs = <span class="keyword">self</span>.dWs[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">self</span>.dBs = <span class="keyword">self</span>.dBs[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    def steps(<span class="keyword">self</span>, lr=<span class="number">0.001</span>, lr_decay=False):</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(<span class="keyword">self</span>.dWs)):</span><br><span class="line">            <span class="keyword">self</span>.W[index] -= lr*<span class="keyword">self</span>.dWs[index]</span><br><span class="line">            <span class="keyword">self</span>.B[index] -= lr*<span class="keyword">self</span>.dBs[index]</span><br><span class="line"></span><br><span class="line">    def train(<span class="keyword">self</span>, train_datas=<span class="literal">None</span>, train_targets=<span class="literal">None</span>, train_epoch=<span class="number">1</span>, lr=<span class="number">0.001</span>, lr_decay=False, loss=<span class="symbol">'MSE</span>', regularization=False, display=False):</span><br><span class="line">        train_counts = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(train_epoch):</span><br><span class="line">            <span class="keyword">if</span> epoch == int(train_epoch * <span class="number">0.7</span>) and lr_decay == True:</span><br><span class="line">                lr *= <span class="number">0.1</span></span><br><span class="line">            train_steps = train_datas.shape[<span class="number">0</span>] <span class="comment">// self.batch_size</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(train_steps):</span><br><span class="line">                input_data = train_datas[<span class="keyword">self</span>.batch_size*i : <span class="keyword">self</span>.batch_size*(i+<span class="number">1</span>), :].reshape(<span class="keyword">self</span>.batch_size, train_datas.shape[<span class="number">1</span>])</span><br><span class="line">                targets = train_targets[<span class="keyword">self</span>.batch_size*i : <span class="keyword">self</span>.batch_size*(i+<span class="number">1</span>), :].reshape(<span class="keyword">self</span>.batch_size, train_targets.shape[<span class="number">1</span>])</span><br><span class="line">                prediction = <span class="keyword">self</span>.forward(input_data)</span><br><span class="line">                forward_loss = <span class="keyword">self</span>.lossfunction(prediction, targets)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.task_model==<span class="symbol">'logistic</span>':</span><br><span class="line">                    accuracy = np.sum((prediction&gt;<span class="number">0.6</span>) == targets) / targets.shape[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">self</span>.total_accuracy.append(accuracy)</span><br><span class="line">                elif <span class="keyword">self</span>.task_model==<span class="symbol">'multi</span>':</span><br><span class="line">                    accuracy = np.sum(np.argmax(prediction,<span class="number">1</span>) == np.argmax(targets,<span class="number">1</span>)) / targets.shape[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">self</span>.total_accuracy.append(accuracy)</span><br><span class="line">                <span class="keyword">self</span>.total_loss.append(forward_loss)</span><br><span class="line">                <span class="keyword">if</span> display:</span><br><span class="line">                    <span class="keyword">if</span> train_counts % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">self</span>.task_model == <span class="symbol">'logistic</span>' or <span class="keyword">self</span>.task_model == <span class="symbol">'multi</span>':</span><br><span class="line">                            print(<span class="string">"After "</span> + <span class="built_in">str</span>(train_counts) + <span class="string">", loss is "</span>, forward_loss,</span><br><span class="line">                            <span class="string">", accuracy is "</span>, accuracy)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            print(<span class="string">"After "</span> + <span class="built_in">str</span>(train_counts) + <span class="string">", loss is "</span>, forward_loss)</span><br><span class="line">                <span class="keyword">self</span>.back_forward(targets=targets, loss=loss, regularization=regularization)</span><br><span class="line">                <span class="keyword">self</span>.steps(lr=lr, lr_decay=lr_decay)</span><br><span class="line">                train_counts += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    def save_model(<span class="keyword">self</span>, path):</span><br><span class="line">        print(<span class="string">"Saving the "</span> + <span class="keyword">self</span>.name + <span class="string">" model ..."</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">            np.savetxt(path  + <span class="keyword">self</span>.name + <span class="string">"_layer_"</span> + <span class="built_in">str</span>(i) + <span class="string">"_W.txt"</span>, <span class="keyword">self</span>.W[i])</span><br><span class="line">            np.savetxt(path  + <span class="keyword">self</span>.name + <span class="string">"_layer_"</span> + <span class="built_in">str</span>(i) + <span class="string">"_B.txt"</span>, <span class="keyword">self</span>.B[i])</span><br><span class="line">        print(<span class="string">"Model saved !!!"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="32-K-Means算法的原理"><a href="#32-K-Means算法的原理" class="headerlink" title="32.K_Means算法的原理"></a>32.K_Means算法的原理</h4><ul>
<li>聚类算法综述：聚类算法是一种无监督学习算法，它是将相似的对象归到同一个簇中。K均值算法中的K可以理解用户想要聚类成K个不同的簇，K是一个用户可以自行定义的超参数。</li>
<li>K均值聚类的优缺点：<ul>
<li>优点：容易实现</li>
<li>缺点：可能收敛到局部最小值，在大规模的数据上收敛慢</li>
<li>适用场合：数值型数据</li>
</ul>
</li>
<li>K_Means算法的基本流程：<ul>
<li>1.随机选择K个点作为起始的聚类中心</li>
<li>2.遍历每个样本，计算每个样本到K个聚类中心的距离，找出”距离”聚类中心最近的样本，并将此样本聚集到离它最近的那一个簇中。<strong>注：K_Means算法的性能会受到所选距离计算方法的影响</strong>。</li>
<li>3.所有样本都聚集到K个簇完成后，计算K个簇的均值，并将聚类中心移动到K个簇的均值处作为新的聚类中心。</li>
<li>4.重复上述步骤2~3，直到最大迭代次数就停止。</li>
</ul>
</li>
<li><strong>K_Means算法的优化(为了克服收敛于局部最小值提出)</strong>：如何知道生成的簇比较好？一种用来衡量K_Means算法聚类效果的指标是SSE误差平方和(预测数据与原始数据之间误差的平方和),SSE越小表示样本点越接近于聚类中心点，聚类效果越好。<strong>因为对误差取了平方，因此更加重视那些远离聚类中心的点(未理解)</strong>。降低SSE值的方法是增加簇的个数，但是簇的个数K在算法一开始运行时就固定了，不能改变。聚类的目标是在保持原有簇数目不变的条件下，提高簇的质量。<strong>常用思想是：对生成的簇进行后处理，将具有最大SSE值的簇划分成两个簇。为了保持簇的总数不变，可以将某两个簇进行合并</strong>。可以有下面两种方法合并：<ul>
<li>1.合并最近的聚类中心：计算所有聚类中心之间的距离，合并距离最近的两个聚类中心点。</li>
<li>2.合并两个使得SSE增加最小的聚类中心：合并两个簇，然后计算总的SSE。必须在所有可能的两个簇上重复上述处理过程，直到找到合并最佳的两个簇。</li>
</ul>
</li>
</ul>
<h4 id="33-常见的距离函数总结"><a href="#33-常见的距离函数总结" class="headerlink" title="33.常见的距离函数总结"></a>33.常见的距离函数总结</h4><ul>
<li>闵可夫斯基距离：给定样本$\overrightarrow{\mathbf{x}}<em>{i}=\left(x</em>{i, 1}, x<em>{i, 2}, \cdots, x</em>{i, n}\right)^{T}$,$\overrightarrow{\mathbf{x}}<em>{j}=\left(x</em>{j, 1}, x<em>{j, 2}, \cdots, x</em>{j, n}\right)^{T}$，则闵可夫斯基距离定义为：<script type="math/tex; mode=display">
\text { distance( }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left(\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{p}\right)^{1 / p}</script></li>
<li>当p=2时，闵可夫斯基距离就是<strong>欧式距离</strong>：<script type="math/tex; mode=display">
\operatorname{distance}\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{2}=\sqrt{\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{2}}</script></li>
<li>当p=1时，闵可夫斯基距离就是<strong>曼哈顿距离</strong>：<script type="math/tex; mode=display">
\text { distance }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{1}=\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|</script></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统知识点总结</title>
    <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h4><ul>
<li>对于有线程系统：<ul>
<li>进程是资源分配的独立单位</li>
<li>线程是资源调度的独立单位</li>
</ul>
</li>
<li>对无无线程系统：<ul>
<li>进程是资源调度、分配的独立单位</li>
</ul>
</li>
</ul>
<h4 id="2-进程间的通信方式及优缺点"><a href="#2-进程间的通信方式及优缺点" class="headerlink" title="2.进程间的通信方式及优缺点"></a>2.进程间的通信方式及优缺点</h4><ul>
<li><strong>管道</strong><ul>
<li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信。<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：<ul>
<li>a.长期存于系统中，使用不当容易出错</li>
<li>b.缓冲区有限</li>
</ul>
</li>
</ul>
</li>
<li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul>
<li>优点：简单方便</li>
<li>缺点：<ul>
<li>a.局限于单向通信</li>
<li>b.只能创建在它的进程以及其有亲缘关系的进程之间</li>
<li>c.缓冲区有限</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>信号量</strong>：一个计数器，可以用来控制多个线程对共享资源的访问<ul>
<li>优点：可以同步进程</li>
<li>缺点：信号量有限</li>
</ul>
</li>
<li><strong>信号</strong>: 一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
<li><strong>消息队列</strong>: 是消息的链表，存放在内核中并由消息队列标识符标识<ul>
<li>优点： 可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li>
<li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li>
</ul>
</li>
<li><strong>共享内存</strong>：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul>
<li>优点：无须复制，快捷，信息量大</li>
<li>缺点：<ul>
<li>a.通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li>
<li>b.利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ul>
</li>
</ul>
</li>
<li><strong>套接字</strong>：可用于不同及其间的进程通信<ul>
<li>优点：<ul>
<li>a.传输数据为字节级，传输数据可自定义，数据量小效率高</li>
<li>b.传输数据时间短，性能高</li>
<li>c.适合于客户端和服务器端之间信息实时交互</li>
<li>d.可以加密,数据安全性强</li>
</ul>
</li>
<li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
</li>
</ul>
<h4 id="3-线程之间的通信方式"><a href="#3-线程之间的通信方式" class="headerlink" title="3.线程之间的通信方式"></a>3.线程之间的通信方式</h4><ul>
<li><strong>锁机制</strong>：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul>
<li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>自旋锁（spin lock）：与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li>
<li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
</li>
<li><strong>信号量机制</strong><ul>
<li>无名线程信号量</li>
<li>有名线程信号量</li>
</ul>
</li>
<li><strong>信号机制(Signal)</strong>：类似进程间的信号处理</li>
<li><strong>屏障</strong>：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<h4 id="4-进程之间私有和共享的资源"><a href="#4-进程之间私有和共享的资源" class="headerlink" title="4.进程之间私有和共享的资源"></a>4.进程之间私有和共享的资源</h4><ul>
<li>私有：地址空间、堆、全局变量、栈、寄存器</li>
<li>共享：代码段，公共数据，进程目录，进程 ID</li>
</ul>
<h4 id="5-线程之间私有和共享的资源"><a href="#5-线程之间私有和共享的资源" class="headerlink" title="5.线程之间私有和共享的资源"></a>5.线程之间私有和共享的资源</h4><ul>
<li>私有：线程栈，寄存器，程序寄存器</li>
<li>共享：堆，地址空间，全局变量，静态变量</li>
</ul>
<h4 id="6-多进程与多线程间的对比、优劣与选择"><a href="#6-多进程与多线程间的对比、优劣与选择" class="headerlink" title="6.多进程与多线程间的对比、优劣与选择"></a>6.多进程与多线程间的对比、优劣与选择</h4><p><img src="https://upload-images.jianshu.io/upload_images/13407176-f1d727410790e1b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="特点对比.jpg"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-c113b6d4576c9f27.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优缺点对比.jpg"></p>
<ul>
<li>线程与进程选用规则：<ul>
<li>需要频繁创建销毁的优先用线程</li>
<li>需要进行大量计算的优先使用线程</li>
<li>强相关的处理用线程，弱相关的处理用进程</li>
<li>可能要扩展到多机分布的用进程，多核分布的用线程</li>
<li>都满足需求的情况下，用你最熟悉、最拿手的方式</li>
</ul>
</li>
</ul>
<h4 id="7-Linux的内核同步方式"><a href="#7-Linux的内核同步方式" class="headerlink" title="7.Linux的内核同步方式"></a>7.Linux的内核同步方式</h4><ul>
<li><strong>为什么需要内核同步？</strong>：在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程、多线程编程一样也需要一些同步机制来同步<strong>各执行单元对共享数据的访问</strong>。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</li>
<li><strong>内核同步方式</strong>:<ul>
<li>原子操作</li>
<li>信号量（semaphore）</li>
<li>读写信号量（rw_semaphore）</li>
<li>自旋锁（spinlock）</li>
<li>大内核锁（BKL，Big Kernel Lock）</li>
<li>读写锁（rwlock）</li>
<li>大读者锁（brlock-Big Reader Lock）</li>
<li>读-拷贝修改(RCU，Read-Copy Update)</li>
<li>顺序锁（seqlock）</li>
</ul>
</li>
</ul>
<h4 id="8-死锁"><a href="#8-死锁" class="headerlink" title="8.死锁"></a>8.死锁</h4><ul>
<li>定义：<strong>是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。</strong></li>
<li><strong>死锁产生的条件</strong>：<ul>
<li>互斥</li>
<li>请求和保持</li>
<li>不可剥夺</li>
<li>环路等待</li>
</ul>
</li>
<li><strong>预防死锁</strong>：<ul>
<li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li>
<li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li>
<li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li>
<li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li>
<li>有序资源分配法</li>
<li><a href="https://blog.csdn.net/jgm20475/article/details/81265947" target="_blank" rel="noopener">银行家算法</a></li>
</ul>
</li>
</ul>
<h4 id="9-页面置换算法"><a href="#9-页面置换算法" class="headerlink" title="9.页面置换算法"></a>9.页面置换算法</h4><ul>
<li><strong>页面置换</strong>：在地址映射过程中，如果在页面中发现所要访问的页面不存在于内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</li>
<li><p><strong>分类</strong>：</p>
<ul>
<li>全局置换：在整个内存空间置换<ul>
<li>工作集算法</li>
<li>缺失率置换算法</li>
</ul>
</li>
<li><p>局部置换：在本进程中进行置换</p>
<ul>
<li>最佳置换算法(OPT)<ul>
<li>原理：从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 <a href="https://blog.csdn.net/jack450250844/article/details/84986690" target="_blank" rel="noopener">详见原理</a></li>
</ul>
</li>
<li><p>先进先出置换算法(FIFO)</p>
<ul>
<li>原理：该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老的页面。但该算法与进程实际运行的规律不相适应，因为在进程中，有些页面经常被访问，比如，含有全局变量、常用函数、例程等的页面，FIFO算法并不能保证这些页面不被淘汰。<a href="https://blog.csdn.net/jack450250844/article/details/85019950" target="_blank" rel="noopener">详见原理</a></li>
</ul>
</li>
<li><p>最近最久未使用算法(LRU)</p>
<ul>
<li>原理：根据页面调入内存后的使用情况做出决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有也面中t值最大的，即最近最久未使用的页面予以淘汰。<a href="https://blog.csdn.net/jack450250844/article/details/85019898" target="_blank" rel="noopener">详见原理</a></li>
</ul>
</li>
<li>时钟置换算法(Clock)<ul>
<li>原理：淘汰访问位为0的页框中的页面，被访问过的页面将其页框的访问位数值置1。<a href="https://blog.csdn.net/Long_H_Zhu/article/details/84184563" target="_blank" rel="noopener">详见原理</a></li>
</ul>
</li>
</ul>
</li>
<li>局部置换的三种算法C++代码  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> page[] = &#123; <span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FIFO</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OPT</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RLU</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inArray</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    FIFO();</span><br><span class="line">    OPT();</span><br><span class="line">    RLU();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FIFO算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FIFO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">3</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"FIFO:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (page[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inArray(temp, <span class="number">3</span>, page[num])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            error++;</span><br><span class="line">            <span class="keyword">bool</span> hasChanged = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (time[i] == <span class="number">0</span> &amp;&amp; hasChanged == <span class="literal">false</span>) &#123;</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    hasChanged = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (time[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    time[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误率:"</span> &lt;&lt; error &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inArray</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == a[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OPT算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OPT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//OPT已知未来的页数为20</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"OPT:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (page[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = page[num];</span><br><span class="line">        <span class="keyword">if</span> (inArray(temp, <span class="number">3</span>, page[num])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            error++;</span><br><span class="line">            <span class="keyword">bool</span> fuck = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    fuck = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fuck == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> distance[<span class="number">3</span>] = &#123; <span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span> &#125;;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= num; i--) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (temp[j] == page[i] &amp;&amp; (i - num) &lt; distance[j]) &#123;</span><br><span class="line">                            distance[j] = i - num;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (max &lt; distance[i]) &#123;</span><br><span class="line">                        max = distance[i];</span><br><span class="line">                        k = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                temp[k] = page[num];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误率:"</span> &lt;&lt; error &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RLU算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RLU</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"RLU:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (page[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = page[num];</span><br><span class="line">        <span class="keyword">if</span> (inArray(temp, <span class="number">3</span>, page[num])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//bool Changed = false;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == page[num]) &#123;</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//Changed = true;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] != page[num]&amp;&amp;time[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">                    time[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            error++;</span><br><span class="line">            <span class="comment">//bool hasChange = false;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(time[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    time[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误率:"</span> &lt;&lt; error &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="10-进程状态转换图"><a href="#10-进程状态转换图" class="headerlink" title="10.进程状态转换图"></a>10.进程状态转换图</h4><p><img src="https://upload-images.jianshu.io/upload_images/13407176-2d3db5b8d56f27a8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程的五种基本状态"></p>
<ul>
<li>进程的五种基本状态：<ul>
<li>创建状态：进程正在被创建</li>
<li>就绪状态：进程被加入到就绪队列中等待CPU调度运行</li>
<li>执行状态：进程正在被运行</li>
<li>等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行</li>
<li>终止状态：进程运行完毕</li>
</ul>
</li>
</ul>
<h4 id="11-软链接和硬链接的区别"><a href="#11-软链接和硬链接的区别" class="headerlink" title="11.软链接和硬链接的区别"></a>11.软链接和硬链接的区别</h4><ul>
<li>软链接也叫符号链接，软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</li>
<li>硬链接：通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</li>
</ul>
<h4 id="12-协程"><a href="#12-协程" class="headerlink" title="12.协程"></a>12.协程</h4><ul>
<li><p>定义：又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。例如：</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span> :</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'2'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'3'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span> :</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'x'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'y'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'z'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上面协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。</p>
</li>
</ul>
<h4 id="13-协程与线程的区别"><a href="#13-协程与线程的区别" class="headerlink" title="13.协程与线程的区别"></a>13.协程与线程的区别</h4><ul>
<li>协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制。因此，没有线程切换的开销。协程和多线程相比，线程数量越多，协程的性能优势就越明显。</li>
<li>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突。在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li>
</ul>
<h4 id="14-进程同步的几种方式"><a href="#14-进程同步的几种方式" class="headerlink" title="14.进程同步的几种方式"></a>14.进程同步的几种方式</h4><ul>
<li><strong>信号量</strong>：用于进程间传递信号的一个整数值。</li>
<li>在信号量上只有三种操作可以进行：初始化、P操作、V操作，这三种操作都是原子操作。<strong>P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程</strong>。</li>
<li>原理：两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。该信号即为信号量s。为通过信号量s传送信号，进程可执行原语semSignal(s);为通过信号量s接收信号，进程可执行原语semWait(s);如果相应的信号仍然没有发送，则进程被阻塞，直到发送完为止。可把信号量视为一个具有整数值的变量，在它之上定义三个操作：<ul>
<li>一个信号量可以初始化为非负数；</li>
<li>semWait操作使信号量s减1.若值为负数，则执行semWait的进程被阻塞。否则进程继续执行；</li>
<li>semSignal操作使信号量加1，若值大于或等于零，则被semWait操作阻塞的进程被解除阻塞</li>
</ul>
</li>
<li><strong>管程</strong>：由一个或多个过程、一个初始化序列和局部数据组成的软件模块，其主要特点如下：<ul>
<li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问；</li>
<li>一个进程通过调用管程的一个过程进入管程；</li>
<li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用；</li>
</ul>
</li>
<li><strong>消息传递</strong>：是进程间进程消息传递所需要的最小操作集。一个进程以消息的形式给另一个指定的目标进程发送消息；进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。</li>
</ul>
<h4 id="15-线程同步的几种方式"><a href="#15-线程同步的几种方式" class="headerlink" title="15.线程同步的几种方式"></a>15.线程同步的几种方式</h4><ul>
<li><strong>临界区</strong>:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</li>
<li><strong>互斥量</strong>:采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。</li>
<li><strong>信号量</strong>:它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</li>
<li><strong>事件</strong>:通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。<h4 id="16-操作系统中程序的内存结构"><a href="#16-操作系统中程序的内存结构" class="headerlink" title="16.操作系统中程序的内存结构"></a>16.操作系统中程序的内存结构</h4><img src="https://upload-images.jianshu.io/upload_images/13407176-51b3576acab2510c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="操作系统中的内存结构"></li>
<li><strong>一个程序本质上都是由BSS段、数据段(data段)、text段(代码段)三个组成的</strong>。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</li>
<li><strong>BSS段（未初始化数据区）</strong>：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</li>
<li><strong>数据段</strong>：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</li>
<li><strong>代码段</strong>：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。<ul>
<li>BSS段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中，其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</li>
<li>data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。<strong>包含数据段和BSS段的整个区段此时通常称为数据区</strong>。</li>
</ul>
</li>
<li><strong>可执行程序在运行时又多出两个区域：栈区和堆区</strong>。<ul>
<li>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</li>
<li>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的文件打包与压缩方法总结</title>
    <url>/Linux/Linux%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="一、文件打包和解压缩"><a href="#一、文件打包和解压缩" class="headerlink" title="一、文件打包和解压缩"></a>一、文件打包和解压缩</h3><ul>
<li>在windows系统上最常见的压缩文件不外乎这三种*.zip,*.rar,*.7z后缀的压缩文件，而在Linux系统上常见常用的除了以上的三种之外，还有*.gz,*.xz,*.bz2,*.tar,*tar.gz,*tar.xz,*.tar.bz2等后缀的压缩文件。</li>
<li><p>1..zip压缩打包程序</p>
<ul>
<li><p>1.1 打包文件夹<br>zip -r -q -o njust.zip /home/cdl</p>
<ul>
<li>参数说明:<ul>
<li>-r：表示递归打包包含子目录的全部内容</li>
<li>-q：表示为安静模式，即不向屏幕输出信息</li>
<li>-o：表示输出文件，需要在其后紧跟打包输出文件名</li>
</ul>
</li>
<li>查看压缩文件的信息：  <figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">du -<span class="keyword">h</span> njust.<span class="keyword">zip</span></span><br><span class="line"><span class="keyword">file</span> njust.<span class="keyword">zip</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>1.2 设置压缩等级(9最小,1最大)<br>  zip -r 9 -q -o njust_9.zip /home/cdl -x ~/*.zip<br>  zip -r -1 -q -o njust_1.zip /home/cdl -x ~/*.zip<br>这里添加了一个参数用于设置压缩级别[1-9],1表示最快压缩但体积大，9表示体积最小但耗时最久。最后那个-x是为了排除上一次创建的zip文件，否则又会被打包进这一次的压缩文件中。这里只能使用绝对路径！！！</p>
<ul>
<li><p>再使用du命令分别查看默认压缩等级、最低和最高压缩级别及未压缩的文件的大小：</p>
   <figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">du</span> -h -d <span class="number">0</span> <span class="regexp">*.zip</span> | sort</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过man手册可知：</p>
<ul>
<li>-h：输入人类可以解释的信息</li>
<li>-d：所查看文件的深度</li>
</ul>
</li>
</ul>
</li>
<li>1.3 创建加密zip包(使用-e参数可以创建加密压缩包)<br>  zip -r -e -o njust_encryption.zip /home/cdl<ul>
<li>注意：关于zip命令，因为windows系统与Linux在文本文件格式上的兼容问题，比如换行符(为不可见字符)，在windows为回车加换行，Linux上为换行；所以如果不加处理的话，在Linux上编辑的文本文件，在windows系统上打开可能看起来是没有换行的。如果想让在Linux创建的zip压缩文件在Windows系统上解压后没有任何问题，那么还需要对命令进行修改：<br>  zip -r -l -o njust.zip /home/cdl   需要加上-l参数将换行转为回车加换行</li>
</ul>
</li>
</ul>
</li>
<li><p>2.使用unzip命令解压缩zip文件</p>
<ul>
<li>将njust.zip解压到当前目录下：<br>  unzip njust.zip</li>
<li>使用安静模式，将文件解压到指定目录，指定目录不存在，会自动创建：<br>  unzip -q njust.zip -d ziptest</li>
<li>如果不想解压只想查看压缩包的内容，可以使用-l参数：<br>  unzip -l njust.zip<br>  注意：使用unzip解压文件时同样应该注意兼容问题，不过这里此时关心的不再是上面的问题，而是中文编码的问题。通常windows系统上创建的压缩文件，如果有包含中文的文档或以中文作为文件名的文件时，默认会采用GBK或其他编码，而Linux上默认使用utf-8编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题(有时候它会帮你自动处理)。为了解决这个问题，可以在解压时指定编码类型。</li>
<li>使用-O(大写的字母O)参数指定编码类型： <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">unzip</span> <span class="selector-tag">-O</span> <span class="selector-tag">GBK</span> 中文压缩文件<span class="selector-class">.zip</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>3..rar文件打包压缩命令</p>
<ul>
<li>rar也是windows上常用的一种压缩文件的格式，在Linux上可以使用rar和unrar工具分别创建和解压rar压缩包</li>
<li>首先使用需要安装rar和unrar工具：<br>  sudo apt-get update<br>  sudo apt-get install rar unrar</li>
<li>在使用rar、unrar命令时，应该注意命令参数前不加-，否则会报错！<br>  rm *.zip<br>  rar a njust.rar<br>上面的命令使用a参数添加一个目录~到一个归档文件中，如果该文件不存在就会自动创建。</li>
<li>如果不解压只是查看文件，可以使用参数l：<br>  rar l njust.rar</li>
<li>全路径解压：<br>  unrar x njust.rar</li>
<li>去掉全路径解压：<br>  mkdir temp<br>  unrar e njust.rar temp/</li>
</ul>
</li>
<li>4..tar打包工具<ul>
<li>在Linux上面更常用的是tar工具，tar原本只是一个打包工具，只是同时还实现了对7z，gizp，xz，bzip2等工具的支持</li>
<li>创建一个tar包：<br>tar -cf njust.tar ~   (此命令会自动去掉表示绝对路径的/，也可以使用-P保留绝对路径符)</li>
<li>参数说明：</li>
<li>-c：创建一个tar包文件</li>
<li>-f：指定创建文件的名，注意文件名必须紧跟在-f参数后，不能写成tar -fc njust.tar!可以写成tar -f njust.tar -c ~</li>
<li>-v：以可视的方式输出打包的文件</li>
<li>解压一个文件(-x参数)到指定路径的已存在目录(-C参数)：<br>mkdir tardir<br>tar -xf njust.tar -C tardir</li>
<li>只查看不解压文件-t参数：<br>tar -tf njust.tar</li>
<li>对于创建不同压缩格式的文件时，对于tar来说是非常简单，需要的只是换一个参数，这里以使用gzip工具创建.tar.gz文件为例来说明。只需要在创建tar文件的基础上加一个-z参数，使用gzip来压缩文件：tar -czf njust.tar.gz ~</li>
<li>解压*.tar.gz文件到当前文件夹：<br>tar -xzf njust.tar.gz</li>
<li>现在要使用其他的压缩工具创建或解压相应文件时，只需要更改一个参数即可：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-34cfcf22721e7015.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tar解压命令.png"></li>
<li>此外，还有gzip和gunzip(相当于gzip -d)：压缩和解压命令，解压文件为.gz后缀</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow中的RNNCell基本单元使用</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow%E4%B8%AD%E7%9A%84RNNCell%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="0-charRNN基础介绍"><a href="#0-charRNN基础介绍" class="headerlink" title="0.charRNN基础介绍"></a>0.charRNN基础介绍</h3><ul>
<li>charRNN 是N vs N的循环神经网络，要求输入序列长度等于输出序列长度。<br>原理：用已经输入的字母去预测下一个字母的概率。一个句子是hello!,例如输入序列是hello,则输出序列是ello!<br>预测时：首先选择一个x1当作起始的字符，然后用训练好的模型得到下一个字符出现的概率。根据这个概率选择一个字符输出，然后将此字符当作下一步的x2输入到模型中。依次递推，得到任意长度的文字。<strong>注意：输入的单个字母是以one-hot形式进行编码的！</strong></li>
<li>对中文进行建模时，每一步输入模型的是一个汉字，由于汉字的种类太多，导致模型太大，一般采用下面的方法进行优化：<ul>
<li>1.取最常用的N个汉字，将剩下的汉字变成单独的一类，用一个\<unk\>字符来进行标注</unk\></li>
<li>2.在输入时，可以加入一个embedding层，将汉字的one-hot编码转为稠密的词嵌入表示。对单个字母不使用embedding是由于单个字母不具备任何的含义，只需要使用one-hot编码即可。单个汉字是具有一定的实际意义的，所以使用embedding层</li>
</ul>
</li>
</ul>
<h3 id="1-实现RNN的基本单元RNNCell抽象类————有两种直接使用的子类-BasicRNNCell-基本的RNN-和LSTMCell-基本的LSTM"><a href="#1-实现RNN的基本单元RNNCell抽象类————有两种直接使用的子类-BasicRNNCell-基本的RNN-和LSTMCell-基本的LSTM" class="headerlink" title="1.实现RNN的基本单元RNNCell抽象类————有两种直接使用的子类:BasicRNNCell(基本的RNN)和LSTMCell(基本的LSTM)"></a>1.实现RNN的基本单元RNNCell抽象类————有两种直接使用的子类:BasicRNNCell(基本的RNN)和LSTMCell(基本的LSTM)</h3><ul>
<li>RNNCell有三个属性:<ul>
<li>1.类方法call:所有的子类都会实现一个<strong>call</strong>函数，可以实现RNN的单步计算，调用形式：(output,next<em>state)=\</em>_call__(input, state)</li>
<li>2.类属性state<em>size:隐藏层的大小，输入数据是以batch_size的形式进行输入的即input=(batch_size, input_size),调用\</em>_call__函数时隐藏层的形状是(batch_size, state_size),输出层的形状是(batch_size, output_size)</li>
<li>3.类属性output_size:输出向量的大小</li>
</ul>
</li>
</ul>
<h3 id="2-定义一个基本的RNN单元"><a href="#2-定义一个基本的RNN单元" class="headerlink" title="2.定义一个基本的RNN单元"></a>2.定义一个基本的RNN单元</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">rnn_cell = tf<span class="selector-class">.nn</span><span class="selector-class">.rnn_cell</span><span class="selector-class">.BasicRNNCell</span>(num_units=<span class="number">128</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"rnn_cell.state_size:"</span>, rnn_cell.state_size)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="3-定义一个基本的LSTM的基本单元"><a href="#3-定义一个基本的LSTM的基本单元" class="headerlink" title="3.定义一个基本的LSTM的基本单元"></a>3.定义一个基本的LSTM的基本单元</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">lstm_cell = tf.nn.rnn_cell.LSTMCell(<span class="attribute">num_units</span>=128)</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"lstm_cell.state_size:"</span>, lstm_cell.state_size)</span><br><span class="line"></span><br><span class="line">lstm_cell = tf.nn.rnn_cell.LSTMCell(<span class="attribute">num_units</span>=128) # <span class="attribute">batch_size</span>=32, <span class="attribute">input_size</span>=100</span><br><span class="line">inputs = tf.placeholder(np.float32, shape=(32, 100))</span><br><span class="line">h0 = lstm_cell.zero_state(32, np.float32)  # 通过zero_state得到一个全0的初始状态</span><br><span class="line">output, h1 = lstm_cell.__call__(inputs, h0)</span><br><span class="line"><span class="builtin-name">print</span>(h1.c)</span><br><span class="line"><span class="builtin-name">print</span>(h1.h)</span><br></pre></td></tr></table></figure>
<h3 id="4-对RNN进行堆叠：MultiRNNCell"><a href="#4-对RNN进行堆叠：MultiRNNCell" class="headerlink" title="4.对RNN进行堆叠：MultiRNNCell"></a>4.对RNN进行堆叠：MultiRNNCell</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每次调用这个函数返回一个BasicRNNCell</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_a_cell</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.rnn_cell.BasicRNNCell(num_units=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用MultiRNNCell创建3层RNN</span></span><br><span class="line">cell = tf.nn.rnn_cell.MultiRNNCell([get_a_cell() <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)])</span><br><span class="line"><span class="comment"># 得到的RNN也是RNNCell的子类,state_size=(128, 128, 128):三个隐层状态，每个隐层状态的大小是128</span></span><br><span class="line">print(cell.state_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32是batch_size, 100是input_size</span></span><br><span class="line">inputs = tf.placeholder(np.float32, shape=(<span class="number">32</span>, <span class="number">100</span>))</span><br><span class="line">h0 = cell.zero_state(<span class="number">32</span>, np.float32)</span><br><span class="line">output, h1 = cell.__call__(inputs, h0)</span><br><span class="line">print(h1)</span><br></pre></td></tr></table></figure>
<h3 id="5-使用tf-nn-dunamic-rnn按时间展开：相当于增加了一个时间维度time-steps-通过-h0-x1-x2…-xn-得到-h1-h2-h3-…hn"><a href="#5-使用tf-nn-dunamic-rnn按时间展开：相当于增加了一个时间维度time-steps-通过-h0-x1-x2…-xn-得到-h1-h2-h3-…hn" class="headerlink" title="5.使用tf.nn.dunamic_rnn按时间展开：相当于增加了一个时间维度time_steps,通过{h0,x1,x2…,xn}得到{h1,h2,h3,…hn}"></a>5.使用tf.nn.dunamic_rnn按时间展开：相当于增加了一个时间维度time_steps,通过{h0,x1,x2…,xn}得到{h1,h2,h3,…hn}</h3><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">inputs: shape=(batch_size, time_steps, input_size)  <span class="comment"># 输入数据的格式是(batch_size, time_steps, input_size)</span></span><br><span class="line">initial_state:  shape(batch_size,cell.state_size)  <span class="comment"># 初始状态,一般可以取零矩阵</span></span><br><span class="line">outputs, <span class="keyword">state</span> = tf.nn.dynamic_rnn(cell,inputs,initial_state)</span><br><span class="line"><span class="comment"># outputs是time_steps中所有的输出，形状是(batch_size, time_steps, cell.output_size)</span></span><br><span class="line"><span class="comment"># state是最后一步的隐状态，形状是(batch_size,cell.state_size)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>注意：输入数据的形状是(time_steps,batch_size, input_size),可以调用tf.nn.dynamic_rnn()函数中设定参数time_major=True。此时，得到的outputs的形状是(time_steps, batch_size, cell.output_size);state的形状不变化</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas中iloc、loc、ix三者的区别</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/Pandas%E4%B8%ADiloc%E3%80%81loc%E3%80%81ix%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="一、综述：iloc、loc、ix可以用来索引数据、抽取数据"><a href="#一、综述：iloc、loc、ix可以用来索引数据、抽取数据" class="headerlink" title="一、综述：iloc、loc、ix可以用来索引数据、抽取数据"></a>一、综述：iloc、loc、ix可以用来索引数据、抽取数据</h3><h3 id="二、iloc、loc、ix三者对比"><a href="#二、iloc、loc、ix三者对比" class="headerlink" title="二、iloc、loc、ix三者对比"></a>二、iloc、loc、ix三者对比</h3><ul>
<li><ol>
<li>iloc和loc的区别</li>
</ol>
<ul>
<li>iloc主要使用数字来索引数据，不能使用字符型的标签来索引数据。</li>
<li>loc只能使用字符型标签来索引数据，不能使用数字来索引数据。特殊情况：当dataframe的行标签或列标签为数字时，loc就可以来索引</li>
</ul>
</li>
<li><ol>
<li>行标签和列标签都是数字的情况<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(<span class="string">"a: \n"</span>, a)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(a)</span><br><span class="line">print(<span class="string">"df: \n"</span>, df)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"df.loc[0]: \n"</span>, df.loc[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">"df.iloc[0]: \n"</span>, df.iloc[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"df.loc[:,[0,3]]: \n"</span>, df.loc[:, [<span class="number">0</span>, <span class="number">3</span>]])</span><br><span class="line">print(<span class="string">"df.iloc[:, [0,3]]: \n"</span>, df.iloc[:, [<span class="number">0</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><ol>
<li>将行标签[0, 1, 2]改为[‘a’,’b’,’c’]时的情况</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.index = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">print(<span class="string">"df: \n"</span>, df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(df.loc[0])  报错！TypeError: cannot do label indexing on &lt;class 'pandas.core.indexes.base.Index'&gt; with these indexers [0] of &lt;class 'int'&gt;</span></span><br><span class="line">print(<span class="string">"df.iloc[0]: \n"</span>, df.iloc[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"df.loc['a']: \n"</span>, df.loc[<span class="string">'a'</span>])</span><br><span class="line"><span class="comment"># print("df.iloc['a']: \n", df.iloc['a']) 报错！</span></span><br></pre></td></tr></table></figure>
<ul>
<li><ol>
<li>将列标签[0, 1, 2]改为[‘A’, ‘B’, ‘C’]时的情况</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.columns = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line">print(<span class="string">"df: \n"</span>, df)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"df.loc[:, 'A']: \n"</span>, df.loc[:, <span class="string">'A'</span>])</span><br><span class="line"><span class="comment"># print("df.iloc[:, 'A']: \n", df.iloc[:, 'A'])  报错！</span></span><br></pre></td></tr></table></figure>
<ul>
<li><ol>
<li>ix是一种混合索引，字符型标签和整型索引都可以使用<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"df.ix[0]: \n"</span>, df.ix[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">"df.ix['a']: \n"</span>, df.ix[<span class="string">'a'</span>])</span><br><span class="line">print(<span class="string">"df.ix[:, 0]: \n"</span>, df.ix[:, <span class="number">0</span>])</span><br><span class="line">print(<span class="string">"df.ix[:, 'A']: \n"</span>, df.ix[:, <span class="string">'A'</span>])</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="三、参考博客"><a href="#三、参考博客" class="headerlink" title="三、参考博客"></a>三、参考博客</h3><p><a href="https://blog.csdn.net/niuniuyuh/article/details/76650904" target="_blank" rel="noopener">CSDN博客链接</a></p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>Python3</tag>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基础知识点总结</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="0-互联网的组成"><a href="#0-互联网的组成" class="headerlink" title="0.互联网的组成"></a>0.互联网的组成</h3><ul>
<li>边缘部分：所有连接在互联网上的主机（主机指的是所有与网络直接相连的计算机）组成，用户可以直接使用，用来进行主机之间的通信和资源共享。</li>
<li>核心部分：大量的网络与连接这些网络所使用的路由器构成，为边缘部分提供服务。</li>
<li>边缘部分总结<ul>
<li>边缘部分主要使用核心部分所提供的服务，使得许多主机之间能够互相通信并进行交换或共享信息。计算机之间的通信指的是主机A上的一个进程与主机B上的另一个进程之间进行通信。通信的方式主要有两种：<ul>
<li>客户-服务器方式：即C /S方式。客户端发送服务的请求，服务器是服务的提供方。</li>
<li>P2P：对等连接方式。两台通信的主机之间不区分哪个是客户，哪个是服务端，只要两台主机都运行了对等连接软件就可以进行平等、对等的连接通信。</li>
</ul>
</li>
</ul>
</li>
<li>核心部分总结<ul>
<li>核心部分起到特殊作用的是路由器，它是一个专用的计算机，主要作用是<strong>分组交换和存储转发</strong>的功能。<ul>
<li>电路交换：使用在电话机之间的通信，使用电话交换机解决了多个电话机之间通信需要大量的电线的问题。电路交换的过程是：<strong>建立连接(开始占用通信资源)—-通话(一直占用通信资源)——释放连接(归还通信资源)</strong>。电路交换的特点是：通话期间，通话的两个用户会始终占用通信资源。使用电路交换传输计算机数据时，传输效率往往会很低。因为计算机数据具有突变式的特点，线路上真正用来传输数据的时间往往不到10%,大部分通信线路资源绝大部分时间都被浪费了。<strong>整个报文的比特流连续的从源点直达终点</strong></li>
<li>分组交换：采用<strong>存储转发的技术</strong>，把一个报文（需要发生出去的整块数据）划分成几组分组后再进行传输。将报文划分成更小的等长数据段，然后加上首部(包含一些控制信息)，构成了一个分组，分组的首部称为一个包头。<strong>单个分组（只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</strong></li>
<li>报文交换：<strong>整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</strong></li>
<li>路由器的工作流程：路由器接收到一个分组后，暂存数据到路由器自己的缓存中即自身的存储器中，然后检查其首部，查找转发表。按照首部中的目的地址，找到合适的接口转发除去，把分组交给下一个路由器。这样一步一步以存储转发的方式，把分组交给最终的目的主机。<strong>路由器只是暂存一个分组，不是整个报文。分组在哪段链路上传送时才会占用此段链路上的通信资源，在各分组传输之间的空闲时间，此链路也是可以被其他主机发送的分组使用。</strong><h4 id="计算机网络中的常见硬件设备介绍："><a href="#计算机网络中的常见硬件设备介绍：" class="headerlink" title="计算机网络中的常见硬件设备介绍："></a>计算机网络中的常见硬件设备介绍：</h4></li>
</ul>
</li>
</ul>
</li>
<li>物理层：实现网络互连的主要设备有<strong>中继器和HUB(集线器)</strong>。中继器的主要功能是对接收到的信号进行再生整形放大以扩大网络的传输距离；集线器在此基础上将所有的节点集中在以它为中心的节点中，可组成星型拓扑结构。</li>
<li>数据链路层：实现网络互联的主要设备有<strong>二层交换机和网桥</strong>。交换机是一种基于MAC识别，能完成封装转发数据包功能的网络设备。它可以“学习”MAC地址，并把其存放在内部地址表中，当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口。  交换机将局域网分为多个冲突域，每个冲突域都是有独立的宽带，因此大大提高了局域网的带宽。网桥是数据链路层互联的设备，在网络互联中可起到数据接收、地址过滤与数据转发的作用，可用来实现多个不同网络系统之间的数据交换。</li>
<li>网络层：实现网络互连的主要设备有<strong>三层交换机和路由器</strong>。路由器用于连接多个逻辑上分开的网络，具有判断网络地址和选择IP路径的功能，它能在多网络互联环境中，建立灵活的连接，可用完全不同的数据分组和介质访问方法连接各种子网。</li>
<li>传输层（包括传输层）以上：实现网络互连的设备有<strong>网关</strong>。网关在网络层以上实现网络互连，用于两个高层协议不同的网络互连。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</li>
</ul>
<h3 id="1-计算机网络体系结构"><a href="#1-计算机网络体系结构" class="headerlink" title="1.计算机网络体系结构"></a>1.计算机网络体系结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/13407176-7fe56a6a91c93d29?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机网络体系结构"></p>
<ul>
<li><strong>应用层</strong>：应用层是体系结构中的最高层。应用层直接为用户的应用进程程序提供服务。这里的进程就是指正在运行的程序。在因特网中的应用层协议很多，如支持万维网应用的http协议支持电子邮件的SMTP协议，支持文件传送的FTP协议等。</li>
<li><strong>运输层</strong>：运输层的任务就是负责向两个主机中进程之间的通信提供服务。由于一个主机可以同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可以同时使用下面运输层的服务，分用就是运输层把收到的信息分别交付给上面应用层中的相应进程。<ul>
<li>运输层主要使用下面两个协议：<ul>
<li>传输控制协议TCP：面向连接的，数据传输的基本单位是报文段，能够提供可靠的交付</li>
<li>用户数据包协议UDP：无连接的，数据传输的基本单位是用户数据报，不能保证提供可靠的交付，只能提供<strong>尽最大努力交付</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>网络层</strong>：  负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫作IP数据报。</li>
<li><strong>数据链路层</strong>：两个主机之间的数据传输，总是在一段一段的链路上传送的。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上透明地传送帧中的数据，每一帧包括数据和必要的控制信息。</li>
<li><strong>物理层</strong>：在物理层上传送的数据单位是比特。物理层的任务就是透明地传送比特流。</li>
</ul>
<h3 id="2-各层的作用和支持的协议"><a href="#2-各层的作用和支持的协议" class="headerlink" title="2.各层的作用和支持的协议"></a>2.各层的作用和支持的协议</h3><p><img src="https://upload-images.jianshu.io/upload_images/13407176-8576f94e43f01841?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="各层的作用和支持的协议"></p>
<h3 id="3-物理层"><a href="#3-物理层" class="headerlink" title="3.物理层"></a>3.物理层</h3><ul>
<li>传输数据的基本单位：比特流0和1</li>
<li>数据传输系统：源系统（源点、发送器） —&gt; 传输系统 —&gt; 目的系统（接收器、终点）</li>
<li>通道：<ul>
<li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li>
<li>双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li>
<li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li>
</ul>
</li>
<li>通道复用技术：<ul>
<li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li>
<li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li>
<li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li>
<li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li>
</ul>
</li>
</ul>
<h3 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4.数据链路层"></a>4.数据链路层</h3><ul>
<li>主要信道：<ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
</li>
<li>点对点信道：<ul>
<li>数据单元：帧</li>
<li>三个基本问题：<ul>
<li>封装成帧：把网络层的 IP 数据报封装成帧，SOH - 数据部分 - EOT</li>
<li>透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）</li>
<li>差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）</li>
</ul>
</li>
<li>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</li>
</ul>
</li>
<li>广播信道：<ul>
<li>硬件地址（物理地址、MAC 地址）</li>
<li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li>
<li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li>
<li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li>
</ul>
</li>
</ul>
<h3 id="5-网络层"><a href="#5-网络层" class="headerlink" title="5.网络层"></a>5.网络层</h3><ul>
<li>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</li>
<li>ARP（Address Resolution Protocol，地址解析协议）</li>
<li>ICMP（Internet Control Message Protocol，网际控制报文协议）</li>
<li>IGMP（Internet Group Management Protocol，网际组管理协议）</li>
</ul>
<h4 id="5-1-IP网际协议"><a href="#5-1-IP网际协议" class="headerlink" title="5.1 IP网际协议"></a>5.1 IP网际协议</h4><ul>
<li>IP地址<strong>({&lt;网络号&gt;,&lt;主机号&gt;})</strong>分类：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-d17fd5c720d09ac7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP地址分类"></li>
<li>IP数据报格式：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-6c51c50ec528c7e5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP数据报格式"></li>
</ul>
<h4 id="5-2-ICMP网际控制报文协议"><a href="#5-2-ICMP网际控制报文协议" class="headerlink" title="5.2 ICMP网际控制报文协议"></a>5.2 ICMP网际控制报文协议</h4><ul>
<li>ICMP报文格式：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-6b5180a4aef64d5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" ICMP报文格式"></li>
<li>应用：<ul>
<li>PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性</li>
<li>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</li>
</ul>
</li>
</ul>
<h4 id="5-3-内部网关协议"><a href="#5-3-内部网关协议" class="headerlink" title="5.3 内部网关协议"></a>5.3 内部网关协议</h4><ul>
<li>RIP（Routing Information Protocol，路由信息协议）</li>
<li>OSPF（Open Sortest Path First，开放最短路径优先）</li>
</ul>
<h4 id="5-4-外部网关协议"><a href="#5-4-外部网关协议" class="headerlink" title="5.4 外部网关协议"></a>5.4 外部网关协议</h4><ul>
<li>BGP（Border Gateway Protocol，边界网关协议）</li>
</ul>
<h4 id="5-5-IP多播"><a href="#5-5-IP多播" class="headerlink" title="5.5 IP多播"></a>5.5 IP多播</h4><ul>
<li>IGMP（Internet Group Management Protocol，网际组管理协议）</li>
<li>多播路由选择协议</li>
</ul>
<h4 id="5-6-VPN和NAT"><a href="#5-6-VPN和NAT" class="headerlink" title="5.6 VPN和NAT"></a>5.6 VPN和NAT</h4><ul>
<li>VPN（Virtual Private Network，虚拟专用网）</li>
<li>NAT（Network Address Translation，网络地址转换）</li>
</ul>
<h4 id="5-7-路由表包含什么？"><a href="#5-7-路由表包含什么？" class="headerlink" title="5.7 路由表包含什么？"></a>5.7 路由表包含什么？</h4><ul>
<li>网络 ID（Network ID, Network number）：就是目标地址的网络 ID。</li>
<li>子网掩码（subnet mask）：用来判断 IP 所属哪个子网络</li>
<li>下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: 0.0.0.0, Netmask: 0.0.0.0）指向自治系统的出口。</li>
<li>根据应用和执行的不同，路由表可能含有如下附加信息：<ul>
<li>花费（Cost）：就是数据发送过程中通过路径所需要的花费</li>
<li>路由的服务质量</li>
<li>路由中需要过滤的出/入连接列表</li>
</ul>
</li>
</ul>
<h3 id="6-传输层"><a href="#6-传输层" class="headerlink" title="6.传输层"></a>6.传输层</h3><ul>
<li>支持的协议：<ul>
<li>TCP（Transmission Control Protocol，传输控制协议）</li>
<li>UDP（User Datagram Protocol，用户数据报协议）</li>
</ul>
</li>
<li>端口号：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-5c31b958235daae0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="端口号"></li>
</ul>
<h4 id="6-1-TCP（Transmission-Control-Protocol，传输控制协议）"><a href="#6-1-TCP（Transmission-Control-Protocol，传输控制协议）" class="headerlink" title="6.1 TCP（Transmission Control Protocol，传输控制协议）"></a>6.1 TCP（Transmission Control Protocol，传输控制协议）</h4><ul>
<li>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。</li>
<li>特征：<ul>
<li>面向连接</li>
<li>只能点对点（一对一）通信</li>
<li>可靠交互</li>
<li>全双工通信</li>
<li>面向字节流</li>
</ul>
</li>
<li>TCP如何保证可靠传输？<ul>
<li>确认和超时重传</li>
<li>数据合理分片和排序</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>数据校验</li>
</ul>
</li>
<li>TCP报文结构<br><img src="https://upload-images.jianshu.io/upload_images/13407176-b75609962acd02c7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP报文结构"></li>
<li>TCP首部<br><img src="https://upload-images.jianshu.io/upload_images/13407176-00e1f7be59ced0c3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP首部"></li>
<li>TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：<ul>
<li>URG：紧急比特（urgent），当 URG＝1 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。</li>
<li>ACK：确认比特（Acknowledge）。只有当 ACK＝1 时确认号字段才有效，代表这个封包为确认封包。当 ACK＝0 时，确认号无效。</li>
<li>PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。</li>
<li>RST：复位比特(Reset)，当 RST＝1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li>
<li>SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。</li>
<li>FIN：终止比特(Final)，用来释放一个连接。当 FIN＝1 时，表明此报文段的发送端的数据已发送完毕，并要求释放传输连接。</li>
</ul>
</li>
</ul>
<h4 id="6-2-UDP（User-Datagram-Protocol，用户数据报协议）"><a href="#6-2-UDP（User-Datagram-Protocol，用户数据报协议）" class="headerlink" title="6. 2 UDP（User Datagram Protocol，用户数据报协议）"></a>6. 2 UDP（User Datagram Protocol，用户数据报协议）</h4><ul>
<li>UDP是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。</li>
<li>特征：<ul>
<li>无连接</li>
<li>尽最大努力交付</li>
<li>面向报文</li>
<li>没有拥塞控制</li>
<li>支持一对一、一对多、多对多的交互通信</li>
<li>首部开销小</li>
</ul>
</li>
<li>UDP报文结构<br><img src="https://upload-images.jianshu.io/upload_images/13407176-34146b4de4078b50?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP报文结构"></li>
<li>UDP首部<br><img src="https://upload-images.jianshu.io/upload_images/13407176-2aee214a6316bad1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP首部"></li>
</ul>
<h4 id="6-3-TCP与UDP的区别"><a href="#6-3-TCP与UDP的区别" class="headerlink" title="6.3 TCP与UDP的区别"></a>6.3 TCP与UDP的区别</h4><ul>
<li>TCP面向连接、UDP是无连接的；</li>
<li>TCP提供可靠的服务、也就是说，通过TCP连接传输的数据是无差错、不丢失、不重复且按序到达；UDP尽最大努力交付，即不保证可靠交付</li>
<li>TCP的逻辑通信信息是全双工的可靠信息；UDP则是不可靠信息</li>
<li>每一条TCP连接只能是点对点的；UDP支持一对多、多对一、多对多的交互通信</li>
<li>TCP面向字节流(可能会出现黏包问题)，实际上是TCP白数据看成一连串无结构的字节流；UDP是面向报文的(不会出现黏包问题)</li>
<li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如IP电话，实时视频会议等)</li>
<li>TCP首部开销20字节；UDP的首部开销小，只有8字节</li>
</ul>
<h4 id="6-4-TCP的黏包问题"><a href="#6-4-TCP的黏包问题" class="headerlink" title="6.4 TCP的黏包问题"></a>6.4 TCP的黏包问题</h4><ul>
<li>出现黏包问题的原因：TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的，所以可能会出现两个数据包黏在一起的情况。</li>
<li>解决方法：<ul>
<li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li>
<li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li>
<li>在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。</li>
<li>使用更加复杂的应用层协议<h4 id="6-5-TCP流量控制"><a href="#6-5-TCP流量控制" class="headerlink" title="6.5 TCP流量控制"></a>6.5 TCP流量控制</h4></li>
</ul>
</li>
<li>概念：流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。</li>
<li>方法：利用可变窗口进行流量控制<br><img src="https://upload-images.jianshu.io/upload_images/13407176-89d12260a132081f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流量控制"></li>
</ul>
<h4 id="6-6-TCP拥塞控制"><a href="#6-6-TCP拥塞控制" class="headerlink" title="6.6 TCP拥塞控制"></a>6.6 TCP拥塞控制</h4><ul>
<li>概念：拥塞控制就是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载。</li>
<li>解决方法：<ul>
<li>慢启动( slow-start )</li>
<li>拥塞避免( congestion avoidance )</li>
<li>快重传( fast retransmit )</li>
<li>快恢复( fast recovery )<br><img src="https://upload-images.jianshu.io/upload_images/13407176-163d146352f644df?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP拥塞窗口cwnd在拥塞控制时的变化情况"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-712bcfb5f81b82b0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP的拥塞控制流程图"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-9c1c63e1f94a6aff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="快重传"></li>
</ul>
</li>
</ul>
<h4 id="6-7-TCP传输连接管理-重点"><a href="#6-7-TCP传输连接管理-重点" class="headerlink" title="6.7 TCP传输连接管理(重点)"></a><strong>6.7 TCP传输连接管理(重点)</strong></h4><ul>
<li>一.TCP建立连接：三次握手<br><img src="https://upload-images.jianshu.io/upload_images/13407176-2c267347f110bf71?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP三次握手建立连接"></li>
<li>TCP 建立连接全过程解释：<ul>
<li>1.客户端发生SYN给服务器，表示客户端向服务器请求建立连接；</li>
<li>2.服务端收到客户端的SYN，并回复SYN+ACK给客户端(同意建立连接)；</li>
<li>3.客户端收到来自服务器的SYN+ACK后，回复ACK给服务端(表示客户端收到了服务端发的同意报文)；</li>
<li>4.服务端收到客户端的ACK，连接已建立，可以进行数据传输。</li>
</ul>
</li>
<li>建立连接的详细过程：<ul>
<li>a.B的TCP服务器进程首先创建传输控制块TCB,准备接受客户进程的连接请求。然后服务器进程就处于LISTEN(收听)状态，等待客户的连接请求。如有，就做出响应。</li>
<li>b.A的TCP客户进程也是首先创建传输控制模块TCB，然后向B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文段(即SYN=1的报文段)不能携带数据，但是要消耗一个序号。这时，TCP客户进程进入SYN-SENT(同步已发送)状态。</li>
<li>c.B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN和ACK位都置1，确认号是ack=x+1,同时也为自己选择一个初始序号seq=y。注意：<strong>这个报文段也不能携带数据，但同样要消耗一个序号</strong>。这时TCP服务器进程进入SYN-RECV(同步收到)状态。</li>
<li>d.TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。<strong>TCP标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号</strong>。在这种情况下，下一个数据报文段的序号仍然是seq=x+1。这时，TCP的连接已经建立，A进入ESTABLISHED(已建立连接)状态。当B接收到A的确认后，B也进入ESTABLISHED(已建立连接)状态。</li>
</ul>
</li>
<li>Q1：TCP为什么要进行三次握手？<ul>
<li>因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。(而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手)</li>
<li>因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信</li>
<li>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</li>
</ul>
</li>
<li>二.TCP断开连接：四次挥手<br><img src="https://upload-images.jianshu.io/upload_images/13407176-7c3eb002a1527b14?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP四次挥手释放连接"><ul>
<li>TCP 断开连接全过程解释：<ul>
<li>1.客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；</li>
<li>2.服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；</li>
<li>3.客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；</li>
<li>4.服务端继续发送之前没发完的数据给客户端；</li>
<li>5.服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；</li>
<li>6.服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；</li>
<li>7.服务端收到客户端的 ACK 后，断开从服务端到客户端的连接</li>
</ul>
</li>
<li>释放连接的详细过程：<ul>
<li>a.A和B都处于ESTABLISHED状态，A的应用进程首先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的FIN置1，其序列号seq=u，它等于前面已经传送过的数据的最后一个字节的序号加1。这时，A进入FIN-WAIT-1(终止等待1)状态，等待B的确认。<strong>注意：TCP规定：FIN报文段即使不携带数据，它也会消耗一个序号。</strong></li>
<li>b.B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等待B前面已经传送过的数据的最后一个字节的序号加1。然后B就进入CLOSE-WAIT(关闭等待)状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并没有关闭，这个连接可能会持续一段时间。</li>
<li>c.A收到来自B的确认后，就进入FIN-WAIT-2(终止等待2)状态，等待B发出的连接释放报文段。如果B已经没有要向A发送的数据，其应用进程就会通知TCP释放连接。这时B发出的连接释放报文段必须使FIN=1。现假定B的序号为w(在半关闭状态B可能又发送了一些数据)。B还必须重复上次已经发送过的确认号ack=u+1。这时，B就进入LAST-ACK(最后确认状态)，等待A的确认。</li>
<li>d.A在收到B的释放连接报文段后，必须对此发出一个确认。在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1(根据TCP标准，前面发送过的FIN报文段要消耗一个序号)。然后经过时间等待计时器(TIME-WAIT)设置的时间2MSL后，A才进入到CLOSED状态。时间MSL叫做最长报文段寿命</li>
</ul>
</li>
<li>Q2：TCP 为什么要进行四次挥手？<ul>
<li>因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</li>
</ul>
</li>
<li>Q3：为什么 TCP 建立连接时可以 ACK 和 SYN 一起发送，而断开连接时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）<ul>
<li>因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。</li>
</ul>
</li>
<li>Q4：为什么客户端断开连接时，最后需要 TIME-WAIT 等待 2MSL 呢？<ul>
<li>1.为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li>
<li>2.防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。<h4 id="6-8-TCP有限状态机"><a href="#6-8-TCP有限状态机" class="headerlink" title="6.8 TCP有限状态机"></a>6.8 TCP有限状态机</h4><img src="https://upload-images.jianshu.io/upload_images/13407176-9997deb1e8e31655?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP的有限状态机"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7.应用层"></a>7.应用层</h3><h4 id="7-1-DNS-Domain-Name-System，域名系统"><a href="#7-1-DNS-Domain-Name-System，域名系统" class="headerlink" title="7.1 DNS(Domain Name System，域名系统)"></a>7.1 DNS(Domain Name System，域名系统)</h4><ul>
<li>DNS是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。<ul>
<li>域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}，如：blog.huihut.com</li>
</ul>
</li>
</ul>
<h4 id="7-2-FTP-File-Transfer-Protocol，文件传输协议"><a href="#7-2-FTP-File-Transfer-Protocol，文件传输协议" class="headerlink" title="7.2 FTP(File Transfer Protocol，文件传输协议)"></a>7.2 FTP(File Transfer Protocol，文件传输协议)</h4><ul>
<li>FTP是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</li>
<li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</li>
</ul>
<h4 id="7-3-TELNET"><a href="#7-3-TELNET" class="headerlink" title="7.3 TELNET"></a>7.3 TELNET</h4><ul>
<li>TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</li>
</ul>
<h4 id="7-4-HTTP（HyperText-Transfer-Protocol，超文本传输协议）"><a href="#7-4-HTTP（HyperText-Transfer-Protocol，超文本传输协议）" class="headerlink" title="7.4 HTTP（HyperText Transfer Protocol，超文本传输协议）"></a>7.4 HTTP（HyperText Transfer Protocol，超文本传输协议）</h4><ul>
<li>HTTP是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。</li>
</ul>
<h4 id="7-5-SMTP（Simple-Mail-Transfer-Protocol，简单邮件传输协议）"><a href="#7-5-SMTP（Simple-Mail-Transfer-Protocol，简单邮件传输协议）" class="headerlink" title="7.5 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）"></a>7.5 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</h4><ul>
<li>SMTP是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。它是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器，SMTP 使用 TCP 端口 25。</li>
</ul>
<h4 id="7-6-DHCP（Dynamic-Host-Configuration-Protocol，动态主机设置协议）"><a href="#7-6-DHCP（Dynamic-Host-Configuration-Protocol，动态主机设置协议）" class="headerlink" title="7.6 DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）"></a>7.6 DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）</h4><ul>
<li>DHCP是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：<ul>
<li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li>
<li>用于内部网络管理员作为对所有电脑作中央管理的手段</li>
</ul>
</li>
</ul>
<h4 id="7-7-SNMP（Simple-Network-Management-Protocol，简单网络管理协议）"><a href="#7-7-SNMP（Simple-Network-Management-Protocol，简单网络管理协议）" class="headerlink" title="7.7 SNMP（Simple Network Management Protocol，简单网络管理协议）"></a>7.7 SNMP（Simple Network Management Protocol，简单网络管理协议）</h4><ul>
<li>SNMP构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</li>
</ul>
<h3 id="8-相关概念"><a href="#8-相关概念" class="headerlink" title="8.相关概念"></a>8.相关概念</h3><h4 id="8-1-Socket（套接字）"><a href="#8-1-Socket（套接字）" class="headerlink" title="8.1 Socket（套接字）"></a>8.1 Socket（套接字）</h4><ul>
<li>Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。</li>
</ul>
<h4 id="8-2-WWW（World-Wide-Web，环球信息网，万维网）"><a href="#8-2-WWW（World-Wide-Web，环球信息网，万维网）" class="headerlink" title="8.2 WWW（World Wide Web，环球信息网，万维网）"></a>8.2 WWW（World Wide Web，环球信息网，万维网）</h4><ul>
<li>WWW是一个由许多互相链接的超文本组成的系统，通过互联网访问<h4 id="8-3-URL（Uniform-Resource-Locator，统一资源定位符）"><a href="#8-3-URL（Uniform-Resource-Locator，统一资源定位符）" class="headerlink" title="8.3 URL（Uniform Resource Locator，统一资源定位符）"></a>8.3 URL（Uniform Resource Locator，统一资源定位符）</h4></li>
<li>概念：URL是因特网上标准的资源的地址（Address）</li>
<li>标准格式：协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</li>
<li>完整格式：协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]  注意：其中[访问凭证信息@；:端口号；?查询；#片段ID]都属于选填项,可以省略，如：<a href="https://github.com/cdlwhm1217096231" target="_blank" rel="noopener">https://github.com/cdlwhm1217096231</a></li>
</ul>
<h3 id="9-HTTP详解"><a href="#9-HTTP详解" class="headerlink" title="9.HTTP详解"></a>9.HTTP详解</h3><ul>
<li>概念：HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</li>
<li>请求方法：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-96c25506dffe9b6f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求方法"></li>
<li>状态码：<ul>
<li>1xx：表示通知信息，如请求收到了或正在进行处理<ul>
<li>100 Continue：继续，客户端应继续其请求</li>
<li>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li>
</ul>
</li>
<li>2xx：表示成功，如接收或知道了<ul>
<li>200 OK: 请求成功</li>
</ul>
</li>
<li>3xx：表示重定向，如要完成请求还必须采取进一步的行动<ul>
<li>301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替</li>
</ul>
</li>
<li>4xx：表示客户的差错，如请求中有错误的语法或不能完成<ul>
<li>400 Bad Request: 客户端请求的语法错误，服务器无法理解</li>
<li>401 Unauthorized: 请求要求用户的身份认证</li>
<li>403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）</li>
<li>404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面</li>
<li>408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时</li>
</ul>
</li>
<li>5xx：表示服务器的差错，如服务器失效无法完成请求<ul>
<li>500 Internal Server Error: 服务器内部错误，无法完成请求</li>
<li>503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</li>
<li>504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="10-DNS-域名解析协议"><a href="#10-DNS-域名解析协议" class="headerlink" title="10.DNS(域名解析协议)"></a>10.DNS(域名解析协议)</h3><ul>
<li>域名的来由：我们可以通过IP地址去访问网站，但是对大多数用户来说，访问每个网站都需要记住一串数字是不现实的，所以用户可以通过域名来访问网站。域名，其实是具有一定含义的字符组合。<strong>域名系统是因特网上作为域名和IP地址相互映射的一个分布式数据库，能让用户更方便使用互联网</strong>。</li>
<li>DNS劫持：指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。范例：收到各种推送广告等网站</li>
<li>DNS污染：指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。比如不能访问Google、YouTube等。</li>
<li>域名表达式为，在地址表达式中，最右边的是最高层次的域名，最左边的是主机名，域与域之间用圆点隔开；</li>
<li>域名解析：通过主机最终得到该主机名对应的IP地址；</li>
</ul>
<h3 id="11-Http协议格式"><a href="#11-Http协议格式" class="headerlink" title="11.Http协议格式"></a>11.Http协议格式</h3><ul>
<li>HTTP请求报文与响应报文格式<ul>
<li>请求报文包含三部分：<ul>
<li>请求行：包含请求方法、URI、HTTP版本信息</li>
<li>请求首部字段</li>
<li>请求内容实体</li>
</ul>
</li>
<li>响应报文包含三部分：<ul>
<li>状态行：包含HTTP版本、状态码、状态码的原因短语</li>
<li>响应首部字段</li>
<li>响应内容实体</li>
</ul>
</li>
</ul>
</li>
<li>HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。</li>
<li>常用的HTTP方法有哪些？<ul>
<li>GET：用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。</li>
<li>POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。</li>
<li>PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置。</li>
<li>HEAD：获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。</li>
<li>DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。</li>
<li>OPTIONS：查询相应URI支持的HTTP方法。</li>
</ul>
</li>
<li>GET方法与POST方法的区别<ul>
<li>get重点在从服务器上获取资源，post重点在向服务器发送数据；</li>
<li>get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如<a href="http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；" target="_blank" rel="noopener">http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；</a></li>
<li>get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式；</li>
<li>get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；post较get安全性较高；</li>
<li>get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。post支持标准字符集，可以正确传递中文字符。</li>
</ul>
</li>
<li>HTTP1.1版本新特性<ul>
<li>默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求</li>
<li>管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应</li>
<li>断点续传原理</li>
</ul>
</li>
<li>常见HTTP首部字段<ul>
<li>通用首部字段（请求报文与响应报文都会使用的首部字段）<ul>
<li>Date：创建报文时间</li>
<li>Connection：连接的管理</li>
<li>Cache-Control：缓存的控制</li>
<li>Transfer-Encoding：报文主体的传输编码方式</li>
</ul>
</li>
<li>请求首部字段（请求报文会使用的首部字段）<ul>
<li>Host：请求资源所在服务器</li>
<li>Accept：可处理的媒体类型</li>
<li>Accept-Charset：可接收的字符集</li>
<li>Accept-Encoding：可接受的内容编码</li>
<li>Accept-Language：可接受的自然语言</li>
</ul>
</li>
<li>响应首部字段（响应报文会使用的首部字段）<ul>
<li>Accept-Ranges：可接受的字节范围</li>
<li>Location：令客户端重新定向到的</li>
<li>URI Server：HTTP服务器的安装信息</li>
</ul>
</li>
<li>实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）<ul>
<li>Allow：资源可支持的HTTP方法</li>
<li>Content-Type：实体主类的类型</li>
<li>Content-Encoding：实体主体适用的编码方式</li>
<li>Content-Language：实体主体的自然语言</li>
<li>Content-Length：实体主体的的字节数</li>
<li>Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</li>
</ul>
</li>
</ul>
</li>
<li>HTTP的缺点与HTTPS<ul>
<li>通信使用明文不加密，内容可能被窃听</li>
<li>不验证通信方身份，可能遭到伪装</li>
<li>无法验证报文完整性，可能被篡改</li>
<li>HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护</li>
</ul>
</li>
</ul>
<h3 id="12-当你输入一个网址-点击一个链接，发生了什么？（以www-baidu-com为例）"><a href="#12-当你输入一个网址-点击一个链接，发生了什么？（以www-baidu-com为例）" class="headerlink" title="12.当你输入一个网址/点击一个链接，发生了什么？（以www.baidu.com为例）"></a>12.当你输入一个网址/点击一个链接，发生了什么？（以www.baidu.com为例）</h3><ul>
<li>1.点击网址后，应用层的DNS协议会将网址解析为IP地址；<ul>
<li>DNS查找过程：浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存（hosts文件）中是否有这个域名对应的DNS解析结果。若还没有，此时会发送一个数据包给DNS服务器，DNS服务器找到后将解析所得IP地址返回给用户。</li>
</ul>
</li>
<li>2.在应用层，浏览器会给web服务器发送一个HTTP请求；<ul>
<li>请求头为：GET <a href="http://www.baidu.com/HTTP/1.1" target="_blank" rel="noopener">http://www.baidu.com/HTTP/1.1</a></li>
</ul>
</li>
<li>3.在传输层，（上层的传输数据流分段）HTTP数据包会嵌入在TCP报文段中；<ul>
<li>TCP报文段需要设置端口，接收方（百度）的HTTP端口默认是80，本机的端口是一个1024-65535之间的随机整数，这里假设为1025，这样TCP报文段由TCP首部（包含发送方和接收方的端口信息）+ HTTP数据包组。</li>
</ul>
</li>
<li>4.在网络层中，TCP报文段再嵌入IP数据包中；<ul>
<li>IP数据包需要知道双方的IP地址，本机IP地址假定为192.168.1.5，接受方IP地址为220.181.111.147（百度），这样IP数据包由IP头部（IP地址信息）+TCP报文段组成。</li>
</ul>
</li>
<li>5.在网络接口层，IP数据包嵌入到数据帧（以太网数据包）中在网络上传送；<ul>
<li>数据帧中包含源MAC地址和目的MAC地址（通过ARP地址解析协议得到的）。这样数据帧由头部（MAC地址）+IP数据包组成。</li>
</ul>
</li>
<li>6.数据包经过多个网关的转发到达百度服务器，请求对应端口的服务；<ul>
<li>服务接收到发送过来的以太网数据包开始解析请求信息，从以太网数据包中提取IP数据包—&gt;TCP报文段—&gt;HTTP数据包，并组装为有效数据交与对应线程池中分配的线程进行处理，在这个过程中，生成相应request、response。</li>
</ul>
</li>
<li>7.请求处理完成之后，服务器发回一个HTTP响应；<ul>
<li>请求处理程序会阅读请求及它的参数和cookies。它会读取也可能更新一些数据，并将数据存储在服务器上。处理完毕后，数据通过response对象给客户输出信息，输出信息也需要拼接HTTP协议头部分，关闭后断开连接。断开后，服务器端自动注销request、response对象，并将释放对应线程的使用标识（一般一个请求单独由一个线程处理，部分特殊情况有一个线程处理多个请求的情况）。响应头为：HTTP/1.1200 OK</li>
</ul>
</li>
<li>8.浏览器以同样的过程读取到HTTP响应的内容（HTTP响应数据包），然后浏览器对接收到的HTML页面进行解析，把网页显示出来呈现给用户。<ul>
<li>客户端接收到返回数据，去掉对应头信息，形成也可以被浏览器认识的页面HTML字符串信息，交与浏览器翻译为对应页面规则信息展示为页面内容。</li>
</ul>
</li>
</ul>
<h3 id="13-计算机的OSI和TCP-IP网络模型"><a href="#13-计算机的OSI和TCP-IP网络模型" class="headerlink" title="13.计算机的OSI和TCP/IP网络模型"></a>13.计算机的OSI和TCP/IP网络模型</h3><ul>
<li>1.计算机的网络模型分为两种OSI模型和TCP/IP模型，它们的对应关系如下：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-757ce91f7440a227.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"></li>
<li><p>2.针对OSI模型，每一层都有各自的功能。</p>
<ul>
<li>应用层<ul>
<li>应用层是OSI模型中最靠近用户的一层，负责为用户的应用程序提供网络服务 。包括为相互通信的应用程序或进程之间建立连接，进行同步建立关于错误纠正和控制同时还包含大量的应用协议，例如远程登录（talent）、简单的邮件传输协议（SMTP）、简单的网络管理协议（SNMP），超文本传输协议（HTTP）。所有能超声网络流量的程序都在应用层。</li>
</ul>
</li>
<li>表示层<ul>
<li>表示层负责在不同的数据格式之间进行转换操作，以实现不同的计算机系统间的信息交换。还负责数据的加密，在传输的过程中进行保护，在发送端加密，在接收端解密，使用加密秘钥来对数据进行加密和解密。</li>
</ul>
</li>
<li><p>会话层</p>
<ul>
<li>会话层的主要功能是在两个节点间建立连接、维护、释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传输，在会话的过程中决定到底使用全双工还是使用半双工模式传输。</li>
</ul>
</li>
<li><p>传输层</p>
<ul>
<li>传输层是OSI模型中唯一负责端到端节点数据传输和控制的层，传输层是在OSI模型中起承上启下的作用，它下面的三层主要主要面向网络通信，以确保信息准确有效的传输，上面的三层树妖面向主机用户，为用户提供各种服务。 传输层为了向会话层提供可靠的端到端传输服务，也使用差错控制和流量控制等机制。4层的协议有传输控制协议（TCP），用户数据报协议（UDP），顺序包交换协议（SPX）。</li>
</ul>
</li>
<li>网络层<ul>
<li>负责选择最佳的路径，规划IP(Internet Protocol)地址。</li>
</ul>
</li>
<li>数据链路层<ul>
<li>数据帧的开始和结束，同时提供透明传输，差错校验。</li>
</ul>
</li>
<li>物理层<ul>
<li>是OSI模型的最底层，它面向原始的比特流的传输，同时规范了接口标准。</li>
</ul>
</li>
</ul>
</li>
<li>3.针对TCP/IP模型，每一层都有各自的功能。<ul>
<li>物理层：对应OSI模型的低两层，物理层和数据链路层；常用协议：Ethernet、FDDI、令牌环</li>
<li>网络层：对应OSI模型的网络层；常用协议：IP、ARP、RAR、ICMP</li>
<li>传输层：对应OSI模型的传输层；常用协议：TCP、UDP</li>
<li>应用层：对应OSI模型的高三层，会话层、表示层、应用层；常用协议：DNS、HTTP、SMTP、POP、TELNET、FTP</li>
</ul>
</li>
</ul>
<h3 id="14-TCP-FTP-简析"><a href="#14-TCP-FTP-简析" class="headerlink" title="14.TCP/FTP 简析"></a>14.TCP/FTP 简析</h3><ul>
<li>1.TCP/FTP简析</li>
<li>TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层：<ul>
<li>网络层：IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议</li>
<li>传输层：TCP协议与UDP协议</li>
<li>应用层：FTP、HTTP、TELNET、SMTP、DNS等协议</li>
</ul>
</li>
<li>2.TCP连接的三次握手<ul>
<li>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</li>
<li>第二次握手：服务端接收到客户端的请求后，给出一个确认ACK(ack=j+1),同时自己也发送出一个SYN包(syn=k),此时服务器进入SYN_RECV状态。</li>
<li>第三次握手：客户端接收到服务端的SYN+ACK包后，向服务器发出一个确认ACK(ack=k+1)，此包发送完毕，客户端和服务端进入ESTABLIST状态，完成三次握手。</li>
</ul>
</li>
<li>3.FTP</li>
<li>文件传输协议（File Transfer Protocol, FTP）是TCP/IP网络上两台计算机传送文件的协议，FTP是在TCP/IP网络和INTERNET上最早使用的协议之一，它属于网络协议组的应用层。FTP客户机可以给服务器发出命令来下载文件，上载文件，创建或改变服务器上的目录。</li>
</ul>
<h3 id="15-IP地址与子网掩码"><a href="#15-IP地址与子网掩码" class="headerlink" title="15.IP地址与子网掩码"></a>15.IP地址与子网掩码</h3><ul>
<li>1.IP地址：Internet上每台主机都必须有一个唯一的地址以区别于其他主机，这个地址就是Internet地址，也称作IP地址；IPv4（第四版本的IP协议）是构成现今互联网技术的基石协议；</li>
<li>2.IP地址的构成：IP地址由32位二进制构成，共约40亿个，由网络地址和主机地址构成；一个IP地址分为四段：a.b.c.d ，段与段之间用原点分开。IP地址表示方法：二进制形式和点分十进制形式；</li>
<li>3.IP地址的分类：5类(A类地址，B类地址，C类地址，D类地址，E类地址)</li>
<li>IP地址的分类是根据第一段（a字段，前8位）的取值范围来划分的；<ul>
<li>A类地址：以0开头，前8位为网络地址，后24位为主机地址。A类地址第一段a字段的取值范围1~126。每一个A类地址中可以容纳的主机的数目约为1600万。地址范围：1.0.0.0~126.255.255.255</li>
<li>B类地址：以10开头，前16位为网络地址，后16位为主机地址。B类地址第一段a字段取值范围为128~191。每一个B类地址中可以容纳主机数目约为65000。地址范围：128.0.0.0~191.255.255.255</li>
<li>C类地址：以110开头，前24位为网络地址，后8位为主机地址。C类地址第一段a字段的取值范围是192~223。每一个C类地址可容纳主机的数目约为254。地址范围：192.0.0.0~223.255.255.255</li>
</ul>
</li>
<li>4.IPv6（第六版IP协议）：一个IP地址由128位二进制组成，采用冒分16进制。</li>
<li>5.特殊的IP地址：<ul>
<li>a.专用IP地址：三类网络号，这些地址不会被Internet分配因此也不能被路由。<ul>
<li>A类：1.0.0.0~10.255.255.255  （长度相当于1个A类IP地址）</li>
<li>B类：172.16.0.0~172.31.255.255  （长度相当于16个连续的B类IP地址）</li>
<li>C类：192.168.0.0~192.168.255.255  （长度相当于256个连续的C类IP地址）</li>
</ul>
</li>
<li>b. 特殊IP地址：<ul>
<li>0.0.0.0  是全零网络代表默认网络，帮助路由器发送路由表中无法查询的包。如果设置了全零网络路由，路由器中无法查询的包都会被送到全零网络的路由中去；</li>
<li>127.0.0.1  称作回送地址，属于环回地址，IP从127.0.0.0到127.255.255.255都将环回到本地主机中；</li>
<li>255.255.255.255  限制广播地址，对本机来说，这个地址指本网段内（同一广播域）所有主机；</li>
</ul>
</li>
</ul>
</li>
<li>6.子网掩码</li>
<li>子网掩码：是一个32位二进制的值，可以将IP地址分离出网络地址和主机地址，采用点分十进制的形式。子网掩码不能单独存在它必须结合IP地址一起使用。</li>
<li>子网掩码由1和0组成，且1和0分别连续。<strong>子网掩码的长度也是32位。左边是网络位，用二进制数字1表示，1的数目等于网络位的长度；右边是主机位用2进制数字0表示，0的数目等于主机位的长度；这样做的目的是为了让掩码与IP地址做与运算时用0遮住原主机数，而不改变网络段的数字；而且很容易通过0的位数确定子网的主机数；</strong>将32位IP地址与32位的子网掩码各位进制进行 ‘与’ 运算，得到的是该IP地址的网络地址；</li>
<li>方法：<strong>子网掩码可以判断两台计算机是否属于同一网段，将计算机10进制的IP地址和子网掩码转换为2进制的形式，然后进行‘与’运算，如果网络地址是相同的，那么两台计算机就属于同一网段；</strong></li>
<li>子网掩码可分为缺省子网掩码和自定义子网掩码：<ul>
<li>a.缺省（默认）子网掩码：即为划分子网，对应的网络号都是1，主机号位都是0；<ul>
<li>A类网络缺省（默认）子网掩码：255.0.0.0</li>
<li>B类网络缺省（默认）子网掩码：255.255.0.0</li>
<li>C类网络缺省（默认）子网掩码：255.255.255.0</li>
</ul>
</li>
<li>b.自定义子网掩码是将一个网络划分为几个子网，需要每一段使用不同的网络号或者子网号，实际上我们可以认为是将主机号分为两个部分：子网号和子网主机号。形式如下：<ul>
<li>未做子网划分的IP地址：网络号+主机号</li>
<li>做子网划分的IP地址：网络号+子网号+子网主机号。也就是说，IP地址在子网划分后，以前的主机号一部分给了子网号，剩下的是子网主机号；</li>
</ul>
</li>
</ul>
</li>
<li>子网掩码通常有两种格式的表示方式：<ul>
<li>点分十进制格式，如：255.255.255.128</li>
<li>IP地址后面加上‘/’符号以及1-32位的数字，其中1-32的数字表示子网掩码中网络标识位的长度；例如：192.168.1.1/24的子网掩码也可以表示为255.255.255.0</li>
</ul>
</li>
</ul>
<h3 id="16-路由器"><a href="#16-路由器" class="headerlink" title="16.路由器"></a>16.路由器</h3><ul>
<li>路由器：属于网络层，是连接因特网中的各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按照前后顺序发送信号。连接不同的网络，所谓不同的网络就是网络地址不同；路由器工作在IP协议网络层，用于实现子网之间转发数据，路由器一般包含多个网络接口，包括局域网和广域网接口，每个网络接口连接不同的网络；路由器记录着每个网络端口连接的网络信息；路由器中还包含路由表：记录了去往不同的网络地址应该送往的端口号；</li>
<li>作用：为每个数据帧寻找最佳的传输路径，并将其有效的传送到目的站点，在路由器中通过路由表保存着各种传输路径的相关数据，供路由选择时使用。</li>
<li>路由表：保存各种传输路径的相关数据，供路由选择时使用；路由表中保存着子网的标志信息、网上路由器的个数和下一个路由器的名字等内容；</li>
<li>静态路由表：由系统管理员事先设定好的路由表；</li>
<li>动态路由表：路由器根据网络系统的运行情况动态调整的路由表；</li>
<li>工作流程：数据包送到路由器后，通过数据包首部的目的主机IP地址和子网掩码计算出网络地址，即目的主机所在的网络，查找当前路由器的路由表，选择端口进行转发;下一台IP路由器收到数据包后继续转发，直到目的地；<strong>路由转发策略称为路由选择；</strong></li>
<li>路由器和交换机之间的主要区别是：交换机发生在OSI参考模型的第二层（数据链路层），而路由器发生在第三层（网络层）。路由器是不同网络之间相互连接的枢纽，路由器构成了Internet的骨架；路由器具有判断网路地址，选择IP路径的功能；</li>
</ul>
<h3 id="17-MAC地址-物理地址、硬件地址-的概念和作用"><a href="#17-MAC地址-物理地址、硬件地址-的概念和作用" class="headerlink" title="17.MAC地址(物理地址、硬件地址)的概念和作用"></a>17.MAC地址(物理地址、硬件地址)的概念和作用</h3><ul>
<li>概念：MAC地址就是在媒体接入层上使用的地址，也叫物理地址、硬件地址或链路地址，其被固化在适配器的ROM中。可见，MAC地址实际上就是适配器地址或适配器标识符。当某台计算机使用某块适配器后，适配器上的标识符就成为该计算机的MAC地址。MAC地址长度为6字节（48比特），由IEEE的注册管理结构RA进行管理分配。</li>
<li>作用：MAC地址是计算机的唯一标识，在数据链路层中，交换机通过识别MAC地址进行数据包的传输。</li>
</ul>
<h3 id="18-路由表中的内容"><a href="#18-路由表中的内容" class="headerlink" title="18.路由表中的内容"></a>18.路由表中的内容</h3><ul>
<li>Network Destination：目标网段；Netmask：子网掩码，IP地址与子网掩码按位与，可以得出该IP地址的网络号，IP地址与子网掩码取反后按位与，可以得出该IP地址的主机号。Interface：达到该目标网段的本地路由器的出口IP；Gateway：网关IP，下一跳路由器的入口IP，通常情况下，interface和gateway是同一网段的。Metric：跳数，该条路由记录的质量，一般情况下，如果有多条到达相同目的地的路由记录，路由器会采用metric值小的那条路由。</li>
</ul>
<h3 id="19-分组转发算法流程"><a href="#19-分组转发算法流程" class="headerlink" title="19.分组转发算法流程"></a>19.分组转发算法流程</h3><ul>
<li>1.从数据报的首部提取目的主机的IP地址D，得出目的网络地址N（子网掩码和IP地址做与运算可得出网络地址）。</li>
<li>2.若N就是于此路由器直接相连的某个网络地址，则进行直接交付，不需要在经过其他路由器，直接把数据报交付给目的主机（这里包括把目的IP地址D转换为具体的MAC地址（ARP协议），把数据报封装成MAC帧，在发送此帧）；否则就是间接交付。</li>
<li>3.若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器。</li>
<li>4.若路由表中有达到网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器。</li>
<li>5.若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器。</li>
<li>6.报告转发分组出错。</li>
</ul>
<h3 id="20-TFTP与FTP的区别"><a href="#20-TFTP与FTP的区别" class="headerlink" title="20.TFTP与FTP的区别"></a>20.TFTP与FTP的区别</h3><ul>
<li>FTP（File Transfer Protocol，文件传输协议）协议在TCP/IP协议族中属于应用层协议，<strong>用于在远端服务器和本地客户端之间传输文件，使用TCP端口20和21进行传输</strong>。端口20用于传输数据，端口21用于传输控制消息。</li>
<li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）也是用于在远端服务器和本地主机之间传输文件的，相对于FTP，TFTP没有复杂的交互存取接口和认证控制，适用于客户端和服务器之间不需要复杂交互的环境。</li>
<li>TFTP协议的运行基于UDP协议，使用UDP端口69进行数据传输。</li>
<li>区别：<ul>
<li>基于的传输协议不一样：FTP是基于TCP TFTP是基于UDP</li>
<li>端口号不一样：FTP是用21.20 TFTP是69</li>
<li>速度和安全方面：FTP在速度方面没有TFTP快但是FTP安全好</li>
</ul>
</li>
</ul>
<h3 id="21-MTU的概念，什么是路径MTU？-MTU发现机制，TraceRoute"><a href="#21-MTU的概念，什么是路径MTU？-MTU发现机制，TraceRoute" class="headerlink" title="21.MTU的概念，什么是路径MTU？ MTU发现机制，TraceRoute"></a>21.MTU的概念，什么是路径MTU？ MTU发现机制，TraceRoute</h3><ul>
<li>MTU：即Maximum Transmission Unit 最大传输单元。它是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。</li>
<li>路径MTU：路径MTU是指一条因特网传输路径中，从源地址到目的地址所经过的“路径”上的所有IP跳的最大传输单元的最小值。或者从另外一个角度来看，就是无需进行分片处理就能穿过这条“路径”的最大传输单元的最大值。</li>
<li>路径MTU的发现方法：这是确定两个IP主机之间路径最大传输单元的技术，其目的就是为了避免IP分片。首先源地址将数据报的DF位置位，在逐渐增大发送的数据报的大小——路径上任何需要将分组进行分片的设备都会将这种数据报丢弃并返回“数据报过大“的ICMP响应到源地址——这样源主机就”学习“到了无需分片就能通过这条路径的最大的最大传输单元。</li>
<li>Traceroute:用来侦测主机到目的主机之间所经路由情况的重要工具。原理如下：它受到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包（每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签），而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器ip。Traceroute提取发送 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。</li>
</ul>
<h3 id="22-ICMP协议"><a href="#22-ICMP协议" class="headerlink" title="22.ICMP协议"></a>22.ICMP协议</h3><ul>
<li>概念：ICMP的全称是 Internet Control Message Protocol ，它是一种“错误侦测与回报机制”，不传输用户数据，其目的就是让我们能够检测网路的连线状况。ICMP数据包由一个8字节长的包头，其中前四个字节是固定格式，包括8位类型字段、8位代码字段个16位校验和；后4个字节根据ICMP类型的不同而取不同的值；</li>
<li>作用：<ul>
<li>侦测远端主机是否存在</li>
<li>建立及维护路由资料</li>
<li>重导数据传送路径</li>
<li>数据流量控制</li>
</ul>
</li>
<li>Internet 控制报文协议，负责发送消息，报告错误；属于TCP/IP协议族；主要用在主机和路由器之间，ICMP提供移动的出错报告信息，但是他的功能是报告问题而不是纠正问题，他将出错的报文返回发送方，纠正问题的功能由发送方完成；发送方根据ICMP提供的错误类型来确定如何才能更好的重新发送失败的数据包；</li>
<li>应用：Ping命令其实就是ICMP协议的工作过程；Tracert命令，跟踪路由的命令也是基于ICMP协议的；</li>
</ul>
<h3 id="23-组播和广播的概念，IGMP的用途"><a href="#23-组播和广播的概念，IGMP的用途" class="headerlink" title="23.组播和广播的概念，IGMP的用途"></a>23.组播和广播的概念，IGMP的用途</h3><ul>
<li>组播：主机之间的通讯模式，也就是加入了同一个组的主机可以接收到此组内的所有数据，网络中的交换机和路由器只向有需求者复制并转发其所需数据。主机可以向路由器请求加入或退出某个组，网络中的路由器和交换机有选择的复制并传输数据，即只将组内数据传输给那些加入组的主机。这样既能一次将数据传输给多个有需要（加入组）的主机，又能保证不影响其他不需要（未加入组）的主机的其他通讯。</li>
<li>广播： 是指在IP子网内广播数据包，所有在子网内部的主机都将收到这些数据包。广播意味着网络向子网每一个主机都投递一份数据包，不论这些主机是否乐于接收该数据包。所以广播的使用范围非常小，只在本地子网内有效，通过路由器和网络设备控制广播传输。组播协议与现在广泛使用的单播协议的不同之处在于，一个主机用单播协议向n个主机发送相同的数据时，发送主机需要分别向n个主机发送，共发送n次。一个主机用组播协议向n个主机发送相同的数据时，只要发送1次，其数据由网络中的路由器和交换机逐级进行复制并发送给各个接收方，这样既节省服务器资源也节省网络主干的带宽资源。</li>
<li>IGMP（Internet Group Management Protocol）的用途<ul>
<li>它用来在ip主机和与其直接相邻的组播路由器之间建立、维护组播组成员关系。组播路由器不需要保存所有主机的成员关系，它只是通过IGMP协议了解每个接口连接的网段上是否存在某个组播组的组成员，而主机只需要保存自己加入了哪些组播组。简而言之，IGMP协议是让连接在本地局域网上的组播路由器知道本局域网上是否有主机上的某个进程参加或退出了某个组播组。</li>
</ul>
</li>
<li>环回地址/广播地址<ul>
<li>环回地址：127.0.0.1，通常被称为本地回环地址(Loop back address)，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。</li>
<li>作用：<ul>
<li>a.一是测试本机的网络配置，能PING通127.0.0.1说明本机的网卡和IP协议安装都没有问题；</li>
<li>b.某些SERVER/CLIENT的应用程序在运行时需调用服务器上的资源，一般要指定SERVER的IP地址，但当该程序要在同一台机器上运行而没有别的SERVER时就可以把SERVER的资源装在本机，SERVER的IP地址设为127.0.0.1同样也可以运行。</li>
</ul>
</li>
<li><strong>广播地址</strong>：是专门用于同时向网络中所有工作站进行发送的一个地址。<strong>在使用TCP/IP协议的网络中，主机标识段host ID为全1的IP地址为广播地址，广播的分组传送给host ID段所涉及的所有计算机</strong>。例如，对于10.1.1.0 （255.255.255.0 ）网段，其广播地址为10.1.1.255（255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。</li>
</ul>
</li>
</ul>
<h3 id="24-DNS的概念，用途，DNS查询的实现算法"><a href="#24-DNS的概念，用途，DNS查询的实现算法" class="headerlink" title="24.DNS的概念，用途，DNS查询的实现算法"></a>24.DNS的概念，用途，DNS查询的实现算法</h3><ul>
<li>DNS用途：DNS是由解析器以及域名服务器组成的。域名服务器是指保存有该网络中所有主机的域名和对应IP地址，并具有将域名转换为IP地址功能的服务器。DNS使用TCP与UDP端口号都是53，主要使用UDP，服务器之间备份使用TCP。</li>
<li>域名到IP地址的解析过程的要点如下：<ul>
<li>a.当某一个应用进程需要主机名解析为IP地址时，该应用进程就调用解析程序，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器。</li>
<li>b.本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。应用进程获得目的主机的IP地址后即可进行通信。</li>
<li>c.若本地域名服务器不能回答该请求，则此域名服务器就暂时成为DNS中的另一个客户，并向其他域名服务器发出查询请求。这种过程直至找到能够回答该请求的域名服务器为止。</li>
</ul>
</li>
<li>DNS查询算法<ul>
<li><strong>主机向本地域名服务器的查询一般都是采用递归查询</strong>，即如果主机所询问的本地域名服务器不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文，而不是让该主机自己进行下一步的查询。 因此，递归查询返回的查询结果或是所要查询的IP地址，或是报错。</li>
<li><strong>本地域名服务器向根服务器的查询通常采用迭代查询</strong>，即当根域名服务器收到本地域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器“下一次应向哪个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。根域名服务器通常把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询。本地域名服务器就这样进行迭代查询。</li>
</ul>
</li>
</ul>
<h3 id="25-TCP的流量控制"><a href="#25-TCP的流量控制" class="headerlink" title="25.TCP的流量控制"></a>25.TCP的流量控制</h3><ul>
<li>1.利用滑动窗口实现流量控制<ul>
<li>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。设A向B发送数据，在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。<br> <img src="https://upload-images.jianshu.io/upload_images/13407176-95ab02be1704aa0f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流量控制.jpg"></li>
<li>从图中可以看出，B进行了三次流量控制。第一次把窗口减少到rwnd=300 ，第二次又减到了rwnd=100 ，最后减到rwnd=0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了ACK=1 ，只有在ACK=1时确认号字段才有意义。TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</li>
</ul>
</li>
<li>2.必须考虑传输速率</li>
<li>可以用不同的机制来控制TCP报文段的发送时机。如：<ul>
<li>a.TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。</li>
<li>b.由发送方的应用进程指明要求发送报文段，即TCP支持的推送( push )操作。</li>
<li>c.发送方的一个计时器期限到了，这时就把已有的缓存数据装入报文段(但长度不能超过MSS)发送出去。</li>
</ul>
</li>
<li>3.Nagle算法</li>
<li>若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。当发送方接收对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段再发送出去，同时继续对随后到达的数据进行缓存。只有在收到对前一个报文段的确认后才继续发送下一个报文段。当数据到达较快而网络速率较慢时，用这样的方法可明显地减少所用的网络带宽。Nagle算法还规定：当到达的数据已达到 发送窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</li>
<li>4.糊涂窗口综合证：TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1字节（这样就使接收缓存空间仅腾出1字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报为40字节的的话）。接收，发送方又发来1个字节的数据（发送方的IP数据报是41字节）。接收方发回确认，仍然将窗口设置为1个字节。这样，网络的效率很低。要解决这个问题，可让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收方缓存已有一半空闲的空间。只要出现这两种情况，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小。</li>
</ul>
<h3 id="26-TCP拥塞控制"><a href="#26-TCP拥塞控制" class="headerlink" title="26.TCP拥塞控制"></a>26.TCP拥塞控制</h3><ul>
<li>1.拥塞：拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。</li>
<li>2.几种拥塞控制方法<ul>
<li>慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</li>
</ul>
</li>
<li>3.慢开始和拥塞避免</li>
<li>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</li>
<li><strong>慢开始算法</strong>：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口cwnd ，可以使分组注入到网络的速率更加合理。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。另外，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：<ul>
<li>当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。</li>
<li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li>
<li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</li>
</ul>
</li>
<li><strong>拥塞避免算法</strong>：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。<br>  <img src="https://upload-images.jianshu.io/upload_images/13407176-163d146352f644df?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP拥塞窗口cwnd在拥塞控制时的变化情况"><ul>
<li>a.当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16 。</li>
<li>b.在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。 当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长。</li>
<li>c.假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。 当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小。强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li>
</ul>
</li>
<li>4.快重传和快恢复</li>
<li><strong>快重传</strong>：如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</li>
<li><strong>快恢复</strong>：<ul>
<li>a.当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</li>
<li>b.由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li>
</ul>
</li>
<li>5.停止等待协议和滑动窗口协议</li>
<li><strong>停止等待协议</strong>：是tcp保证传输可靠的重要途径，”停止等待”就是指发送完一个分组就停止发送，等待对方的确认，只有对方确认过，才发送下一个分组.</li>
<li><strong>滑动窗口协议</strong>：之所以叫滑动窗口协议，是因为窗口是不断向前走的，该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，还可以控制流量的问题。滑动窗口协议中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它受限于在流水线 中为未确认的分组数不能超过某个最大允许数N。滑动窗口协议是TCP使用的一种流量控制方法，此协议能够加速数据的传输。 只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。收发两端的窗口按照以上规律不断地向前滑动，因此这种协议称为滑动窗口协议。当发送窗口和接收窗口的大小都等于1时，就是停止等待协议。</li>
</ul>
<h3 id="27-TIME-WAIT状态及存在原因"><a href="#27-TIME-WAIT状态及存在原因" class="headerlink" title="27.TIME_WAIT状态及存在原因"></a>27.TIME_WAIT状态及存在原因</h3><ul>
<li>客户端与服务器端建立TCP/IP连接后关闭SOCKET后，服务器端连接的端口状态为TIME_WAIT；</li>
<li>主动关闭的Socket端会进入TIME_WAIT状态，并且持续2MSL时间长度，MSL就是maximum segment lifetime(最大分节生命期）；这是一个IP数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒，因而，TIME_WAIT状态一般维持在1-4分钟。</li>
<li>主动关闭的一方在发送最后一个ack后就会进入TIME_WAIT状态停留2MSL（max segment lifetime）时间这个是TCP/IP必不可少的，也就是“解决”不了的。</li>
<li>TIME_WAIT状态存在的理由：<ul>
<li>a.防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失）</li>
<li>b.可靠的关闭TCP连接:在进行关闭连接四路握手协议时，最后的ACK是由主动关闭端发出的，如果这个最终的ACK丢失，服务器将重发最终的FIN，因此客户端必须维护状态信息允 许它重发最终的ACK。<br>如果不维持这个状态信息，那么客户端将响应RST分节，服务器将此分节解释成一个错误。因而，要实现TCP全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，主动关闭 的客户端必须维持状态信息进入TIME_WAIT状态。</li>
</ul>
</li>
</ul>
<h3 id="28-Http2-0和Http1-0区别"><a href="#28-Http2-0和Http1-0区别" class="headerlink" title="28.Http2.0和Http1.0区别"></a>28.Http2.0和Http1.0区别</h3><ul>
<li>Http2.0采用二进制格式非文本格式；</li>
<li>Http2.0是完全多路复用的，非有序并阻塞的只需要一个连接即可实现并行；</li>
<li>使用报头压缩，降低了开销；</li>
<li>Http2.0让服务器可以将响应主动推送到客户端缓存中。</li>
</ul>
<h3 id="29-SMTP和POP3协议的区别"><a href="#29-SMTP和POP3协议的区别" class="headerlink" title="29.SMTP和POP3协议的区别"></a>29.SMTP和POP3协议的区别</h3><ul>
<li>SMTP用来发生邮件的，端口号25；POP3用来接收邮件的，端口号110，使用TCP协议。</li>
</ul>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul>
<li><a href="https://www.cnblogs.com/Allen-rg/category/1011622.html" target="_blank" rel="noopener">参考博客</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>TCP/IP协议栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode刷题记录</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ul>
<li><strong>递归方法和循环方法的对比</strong></li>
<li>递归方法代码实现比较简洁，但是性能不如循环方法，还有可能出现栈溢出的问题。一般情况下优先考虑递归方法来实现！</li>
<li><strong>搜索路径的题目</strong>：一般使用回溯法，回溯法很适合使用递归方法的代码来实现！当要求不能使用递归实现的时候，考虑使用栈模拟递归的过程</li>
<li><strong>求某个问题的最优解时，并且该问题可以拆分为多个子问题时</strong>：可以尝试使用动态规划的方法！在使用自上而下的递归思路去分析动态规划问题时，会发现子问题之间存在重叠<br>的更小的子问题。为了避免不必要的重复计算，使用自下而上的循环代码来实现，即把子问题的最优解先计算出来并用数组保存下来，然后基于子问题的解计算大问题的解。</li>
<li><strong>特殊情况</strong>：在分解子问题的时候存在某个特殊的选择，采用这个特殊的选择将一定那个得到最优解，则此题目可能适用于贪心算法！</li>
<li><strong>典型题目的解题思路</strong>：在一个已经排好序的数组中查找一个数字或者统计某个数字出现的次数，可以尝试使用二分查找算法！</li>
<li>Q1:给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。<strong>注意：答案中不可以包含重复的三元组。</strong></li>
<li><p>自己写的：暴力解决，时间复杂度太大</p>
<figure class="highlight nimrod"><table><tr><td class="code"><pre><span class="line">class <span class="type">Solution</span>(<span class="keyword">object</span>):</span><br><span class="line">    def threeSum(self, nums):</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="literal">result</span> = []</span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j + <span class="number">1</span>, len(nums)):</span><br><span class="line">                    <span class="keyword">if</span> nums[i] + nums[j] + nums[k] == <span class="number">0</span>:</span><br><span class="line">                        <span class="literal">result</span>.append([nums[i], nums[j], nums[k]])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len(<span class="literal">result</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="literal">result</span>[i] <span class="keyword">not</span> <span class="keyword">in</span> temp:</span><br><span class="line">                temp.append(<span class="literal">result</span>[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = <span class="type">Solution</span>()</span><br><span class="line">    <span class="literal">result</span> = s.threeSum([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>, <span class="number">3</span>, -<span class="number">5</span>, -<span class="number">2</span>, -<span class="number">3</span>])</span><br><span class="line">    print(<span class="literal">result</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>网上大神的解法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="comment"># 存储结果列表</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 对nums列表进行排序，无返回值，排序直接改变nums顺序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 因为是升序排列，如果排序后第一个数都大于0，则跳出循环，不可能有为0的三数之和</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 排序后相邻两数如果相等，则跳出当前循环继续下一次循环，相同的数只需要计算一次</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 记录i的下一个位置</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 最后一个元素的位置</span></span><br><span class="line">            k = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="comment"># 判断三数之和是否为0</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] + nums[k] == -nums[i]:</span><br><span class="line">                    <span class="comment"># 把结果加入数组中</span></span><br><span class="line">                    result.append([nums[i], nums[j], nums[k]])</span><br><span class="line">                    <span class="comment"># 判断j相邻元素是否相等，有的话跳过这个</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 判断后面k的相邻元素是否相等，是的话跳过</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k<span class="number">-1</span>]: k -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 没有相等则j+1，k-1，缩小范围</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 小于-nums[i]的话还能往后取</span></span><br><span class="line">                <span class="keyword">elif</span> nums[j] + nums[k] &lt; -nums[i]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q2:见下图<br><img src="https://upload-images.jianshu.io/upload_images/13407176-7d98c1f7b72578aa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="罗马数字转整数.jpg"></p>
</li>
<li><p>A2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    d = &#123;<span class="string">'M'</span>: <span class="number">1000</span>,<span class="string">'D'</span>: <span class="number">500</span> ,<span class="string">'C'</span>: <span class="number">100</span>,<span class="string">'L'</span>: <span class="number">50</span>,<span class="string">'X'</span>: <span class="number">10</span>,<span class="string">'V'</span>: <span class="number">5</span>,<span class="string">'I'</span>: <span class="number">1</span>&#125;</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    s_len = len(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(s_len<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> d[s[i]] &lt; d[s[i+<span class="number">1</span>]]:</span><br><span class="line">            result -= d[s[i]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result += d[s[i]]</span><br><span class="line">    result += d[s[<span class="number">-1</span>]]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q3:编写一个函数来查找字符串数组中的最长公共前缀,如果不存在公共前缀，返回空字符串 “”。</p>
</li>
<li><p>A3：仅仅比较最长与最短的字符串，如果存在相同的前缀就返回；不存在就返回一个空字符串。重要的是如何从两个字符串中取相同位置的字符进行比较。</p>
  <figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">def</span> longest_str(<span class="keyword">strs):</span></span><br><span class="line"><span class="keyword"> </span>   <span class="built_in">s1</span> = min(<span class="keyword">strs) </span> # 最短字符串</span><br><span class="line">    <span class="built_in">s2</span> = max(<span class="keyword">strs) </span># 最长字符串</span><br><span class="line">    for i, v in enumerate(<span class="built_in">s1</span>):</span><br><span class="line">        <span class="meta">if</span> v != <span class="built_in">s2</span>[i]:</span><br><span class="line">            return <span class="built_in">s2</span>[:i]   # 当第一个字符就不相等时,返回<span class="built_in">s2</span>[:<span class="number">0</span>]=[],执行下面的<span class="meta">if</span>语句</span><br><span class="line">    <span class="meta">if</span> not <span class="keyword">strs:</span></span><br><span class="line"><span class="keyword"> </span>       return <span class="string">""</span></span><br><span class="line"><span class="symbol">if</span>  __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">strs </span>= [<span class="string">"dog"</span>, <span class="string">"racecar"</span>, <span class="string">"car"</span>]</span><br><span class="line">    <span class="keyword">strs1 </span>= [<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>]</span><br><span class="line">    result = longest_str(<span class="keyword">strs)</span></span><br><span class="line"><span class="keyword"> </span>   result1 = longest_str(<span class="keyword">strs1)</span></span><br><span class="line"><span class="keyword"> </span>   print(result)</span><br><span class="line">    print(result1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q4:给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：<strong>左括号必须用相同类型的右括号闭合;左括号必须以正确的顺序闭合;注意空字符串可被认为是有效字符串</strong></p>
</li>
<li><p>A4:只有完整出现[],{},()的情况才会返回true,同时空字符串也被任何是有效字符串,所以,用空格进行替换[],{},()，然后比较替换后的结果是否是空字符串，不是的话说明不是有效字符串。</p>
  <figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_Valid</span><span class="params">(s)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="string">"&#123;&#125;"</span> <span class="keyword">in</span>  s <span class="keyword">or</span> <span class="string">"()"</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">"[]"</span> <span class="keyword">in</span> s)<span class="symbol">:</span></span><br><span class="line">        s = s.replace(<span class="string">"&#123;&#125;"</span>, <span class="string">""</span>)</span><br><span class="line">        s = s.replace(<span class="string">"()"</span>, <span class="string">""</span>)</span><br><span class="line">        s = s.replace(<span class="string">"[]"</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> s == <span class="string">""</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Q5:将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 例如，输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4；输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
</li>
<li><p>A5:</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    int val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span> *next;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// 借助归并排序的思路，递归方法实现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span>* mergeTwoLists(<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span> *l1, <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span> *l2)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span> *p;</span><br><span class="line">    <span class="keyword">if</span> (!l1)</span><br><span class="line">        retutn l2;</span><br><span class="line">    <span class="keyword">if</span> (!l2)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;   <span class="comment">// 将两个链表中小的元素放在新的链表中，用指针p指向它</span></span><br><span class="line">        p = l1;</span><br><span class="line">        p-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p = l2;</span><br><span class="line">        p-&gt;next = mergeTwoLists(l2-&gt;next,l1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q6:给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p>
</li>
<li><p>A6:</p>
  <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int removeDuplicates(int *nums, int numsSize)&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    int <span class="built_in">i</span>, <span class="built_in">j</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;numsSize;<span class="built_in">i</span>++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="built_in">j</span>] != nums[<span class="built_in">i</span>])</span><br><span class="line">                nums[++<span class="built_in">j</span>]=nums[<span class="built_in">i</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">j</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q7:给定一个数组 nums 和一个值 val，你需要<strong>原地</strong>移除所有数值等于 <strong>val</strong>的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</li>
<li><p>A7:</p>
  <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">int removeElement(int* nums, int numsSize, int val)&#123;</span><br><span class="line">    int <span class="built_in">i</span>,<span class="built_in">j</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span> &lt; numsSize;<span class="built_in">i</span>++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="built_in">i</span>] != val)</span><br><span class="line">            nums[<span class="built_in">j</span>++] = nums[<span class="built_in">i</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">j</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q8:统计小于非负整数n的质数的个数。例如。n=10,则输出小于10的质数个数是4个，具体是2, 3, 5, 7。</p>
</li>
<li><p>A8:使用<strong>厄拉多塞筛法</strong>：首先从数字2开始，依次删除2的倍数；接着从3开始，依次删除3的倍数，然后从5开始(因为4是2的倍数，已经被删除了)，依次删除5的倍数。一直循环上面的步骤的n-1即可，然后统计最后剩余的数的个数，即质数的个数。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">self</span>, <span class="symbol">n:</span> int)</span></span> -&gt; <span class="symbol">int:</span></span><br><span class="line">       <span class="keyword">if</span> n&lt;=<span class="number">2</span><span class="symbol">:</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       isPrime = [<span class="number">1</span>] * n  <span class="comment"># 生成一个全为1的列表</span></span><br><span class="line">       isPrime[<span class="number">0</span>], isPrime[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(n**<span class="number">0</span>.<span class="number">5</span>)+<span class="number">1</span>):   <span class="comment"># 质数：除1和本身外，没有其他的因数。如果有其他因数p,则p*p = n,即p = n**0.5</span></span><br><span class="line">           <span class="keyword">if</span> isPrime[i] == <span class="number">1</span>:  <span class="comment"># 如果i是质数</span></span><br><span class="line">               isPrime[<span class="number">2</span>*<span class="symbol">i:</span><span class="symbol">n:</span>i] = [<span class="number">0</span>] * len(isPrime[i*<span class="number">2</span><span class="symbol">:n</span><span class="symbol">:i</span>])  <span class="comment"># 将i的倍数置为0</span></span><br><span class="line">             <span class="comment">#  print(i, isPrime)</span></span><br><span class="line">       <span class="keyword">return</span> sum(isPrime)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q9：给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
</li>
<li><p>A9：思路是如果最后一位不是9，而是0到8，就执行普通的最后一位的加1操作；如果最后一位是9，就要考虑向前面一位产生进位标志1，这是此题的关键！</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def plusOne(self, <span class="keyword">digits</span>: List[int]) -&gt; List[int]:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(len(<span class="keyword">digits</span>)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):  # 反向遍历list(起点，终点,步长)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">digits</span>[i] <span class="keyword">is</span> <span class="number">9</span>:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">digits</span>[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">digits</span>[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">digits</span></span><br><span class="line">        <span class="keyword">if</span> flag:   # 防止出现list=[<span class="number">9</span>]的情况</span><br><span class="line">            <span class="keyword">digits</span>.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">digits</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Q10:删除链表中等于给定值 val 的所有节点。示例:输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6  输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p>
</li>
<li><p>A10:</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *<span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(int x) : val(x), <span class="keyword">next</span>(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode*<span class="built_in"> head</span>, int val) &#123;</span><br><span class="line">        // 空链表的情况</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">!head</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        // 删除的节点是头节点</span><br><span class="line">        while<span class="built_in">(head</span>-&gt;val == val)&#123;</span><br><span class="line">           <span class="built_in"> head</span> =<span class="built_in"> head</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">!head</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* pNode =<span class="built_in"> head</span>;</span><br><span class="line">        ListNode* pCur =<span class="built_in"> head</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">        // 删除的是中间的某个节点</span><br><span class="line">        while(pCur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pCur-&gt;val == val)&#123;</span><br><span class="line">                pNode-&gt;<span class="keyword">next</span> = pCur-&gt;<span class="keyword">next</span>;</span><br><span class="line">                pCur = pCur-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pNode = pCur;</span><br><span class="line">                pCur = pCur-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q11：编写一个算法来判断一个数是不是“快乐数”。一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-646c19c262b72ce5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例"></p>
</li>
<li><p>A11:</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    bool isHappy(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1到9中只有1和7符合快乐数的定义！</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n==<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 其余不符合的情况，都不是快乐数!</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">sum</span> = isHappyCore(n);</span><br><span class="line">        <span class="keyword">return</span> isHappy(<span class="keyword">sum</span>);  <span class="comment">// 递归判断</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> isHappyCore(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="comment">// 下面的代码是取一个整数的各个位置上的数，具有一般性，记忆！</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">mod</span> = n % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">sum</span> += <span class="keyword">mod</span> * nod;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q12:给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-c020d4ec291b6d1c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除链表中的重复元素"></p>
</li>
<li><p>A12：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(!head || head-&gt;</span>next == nullptr)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* pNode = head;  <span class="comment">// 慢指针</span></span><br><span class="line">        L<span class="function"><span class="title">istNode</span>* pCur = head-&gt;</span>next;  <span class="comment">// 快指针</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(pNode-&gt;</span>next != nullptr)&#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(pNode-&gt;</span><span class="function"><span class="title">val</span> == pCur-&gt;</span>val)&#123;  <span class="comment">// 找到重复元素</span></span><br><span class="line">                <span class="function"><span class="title">if</span>(pCur-&gt;</span>next == nullptr)&#123;  <span class="comment">// 快指针后面若没有元素直接剔除</span></span><br><span class="line">                    <span class="function"><span class="title">pNode</span>-&gt;</span>next = nullptr;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 快指针后有元素</span></span><br><span class="line">                    <span class="function"><span class="title">pNode</span>-&gt;</span><span class="function"><span class="title">next</span> = pCur-&gt;</span>next;</span><br><span class="line">                    <span class="function"><span class="title">pCur</span> = pCur-&gt;</span>next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//元素不相等</span></span><br><span class="line">                <span class="function"><span class="title">pNode</span> = pNode-&gt;</span>next;</span><br><span class="line">                <span class="function"><span class="title">pCur</span> = pCur-&gt;</span>next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q13：给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-693ffa68c46c1060?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实例"></p>
</li>
<li><p>A13：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(NULL), <span class="built_in">right</span>(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p==nullptr &amp;&amp; q==nullptr)&#123;</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p != nullptr &amp;&amp; q != nullptr &amp;&amp; p-&gt;val == q-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p-&gt;<span class="built_in">left</span>, q-&gt;<span class="built_in">left</span>) &amp;&amp; isSameTree(p-&gt;<span class="built_in">right</span>, q-&gt;<span class="built_in">right</span>);  // 在左右子树上递归实现！</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q14：给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-4ef1c6c76672b65a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实例"></p>
</li>
<li><p>A14：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果是对称二叉树，则从左子树开始遍历与从右子树开始遍历时，遍历的结果都相同！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> isMirror(root,root);  <span class="comment">// 递归实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* root1, TreeNode* root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> || root2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (root1-&gt;val == root2-&gt;val) &amp;&amp; isMirror(root1-&gt;left, root2-&gt;right) &amp;&amp; isMirror(root1-&gt;right, root2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>A15：给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-ae22671c2543635a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="求众数"></p>
</li>
<li><p>Q15：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># nums.sort()</span></span><br><span class="line">        <span class="comment"># nums_len = len(nums)</span></span><br><span class="line">        <span class="comment"># return nums[nums_len // 2]   # 返回中间的数</span></span><br><span class="line">        candidate = <span class="literal">None</span>   <span class="comment"># 摩尔投票法</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == candidate:  <span class="comment"># 如果数组中的下一个元素num与candidate相同，就不会碰撞，此时count加1</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count &gt; <span class="number">0</span>:  <span class="comment"># 如果数组中的下一个元素num与candidate不同，就会发生碰撞，此时count减1，candidate维持上一次的数据</span></span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                candidate, count = num, <span class="number">1</span>  <span class="comment"># 第一次进入循环，candidate是第一个元素，count加1</span></span><br><span class="line">        <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure>
</li>
<li><p>A16：实现一个函数，将字符串中的每个空格替换成%20。例如，输入“hello world.”，则输出”hello%20world.”</p>
</li>
<li><p>Q16：解题思路：观察出空格替换后原始字符串变长的关系。在原始字符串的基础上进行修改，利用观察出的关系，使用两个指针从后向前移动将字符串从原始字符串复制到新的字符串中。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;string&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路：在原始字符串的基础上进行修改，注意原始字符串有足够的空间。使用两个指针，发现空格数量与原始字符串增加的长度关系！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">void</span> ReplaceSPace(<span class="keyword">char</span>* <span class="keyword">str</span>, <span class="keyword">int</span> len)&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">str</span> == nullptr || len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> original_len = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> number_blank = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 遍历原始字符串，统计空格的数目</span></span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">str</span>[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">           ++original_len;</span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">str</span>[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">               ++number_blank;</span><br><span class="line">           &#125;</span><br><span class="line">           ++i;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> new_len = original_len + <span class="number">2</span> * number_blank;</span><br><span class="line">       <span class="keyword">if</span>(new_len &gt; len)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> original_index = original_len;</span><br><span class="line">       <span class="keyword">int</span> new_index = new_len;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(original_index &gt;= <span class="number">0</span> &amp;&amp; new_index &gt; original_index)&#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">str</span>[original_index] == <span class="string">' '</span>)&#123;</span><br><span class="line">               <span class="keyword">str</span>[new_index--] = <span class="string">'0'</span>;</span><br><span class="line">               <span class="keyword">str</span>[new_index--] = <span class="string">'2'</span>;</span><br><span class="line">               <span class="keyword">str</span>[new_index--] = <span class="string">'%'</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">str</span>[new_index--] = <span class="keyword">str</span>[original_index];</span><br><span class="line">           &#125;</span><br><span class="line">           original_index--;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q17：单向链表的基础操作：<strong>在单向链表的末尾插入一个节点和找到第一个值为value的节点并将其删除</strong></p>
</li>
<li><p>A17：<strong>注意不要忘记释放在堆空间上申请的动态内存</strong></p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">    int m_pVal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表的末尾插入一个节点</span></span><br><span class="line">void AddNodeToTail(ListNode** pHead, int value)&#123;</span><br><span class="line">    <span class="comment">// 为新插入的节点分配空间</span></span><br><span class="line">    ListNode* pNew = new ListNode();</span><br><span class="line">    <span class="function"><span class="title">pNew</span>-&gt;</span>m_pNext = nullptr;</span><br><span class="line">    <span class="function"><span class="title">pNew</span>-&gt;</span>m_pVal = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pHead == nullptr)&#123;  <span class="comment">// 空链表</span></span><br><span class="line">        *pHead = pNew;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ListNode* pNode = *pHead;</span><br><span class="line">        <span class="function"><span class="title">while</span>(pNode-&gt;</span>m_pNext != nullptr)&#123;</span><br><span class="line">            <span class="function"><span class="title">pNode</span> = pNode-&gt;</span>m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">pNode</span>-&gt;</span>m_pNext = pNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个含某值value的节点并删除此节点</span></span><br><span class="line">void RemoveNode(ListNode** pHead, int value)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == nullptr || *pHead == nullptr)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* pToDeleted = nullptr;</span><br><span class="line">    <span class="function"><span class="title">if</span>((*pHead)-&gt;</span>m_pVal == value)&#123;  <span class="comment">// 头节点就是要删除的那个节点</span></span><br><span class="line">        pToDeleted = *pHead;</span><br><span class="line">        *<span class="function"><span class="title">pHead</span> = (*pHead)-&gt;</span>m_pNext;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                               <span class="comment">// 头节点不是要删除的那个节点</span></span><br><span class="line">        ListNode* pNode = *pHead;</span><br><span class="line">        <span class="function"><span class="title">while</span>(pNode-&gt;</span><span class="function"><span class="title">m_pNext</span> != nullptr &amp;&amp; pNode-&gt;</span><span class="function"><span class="title">m_pNext</span>-&gt;</span>m_pVal != value)&#123;   <span class="comment">// 头节点不是要删除的那个节点，后面的节点也没有出现value，则一直向后查找</span></span><br><span class="line">            <span class="function"><span class="title">pNode</span> = pNode-&gt;</span>m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span>(pNode-&gt;</span><span class="function"><span class="title">m_pNext</span> != nullptr &amp;&amp; pNode-&gt;</span><span class="function"><span class="title">m_pNext</span>-&gt;</span>m_pVal == value)&#123;   <span class="comment">//  头节点不是要删除的那个节点,后面的节点找到了value，则执行删除操作</span></span><br><span class="line">            <span class="function"><span class="title">pToDeleted</span> = pNode-&gt;</span>m_pNext;</span><br><span class="line">            <span class="function"><span class="title">pNode</span>-&gt;</span><span class="function"><span class="title">m_pNext</span> = pNode-&gt;</span><span class="function"><span class="title">m_pNext</span>-&gt;</span>m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pToDeleted != nullptr)&#123;</span><br><span class="line">        delete pToDeleted;</span><br><span class="line">        pToDeleted = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Q18：从尾到头反向打印出单向链表</p>
</li>
<li>A18：因为单向链表方向不能反过来，如果将指针反过来来实现改变单向链表的方向。但是，这会改变单向链表的数据结构，<strong>故在不改变数据结构的基础上，使用栈来实现</strong>！<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">    <span class="keyword">int</span> m_pVal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用栈这个数据结构，后进先出！因为单向链表方向不能反过来，如果将指针反过来，从而实现改变链表的方向，但是这会改变链表的数据结构，故在不改变数据结构的基础上，使用栈来实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* pHead)&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nodes;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        ListNode* pNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodes.push(pNode-&gt;m_pVal);</span><br><span class="line">            pNode = pNode-&gt;m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            result.push_back(nodes.top());</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络中的注意力机制总结及PyTorch实战</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93%E5%8F%8APyTorch%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h4 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h4><ul>
<li>当神经网络来处理大量的输入信息时，也可以借助人脑的注意力机制，只选择一些关键的信息输入进行处理，用来提高神经网络的效率。在目前的神经网络模型中，可以将max pooling和gating机制近似地看作是自下而上的基于显著性的注意力机制。此外，自上而下的聚焦式注意力也是一种有效的信息选择方法。例如：给定一篇很长的文章，然后就此文章的内容进行提问，提出的问题只和文章中某个段落中的一两个句子相关，其余都无关的。为了减小神经网络的计算代价，只需要把相关的片段挑选出来让后续的神经网络来处理，而不需要把所有文章内容都输入到神经网络中。</li>
</ul>
<h4 id="1-Attention机制基础知识"><a href="#1-Attention机制基础知识" class="headerlink" title="1.Attention机制基础知识"></a>1.Attention机制基础知识</h4><ul>
<li>用$X=\left[\mathbf{x}<em>{1}, \cdots, \mathbf{x}</em>{N}\right]$表示N组输入信息，其中每个向量$\mathbf{x}_{i}, i \in[1, N]$都表示一组输入信息。为了节省计算资源，不需要将所有的信息都输入到神经网络中，只需要从X中选择一些和任务相关的信息。注意力机制的计算可以分为两步：<ul>
<li>(1)在所有输入信息上计算注意力分布；</li>
<li>(2)根据注意力分布来计算输入信息的加权平均</li>
</ul>
</li>
<li>1.1 <strong>注意力分布</strong><ul>
<li>为了从N个输入向量$\left[\mathbf{x}<em>{1}, \cdots, \mathbf{x}</em>{N}\right]$中选择出与某个特定任务相关的信息，需要引入一个和任务相关的表示，称为<strong>查询向量q</strong>，并通过一个打分函数来计算每个输入向量和查询向量之间的相关性。</li>
<li>给定一个和任务相关的查询向量q，用注意力变量$z \in[1, N]$来表示被选择信息的索引位置，即z=i表示选择了第i个输入向量。为了方便计算，下面首先介绍<strong>Soft Attention注意力机制</strong>。首先计算在给定q和X下，选择第i个输入向量的概率$\alpha_{i}$<script type="math/tex; mode=display">
\begin{aligned} \alpha_{i} &=p(z=i | X, \mathbf{q}) \\ &=\operatorname{softmax}\left(s\left(\mathbf{x}_{i}, \mathbf{q}\right)\right) \\ &=\frac{\exp \left(s\left(\mathbf{x}_{i}, \mathbf{q}\right)\right)}{\sum_{j=1}^{N} \exp \left(s\left(\mathbf{x}_{j}, \mathbf{q}\right)\right)} \end{aligned}</script>其中$\alpha<em>{i}$称为注意力分布，$S\left(\mathbf{x}</em>{i}, \mathbf{q}\right)$是注意力打分函数，可以使用下面的几种方法来计算：<ul>
<li>加性模型       $s\left(\mathbf{x}<em>{i}, \mathbf{q}\right)=\mathbf{v}^{\mathrm{T}} \tanh \left(W \mathbf{x}</em>{i}+U \mathbf{q}\right)$</li>
<li>点积模型  $s\left(\mathbf{x}<em>{i}, \mathbf{q}\right)=\mathbf{x}</em>{i}^{\mathrm{T}} \mathbf{q}$</li>
<li>缩放点积模型 $s\left(\mathbf{x}<em>{i}, \mathbf{q}\right)=\frac{\mathbf{x}</em>{i}^{\mathrm{T}} \mathbf{q}}{\sqrt{d}}$</li>
<li>双线性模型  $s\left(\mathbf{x}<em>{i}, \mathbf{q}\right)=\mathbf{x}</em>{i}^{\mathrm{T}} W \mathbf{q}$</li>
</ul>
</li>
<li>上式中W、U、v是可学习的参数，d是输入向量的维度。理论上，加性模型和点积模型的复杂度差不多，但是点积模型在实现上可以更好地利用矩阵乘积，从而计算效率更高。但当输入向量的维度d比较高，点积模型的值通常有较大的方差，从而导致softmax函数的梯度比较小。因此，缩放点积模型可以很好地解决这个问题。双线性模型可以看做是一种泛化的点积模型。假设 $s\left(\mathbf{x}<em>{i}, \mathbf{q}\right)=\mathbf{x}</em>{i}^{\mathrm{T}} W \mathbf{q}$中$W=U^{\mathrm{T}} V$，则双线性模型可以写为$s\left(\mathbf{x}<em>{i}, \mathbf{q}\right)=\mathbf{x}</em>{i}^{\mathrm{T}} U^{\mathrm{T}} V \mathbf{q}=(U \mathbf{x})^{\mathrm{T}}(V \mathbf{q})$即分别对x和q进行线性变换后计算点积。相比点积模型，双线性模型在计算相似度时引入了非对称性。</li>
</ul>
</li>
<li><strong>1.2 加权平均</strong><ul>
<li>注意力分布$\alpha_{i}$可以解释为在给定任务相关的查询q时，第i个输入向量受注意的程度。下面采用一种<strong>软性</strong>的信息选择机制对输入信息进行汇总。<script type="math/tex; mode=display">
\begin{aligned} \operatorname{att}(X, \mathbf{q}) &=\sum_{i=1}^{N} \alpha_{i} \mathbf{x}_{i} \\ &=\mathbb{E}_{z \sim p(z | X, \mathbf{q})}\left[\mathbf{x}_{z}\right] \end{aligned}</script>上式称为<strong>软注意力机制(Soft Attention Mechanism)</strong>。下图给出了软注意力机制的示例图：<br>  <img src="https://upload-images.jianshu.io/upload_images/13407176-8f9c246814375066?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="软注意力机制"></li>
</ul>
</li>
</ul>
<h4 id="2-其他类型的注意力机制"><a href="#2-其他类型的注意力机制" class="headerlink" title="2.其他类型的注意力机制"></a>2.其他类型的注意力机制</h4><ul>
<li><strong>2.1 硬注意力机制</strong><ul>
<li>上面的公式$\mathbb{E}<em>{z \sim p(z | X, \mathbf{q})}\left[\mathbf{x}</em>{z}\right]$提到的是软注意力机制，其选择的信息是所有输入向量在注意力分布下的期望。此外还有一种注意力是只关注到某一个输入向量，叫做<strong>硬注意力机制(Hard Attention Mechanism)</strong>。硬注意力机制有两种方法可以实现：<ul>
<li>(1)选择最高概率的一个输入向量，即<script type="math/tex; mode=display">
\operatorname{att}(X, \mathbf{q})=\mathbf{x}_{j}</script>其中j为概率最大的输入向量的下标，即<script type="math/tex">\begin{array}{c}{j=\arg \max _{i=1}^{N} a_{i}}\end{array}</script></li>
<li>(2)通过在注意力分布上随机采样的方式实现</li>
</ul>
</li>
<li>硬注意力的一个缺点是基于最大采样或随机采样的方式来选择信息。因此最终的损失函数与注意力分布之间的函数关系不可导，因此无法使用反向传播算法进行训练。为了使用反向传播算法进行训练，一般使用软注意力机制。</li>
</ul>
</li>
<li><strong>2.2 键值对注意力</strong><ul>
<li>可以使用键值对格式来表示输入信息，其中键用来计算注意力分布$\alpha<em>{i}$，值用来计算聚合信息。用$(K, V)=\left[\left(\mathbf{k}</em>{1}, \mathbf{v}<em>{1}\right), \cdots,\left(\mathbf{k}</em>{N}, \mathbf{v}_{N}\right)\right]$来表示N组输入信息，给定任务相关的查询向量q时，注意力函数为：<script type="math/tex; mode=display">
\begin{aligned} \operatorname{att}((K, V), \mathbf{q}) &=\sum_{i=1}^{N} \alpha_{i} \mathbf{v}_{i} \\ &=\sum_{i=1}^{N} \frac{\exp \left(s\left(\mathbf{k}_{i}, \mathbf{q}\right)\right)}{\sum_{j} \exp \left(s\left(\mathbf{k}_{j}, \mathbf{q}\right)\right)} \mathbf{v}_{i} \end{aligned}</script>其中$s\left(\mathbf{k}_{i}, \mathbf{q}\right)$是打分函数，1.2节的图中给出了键值对注意力机制的示意图。当K=V时，键值对模式等于普通模式的注意力机制。</li>
</ul>
</li>
<li><strong>2.3 多头注意力</strong><ul>
<li>多头注意力(Multi-head Attention)是利用多个查询 $Q=\left[\mathbf{q}<em>{1}, \cdots, \mathbf{q}</em>{M}\right]$来平行计算从输入信息中选取多组信息。每个注意 力关注输入信息的不同部分。<script type="math/tex; mode=display">
\operatorname{att}((K, V), Q)=\operatorname{att}\left((K, V), \mathbf{q}_{1}\right) \oplus \cdots \oplus \operatorname{att}\left((K, V), \mathbf{q}_{M}\right)</script>其中⊕表示向量拼接。</li>
</ul>
</li>
<li><strong>2.4 自注意力模型(Self Attention)</strong><ul>
<li>当使用神经网络来处理一个变化长度的向量序列时，通过可以使用卷积网络或循环网络进行编码来得到一个相同长度的输出向量序列，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-0bf4dfb1fbcf218a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基于卷积神经网络和循环神经网络的变长序列编码"></li>
<li>基于卷积或循环网络的序列编码都是可以看做是一种局部的编码方式，只建模了输入信息的局部依赖关系。虽然循环网络理论上可以建立长距离依赖关系，但是由于信息传递的容量以及梯度消失问题，实际上也只能建立短距离依赖关系。</li>
<li>如果要建立输入序列之间的长距离依赖关系，可以使用以下两种方法：一种方法是增加网络的层数，通过一个深层网络来获取远距离的信息交互；另一种方法是使用全连接网络。全连接网络是一种非常直接的建模远距离依赖的模型，但是无法处理变长的输入序列。不同的输入长度，其连接权重的大小也是不同的。这时，就可以利用注意力机制来“动态”地生成不同连接的权重，这就是<strong>自注意力模型（Self-Attention Model）</strong>。</li>
<li>假设输入序列为$X=\left[\mathbf{x}<em>{1}, \cdots, \mathbf{x}</em>{N}\right] \in \mathbb{R}^{d<em>{1} \times N}$，输出序列为$H=\left[\mathbf{h}</em>{1}, \cdots, \mathbf{h}<em>{N}\right] \in \mathbb{R}^{d</em>{2} \times N}$，则可以通过线性变换得到三组向量序列：<script type="math/tex; mode=display">
\begin{aligned} Q &=W_{Q} X \in \mathbb{R}^{d_{3} \times N} \\ K &=W_{K} X \in \mathbb{R}^{d_{3} \times N} \\ V &=W_{V} X \in \mathbb{R}^{d_{2} \times N} \end{aligned}</script>其中，Q、K、V分别为查询向量序列，键向量序列、值向量序列，$W<em>{Q} \in \mathbb{R}^{d</em>{3} \times d<em>{1}}$、$W</em>{K} \in \mathbb{R}^{d<em>{3} \times d</em>{1}}$、$W<em>{V} \in \mathbb{R}^{d</em>{2} \times d<em>{1}}$分别表示可学习的参数矩阵。根据$\operatorname{att}((K, V), \mathbf{q})=\sum</em>{i=1}^{N} \alpha<em>{i} \mathbf{v}</em>{i}$，可以得到输出向量$\mathbf{h}<em>{i}$：<br>$\mathbf{h}</em>{i}=\operatorname{att}\left((K, V), \mathbf{q}<em>{i}\right)=\sum</em>{j=1}^{N} \alpha<em>{i j} \mathbf{v}</em>{j}=\sum<em>{j=1}^{N} \operatorname{softmax}\left(s\left(\mathbf{k}</em>{j}, \mathbf{q}<em>{i}\right)\right) \mathbf{v}</em>{j}$<br>其中，$i, j \in[1, N]$为输出和输入向量序列的位置，连接权重$\alpha_{i j}$由注意力机制动态生成。<br>如果使用缩放点积来作为注意力打分函数，输出向量序列可以写为：<script type="math/tex; mode=display">
H=V \operatorname{softmax}\left(\frac{K^{\mathrm{T}} Q}{\sqrt{d_{3}}}\right)</script>其中softmax函数为按列进行归一化的函数。</li>
<li>下图给出了全连接模型和自注意力模型的对比，其中实线表示可学习的权重，虚线表示动态生成的权重。由于自注意力模型的权重是动态生成的，因此可以处理变长的信息序列。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-510d0c5391bc8ed5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="全连接模型与自注意力模型"></li>
<li>自注意力模型可以作为神经网络中的一层来使用，既可以用来替换卷积层和循环层，也可以和它们一起交替使用(例如输入向量X可以是卷积层或循环层的输出)。自注意模型计算的权重$\alpha<em>{i j}$只依赖于$\mathbf{q}</em>{i}$和$\mathbf{k}_{j}$的相关性，从而忽略了输入信息的位置信息。因此，在单独使用时，自注意模型一般需要加入位置编码信息来进行修正。</li>
</ul>
</li>
</ul>
<h4 id="3-实战———以Seq2Seq网络进行法语到英语的翻译为例进行说明"><a href="#3-实战———以Seq2Seq网络进行法语到英语的翻译为例进行说明" class="headerlink" title="3.实战———以Seq2Seq网络进行法语到英语的翻译为例进行说明"></a>3.实战———以Seq2Seq网络进行法语到英语的翻译为例进行说明</h4><ul>
<li>利用机器翻译中的经典网络结构Seq2Seq(具体结构见参考资料中的文献)，其中包含Encoder编码网络将输入的法语句子进行编码，然后输入到Decoder解码网络进行解码，输出期望得到的英文句子。整个网络的结构如下：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-91259671c5a6e418?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Seq2Seq网络结构"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-2df3b1f7ccdc066e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Encoder部分"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-faefaa607c75a828?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Decoder部分"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-310f3d39f7a9fc4d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意力权重可视化"></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-be8ea154c2fc28a9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加坐标轴的注意力权重可视化1"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-4f8c1d8d22ea5719?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加坐标轴的注意力权重可视化2"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-31b166d4bcdeea3f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加坐标轴的注意力权重可视化3"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/13407176-aac78b93c36adfa7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加坐标轴的注意力权重可视化4"><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals, print_function, division</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> open</span><br><span class="line"><span class="keyword">import</span> unicodedata</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将法语翻译成英语</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SOS_token = <span class="number">0</span>  <span class="comment"># 开始的标注</span></span><br><span class="line">EOS_token = <span class="number">1</span>  <span class="comment"># 结束的标注</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 辅助类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lang</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.word2index = &#123;&#125;   <span class="comment"># word----&gt;index</span></span><br><span class="line">        self.index2word = &#123;<span class="number">0</span>: <span class="string">"SOS"</span>, <span class="number">1</span>: <span class="string">"EOS"</span>&#125;  <span class="comment"># index----&gt;word</span></span><br><span class="line">        self.word2count = &#123;&#125;   <span class="comment"># 稍后用来替换稀有单词，统计每个单词出现的次数</span></span><br><span class="line">        self.n_words = <span class="number">2</span>  <span class="comment"># 统计单词总数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addSentence</span><span class="params">(self, sentence)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> sentence.split(<span class="string">" "</span>):</span><br><span class="line">            self.addWord(word)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addWord</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> self.word2index:</span><br><span class="line">            self.word2index[word] = self.n_words</span><br><span class="line">            self.word2count[word] = <span class="number">1</span></span><br><span class="line">            self.index2word[self.n_words] = word</span><br><span class="line">            self.n_words += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.word2count[word] += <span class="number">1</span></span><br><span class="line"> <span class="comment"># Turn a Unicode string to plain ASCII</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unicodeToAscii</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(</span><br><span class="line">        c <span class="keyword">for</span> c <span class="keyword">in</span> unicodedata.normalize(<span class="string">'NFD'</span>, s)</span><br><span class="line">        <span class="keyword">if</span> unicodedata.category(c) != <span class="string">'Mn'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小写，修剪和删除非字母字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalizeString</span><span class="params">(s)</span>:</span></span><br><span class="line">    s = unicodeToAscii(s.lower().strip())</span><br><span class="line">    s = re.sub(<span class="string">r"([.!?])"</span>, <span class="string">r" \1"</span>, s)</span><br><span class="line">    s = re.sub(<span class="string">r"[^a-zA-Z.!?]+"</span>, <span class="string">r" "</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="comment"># 加载文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readLangs</span><span class="params">(lang1, lang2, reverse=False)</span>:</span></span><br><span class="line">    print(<span class="string">"Reading lines......."</span>)</span><br><span class="line">    <span class="comment"># 读取文件并进行划分成行</span></span><br><span class="line">    lines = open(<span class="string">r"E://DeepLearning//jupyter_code//dataset//corpus//translation_data//%s-%s.txt"</span> % (lang1, lang2), encoding=<span class="string">'utf-8'</span>).\</span><br><span class="line">                read().strip().split(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将每行切成一组pairs</span></span><br><span class="line">    pairs = [[normalizeString(s) <span class="keyword">for</span> s <span class="keyword">in</span> l.split(<span class="string">"\t"</span>)] <span class="keyword">for</span> l <span class="keyword">in</span> lines]</span><br><span class="line">    <span class="comment"># 将其他语言翻译成英语</span></span><br><span class="line">    <span class="keyword">if</span> reverse:</span><br><span class="line">        pairs = [list(reversed(p)) <span class="keyword">for</span> p <span class="keyword">in</span> pairs]</span><br><span class="line">        input_lang = Lang(lang2)</span><br><span class="line">        output_lang = Lang(lang1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        input_lang = Lang(lang1)</span><br><span class="line">        output_lang = Lang(lang2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> input_lang, output_lang, pairs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于有很多例句，为了能快速训练，我们会将数据集修剪成相对简短的句子。这里最大长度是10个单词（包括结束标点符号）</span></span><br><span class="line"></span><br><span class="line">MAX_LENGTH = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 英语前缀</span></span><br><span class="line">eng_prefixes = (</span><br><span class="line">    <span class="string">"i am "</span>, <span class="string">"i m "</span>,</span><br><span class="line">    <span class="string">"he is"</span>, <span class="string">"he s "</span>,</span><br><span class="line">    <span class="string">"she is"</span>, <span class="string">"she s "</span>,</span><br><span class="line">    <span class="string">"you are"</span>, <span class="string">"you re "</span>,</span><br><span class="line">    <span class="string">"we are"</span>, <span class="string">"we re "</span>,</span><br><span class="line">    <span class="string">"they are"</span>, <span class="string">"they re "</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filterPair</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(p[<span class="number">0</span>].split(<span class="string">' '</span>)) &lt; MAX_LENGTH <span class="keyword">and</span> \</span><br><span class="line">        len(p[<span class="number">1</span>].split(<span class="string">' '</span>)) &lt; MAX_LENGTH <span class="keyword">and</span> \</span><br><span class="line">        p[<span class="number">1</span>].startswith(eng_prefixes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filterPairs</span><span class="params">(pairs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [pair <span class="keyword">for</span> pair <span class="keyword">in</span> pairs <span class="keyword">if</span> filterPair(pair)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepareData</span><span class="params">(lang1, lang2, reverse=False)</span>:</span></span><br><span class="line">    input_lang, output_lang, pairs = readLangs(lang1, lang2, reverse)</span><br><span class="line">    print(<span class="string">"Read %s sentence pairs"</span> % len(pairs))</span><br><span class="line">    pairs = filterPairs(pairs)</span><br><span class="line">    print(<span class="string">"Trimmed to %s sentence pairs"</span> % len(pairs))</span><br><span class="line">    print(<span class="string">"Counting words..."</span>)</span><br><span class="line">    <span class="keyword">for</span> pair <span class="keyword">in</span> pairs:</span><br><span class="line">        input_lang.addSentence(pair[<span class="number">0</span>])</span><br><span class="line">        output_lang.addSentence(pair[<span class="number">1</span>])</span><br><span class="line">    print(<span class="string">"Counted words:"</span>)</span><br><span class="line">    print(input_lang.name, input_lang.n_words)</span><br><span class="line">    print(output_lang.name, output_lang.n_words)</span><br><span class="line">    <span class="keyword">return</span> input_lang, output_lang, pairs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_lang, output_lang, pairs = prepareData(<span class="string">'eng'</span>, <span class="string">'fra'</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># print("pairs:\n", pairs)  pairs = [法语,英语]</span></span><br><span class="line">print(random.choice(pairs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Encoder 部分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncoderRNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, hidden_size)</span>:</span></span><br><span class="line">        super(EncoderRNN, self).__init__()</span><br><span class="line">        self.hidden_size = hidden_size   <span class="comment"># 隐藏状态a的大小</span></span><br><span class="line"></span><br><span class="line">        self.embedding = nn.Embedding(input_size, hidden_size)  <span class="comment"># 词嵌入层</span></span><br><span class="line">        self.gru = nn.GRU(hidden_size, hidden_size)   <span class="comment"># 多层的GRU</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input, hidden)</span>:</span></span><br><span class="line">        embedded = self.embedding(input).view(<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">        output = embedded</span><br><span class="line">        output, hidden = self.gru(output, hidden)</span><br><span class="line">        <span class="keyword">return</span> output, hidden</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initHidden</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> torch.zeros(<span class="number">1</span>,<span class="number">1</span>, self.hidden_size, device=device)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Decoder部分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoderRNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hidden_size, output_size)</span>:</span></span><br><span class="line">        super(DecoderRNN, self).__init__()</span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line"></span><br><span class="line">        self.embedding = nn.Embedding(output_size, hidden_size)</span><br><span class="line">        self.gru = nn.GRU(hidden_size, hidden_size)</span><br><span class="line">        self.out = nn.Linear(hidden_size, output_size)</span><br><span class="line">        self.softmax = nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input, hidden)</span>:</span></span><br><span class="line">        output = self.embedding(input).view(<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">        output = F.relu(output)</span><br><span class="line">        output, hidden = self.gru(output, hidden)</span><br><span class="line">        output = self.softmax(self.out(output[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">return</span> output, hidden</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initHidden</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> torch.zeros(<span class="number">1</span>,<span class="number">1</span>,self.hidden_size, device=device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Attention 部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttnDecoderRNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hidden_size, output_size, dropout_p=<span class="number">0.1</span>, max_length=MAX_LENGTH)</span>:</span></span><br><span class="line">        super(AttnDecoderRNN, self).__init__()</span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.output_size = output_size</span><br><span class="line">        self.dropout_p = dropout_p</span><br><span class="line">        self.max_length = max_length</span><br><span class="line"></span><br><span class="line">        self.embedding = nn.Embedding(self.output_size, self.hidden_size)</span><br><span class="line">        self.attn = nn.Linear(self.hidden_size*<span class="number">2</span>, self.max_length)</span><br><span class="line">        self.attn_combine = nn.Linear(self.hidden_size*<span class="number">2</span>, self.hidden_size)</span><br><span class="line">        self.dropout = nn.Dropout(self.dropout_p)</span><br><span class="line">        self.gru = nn.GRU(self.hidden_size, self.hidden_size)</span><br><span class="line">        self.out = nn.Linear(self.hidden_size, self.output_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input, hidden, encoder_outputs)</span>:</span></span><br><span class="line">        embedded = self.embedding(input).view(<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">        embedded = self.dropout(embedded)</span><br><span class="line"></span><br><span class="line">        attn_weights = F.softmax(self.attn(torch.cat((embedded[<span class="number">0</span>], hidden[<span class="number">0</span>]), <span class="number">1</span>)), dim=<span class="number">1</span>)  <span class="comment"># 注意力权重</span></span><br><span class="line">        attn_applied = torch.bmm(attn_weights.unsqueeze(<span class="number">0</span>), encoder_outputs.unsqueeze(<span class="number">0</span>))  <span class="comment"># 两个batch之间的矩阵乘法</span></span><br><span class="line"></span><br><span class="line">        output = torch.cat((embedded[<span class="number">0</span>], attn_applied[<span class="number">0</span>]), <span class="number">1</span>)</span><br><span class="line">        output = self.attn_combine(output).unsqueeze(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        output = F.relu(output)</span><br><span class="line">        output, hidden = self.gru(output, hidden)</span><br><span class="line"></span><br><span class="line">        output = F.log_softmax(self.out(output[<span class="number">0</span>]), dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output, hidden, attn_weights</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 隐状态初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initHidden</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> torch.zeros(<span class="number">1</span>, <span class="number">1</span>, self.hidden_size, device=device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备训练数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">indexesFromSentence</span><span class="params">(lang, sentence)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [lang.word2index[word] <span class="keyword">for</span> word <span class="keyword">in</span> sentence.split(<span class="string">" "</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tensorFromSentence</span><span class="params">(lang, sentence)</span>:</span></span><br><span class="line">    indexes = indexesFromSentence(lang, sentence)</span><br><span class="line">    indexes.append(EOS_token)   <span class="comment"># EOS作为encoder编码器网络的结束标志，  SOS作为Decoder解码器网络的开始标志</span></span><br><span class="line">    <span class="keyword">return</span> torch.tensor(indexes, dtype=torch.long, device=device).view(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tensorsFromPair</span><span class="params">(pair)</span>:</span></span><br><span class="line">    input_tensor = tensorFromSentence(input_lang, pair[<span class="number">0</span>])   <span class="comment"># pair[0]是法语</span></span><br><span class="line">    targe_tensor = tensorFromSentence(output_lang, pair[<span class="number">1</span>])  <span class="comment"># pair[1]是英语</span></span><br><span class="line">    <span class="keyword">return</span> (input_tensor, targe_tensor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># “tearcher_forcing_ratio将上一时刻的真实目标输出当作下一个时刻的Encoder网络的输入，而不是使用Encoder网络的上一时刻的预测输出作为下一时刻的输入。</span></span><br><span class="line">tearcher_forcing_ratio = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(input_tensor, target_tensor, encoder, decoder, encoder_optimizer, decoder_optimizer, criterion, max_length=MAX_LENGTH)</span>:</span></span><br><span class="line">    encoder_hidden = encoder.initHidden()</span><br><span class="line"></span><br><span class="line">    encoder_optimizer.zero_grad()</span><br><span class="line">    decoder_optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    input_length = input_tensor.size(<span class="number">0</span>)</span><br><span class="line">    target_length = target_tensor.size(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    encoder_outputs = torch.zeros(max_length, encoder.hidden_size, device=device)</span><br><span class="line"></span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># encoder部分</span></span><br><span class="line">    <span class="keyword">for</span> ei <span class="keyword">in</span> range(input_length):</span><br><span class="line">        encoder_output, encoder_hidden = encoder(input_tensor[ei], encoder_hidden)</span><br><span class="line">        encoder_outputs[ei] = encoder_output[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># decoder部分</span></span><br><span class="line">    decoder_input = torch.tensor([[SOS_token]], device=device)</span><br><span class="line"></span><br><span class="line">    decoder_hidden = encoder_hidden</span><br><span class="line"></span><br><span class="line">    use_teacher_foring = <span class="literal">True</span> <span class="keyword">if</span> random.random() &lt; tearcher_forcing_ratio <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># using teacher forcing</span></span><br><span class="line">    <span class="keyword">if</span> use_teacher_foring:</span><br><span class="line">        <span class="keyword">for</span> di <span class="keyword">in</span> range(target_length):</span><br><span class="line">            decoder_output, decoder_hidden, decoder_attention = decoder(decoder_input, decoder_hidden, encoder_outputs)</span><br><span class="line">            loss += criterion(decoder_output, target_tensor[di])</span><br><span class="line">            decoder_input = target_tensor[di]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不使用teacher forcing,使用上一时刻的输出作为下一时刻的输入</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> di <span class="keyword">in</span> range(target_length):</span><br><span class="line">            decoder_output, decoder_hidden, decoder_attention = decoder(decoder_input, decoder_hidden, encoder_outputs)</span><br><span class="line">            topv, topi = decoder_output.topk(<span class="number">1</span>)</span><br><span class="line">            decoder_input = topi.squeeze().detach()</span><br><span class="line"></span><br><span class="line">            loss += criterion(decoder_output, target_tensor[di])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> decoder_input.item() == EOS_token:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    encoder_optimizer.step()</span><br><span class="line">    decoder_optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loss.item() / target_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 辅助函数------记录时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asMinutes</span><span class="params">(s)</span>:</span></span><br><span class="line">    m = math.floor(s / <span class="number">60</span>)</span><br><span class="line">    s -= m * <span class="number">60</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"%dm %ds"</span> % (m, s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeSince</span><span class="params">(since, percent)</span>:</span></span><br><span class="line">    now = time.time()</span><br><span class="line">    s = now - since</span><br><span class="line">    es = s / (percent)</span><br><span class="line">    rs = es - s</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"%s (- %s)"</span> % (asMinutes(s), asMinutes(rs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个训练过程如下：</span></span><br><span class="line"> <span class="comment"># 开启定时器</span></span><br><span class="line"> <span class="comment"># 初始化优化器和loss函数</span></span><br><span class="line"> <span class="comment"># 创建training pairs</span></span><br><span class="line"> <span class="comment"># 开始训练并绘图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainIters</span><span class="params">(encoder, decoder, n_iters, print_every=<span class="number">1000</span>, plot_every=<span class="number">100</span>, learning_rate=<span class="number">0.01</span>)</span>:</span></span><br><span class="line">    start = time.time()  <span class="comment"># 开启定时器</span></span><br><span class="line">    plot_losses = []</span><br><span class="line">    print_loss_total = <span class="number">0</span>  <span class="comment"># Reset every print_every</span></span><br><span class="line">    plot_loss_total = <span class="number">0</span>  <span class="comment"># Reset every plot_every</span></span><br><span class="line"></span><br><span class="line">    encoder_optimizer = optim.SGD(encoder.parameters(), lr=learning_rate)  <span class="comment"># 定义优化算法</span></span><br><span class="line">    decoder_optimizer = optim.SGD(decoder.parameters(), lr=learning_rate)</span><br><span class="line">    training_pairs = [tensorsFromPair(random.choice(pairs))  <span class="comment"># 创建training pairs</span></span><br><span class="line">                      <span class="keyword">for</span> i <span class="keyword">in</span> range(n_iters)]</span><br><span class="line">    criterion = nn.NLLLoss()  <span class="comment"># 定义损失函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> iter <span class="keyword">in</span> range(<span class="number">1</span>, n_iters + <span class="number">1</span>):</span><br><span class="line">        training_pair = training_pairs[iter - <span class="number">1</span>]</span><br><span class="line">        input_tensor = training_pair[<span class="number">0</span>]</span><br><span class="line">        target_tensor = training_pair[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        loss = train(input_tensor, target_tensor, encoder,</span><br><span class="line">                     decoder, encoder_optimizer, decoder_optimizer, criterion)</span><br><span class="line">        print_loss_total += loss</span><br><span class="line">        plot_loss_total += loss</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> iter % print_every == <span class="number">0</span>:</span><br><span class="line">            print_loss_avg = print_loss_total / print_every</span><br><span class="line">            print_loss_total = <span class="number">0</span></span><br><span class="line">            print(<span class="string">'%s (%d %d%%) %.4f'</span> % (timeSince(start, iter / n_iters),</span><br><span class="line">                                         iter, iter / n_iters * <span class="number">100</span>, print_loss_avg))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> iter % plot_every == <span class="number">0</span>:</span><br><span class="line">            plot_loss_avg = plot_loss_total / plot_every</span><br><span class="line">            plot_losses.append(plot_loss_avg)</span><br><span class="line">            plot_loss_total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    showPlot(plot_losses)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制loss曲线</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.switch_backend(<span class="string">'agg'</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.ticker <span class="keyword">as</span> ticker</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showPlot</span><span class="params">(points)</span>:</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    fig, ax = plt.subplots()</span><br><span class="line">    <span class="comment"># this locator puts ticks at regular intervals</span></span><br><span class="line">    loc = ticker.MultipleLocator(base=<span class="number">0.2</span>)</span><br><span class="line">    ax.yaxis.set_major_locator(loc)</span><br><span class="line">    plt.plot(points)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试阶段--------测试阶段整体与训练阶段类似，但是测试阶段，不用给出target_tensor,只是将decoder网络上一时刻的预测值作为下一时刻的输入值</span></span><br><span class="line"><span class="comment"># 当预测值是EOS时，则停止预测</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(encoder, decoder, sentence, max_length = MAX_LENGTH)</span>:</span></span><br><span class="line">     <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        input_tensor = tensorFromSentence(input_lang, sentence)</span><br><span class="line">        input_length = input_tensor.size()[<span class="number">0</span>]</span><br><span class="line">        encoder_hidden = encoder.initHidden()</span><br><span class="line"></span><br><span class="line">        encoder_outputs = torch.zeros(max_length, encoder.hidden_size, device=device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># encoder部分</span></span><br><span class="line">        <span class="keyword">for</span> ei <span class="keyword">in</span> range(input_length):</span><br><span class="line">            encoder_output, encoder_hidden = encoder(input_tensor[ei],</span><br><span class="line">                                                     encoder_hidden)</span><br><span class="line">            encoder_outputs[ei] += encoder_output[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        decoder_input = torch.tensor([[SOS_token]], device=device)  <span class="comment"># SOS</span></span><br><span class="line"></span><br><span class="line">        decoder_hidden = encoder_hidden</span><br><span class="line"></span><br><span class="line">        decoded_words = []</span><br><span class="line">        decoder_attentions = torch.zeros(max_length, max_length)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># decoder部分</span></span><br><span class="line">        <span class="keyword">for</span> di <span class="keyword">in</span> range(max_length):</span><br><span class="line">            decoder_output, decoder_hidden, decoder_attention = decoder(</span><br><span class="line">                decoder_input, decoder_hidden, encoder_outputs)</span><br><span class="line">            decoder_attentions[di] = decoder_attention.data</span><br><span class="line">            topv, topi = decoder_output.data.topk(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> topi.item() == EOS_token:  <span class="comment"># 结束时的条件</span></span><br><span class="line">                decoded_words.append(<span class="string">'&lt;EOS&gt;'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                decoded_words.append(output_lang.index2word[topi.item()])</span><br><span class="line"></span><br><span class="line">            decoder_input = topi.squeeze().detach()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decoded_words, decoder_attentions[:di + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机地从训练集中选择pairs,然后在测试集上进行评估</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluateRandomly</span><span class="params">(encoder, decoder, n=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        pair = random.choice(pairs)</span><br><span class="line">        print(<span class="string">'输入:&gt;'</span>, pair[<span class="number">0</span>])</span><br><span class="line">        print(<span class="string">'目标:='</span>, pair[<span class="number">1</span>])</span><br><span class="line">        output_words, attentions = evaluate(encoder, decoder, pair[<span class="number">0</span>])</span><br><span class="line">        output_sentence = <span class="string">' '</span>.join(output_words)</span><br><span class="line">        print(<span class="string">'预测:&lt;'</span>, output_sentence)</span><br><span class="line">        print(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正式训练开始运行</span></span><br><span class="line"></span><br><span class="line">hidden_size = <span class="number">256</span></span><br><span class="line">encoder1 = EncoderRNN(input_lang.n_words, hidden_size).to(device)</span><br><span class="line">attn_decoder1 = AttnDecoderRNN(hidden_size, output_lang.n_words, dropout_p=<span class="number">0.1</span>).to(device)</span><br><span class="line"></span><br><span class="line">trainIters(encoder1, attn_decoder1, <span class="number">75000</span>, print_every=<span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line">evaluateRandomly(encoder1, attn_decoder1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意力可视化</span></span><br><span class="line"></span><br><span class="line">output_words, attentions = evaluate(</span><br><span class="line">    encoder1, attn_decoder1, <span class="string">"je suis trop froid ."</span>)</span><br><span class="line">plt.matshow(attentions.numpy());</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加坐标轴，更加清楚的可视化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showAttention</span><span class="params">(input_sentence, output_words, attentions)</span>:</span></span><br><span class="line">    <span class="comment"># Set up figure with colorbar</span></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    cax = ax.matshow(attentions.numpy(), cmap=<span class="string">'bone'</span>)</span><br><span class="line">    fig.colorbar(cax)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set up axes</span></span><br><span class="line">    ax.set_xticklabels([<span class="string">''</span>] + input_sentence.split(<span class="string">' '</span>) +</span><br><span class="line">                       [<span class="string">'&lt;EOS&gt;'</span>], rotation=<span class="number">90</span>)</span><br><span class="line">    ax.set_yticklabels([<span class="string">''</span>] + output_words)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Show label at every tick</span></span><br><span class="line">    ax.xaxis.set_major_locator(ticker.MultipleLocator(<span class="number">1</span>))</span><br><span class="line">    ax.yaxis.set_major_locator(ticker.MultipleLocator(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluateAndShowAttention</span><span class="params">(input_sentence)</span>:</span></span><br><span class="line">    output_words, attentions = evaluate(</span><br><span class="line">        encoder1, attn_decoder1, input_sentence)</span><br><span class="line">    print(<span class="string">'input ='</span>, input_sentence)</span><br><span class="line">    print(<span class="string">'output ='</span>, <span class="string">' '</span>.join(output_words))</span><br><span class="line">    showAttention(input_sentence, output_words, attentions)</span><br></pre></td></tr></table></figure></p>
<h4 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4.参考资料"></a>4.参考资料</h4><ul>
<li><a href="https://nndl.github.io/" target="_blank" rel="noopener">邱锡鹏：《神经网络与深度学习》</a></li>
<li><a href="https://pytorch.org/tutorials/intermediate/seq2seq_translation_tutorial.html" target="_blank" rel="noopener">Translation with a Sequence to Sequence Network and Attention</a></li>
<li><a href="https://pytorch-cn.readthedocs.io/zh/latest/" target="_blank" rel="noopener">PyTorch中文文档</a></li>
<li><a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a></li>
<li><a href="https://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">Sequence to Sequence Learning with Neural Networks</a></li>
<li><a href="https://arxiv.org/abs/1409.0473" target="_blank" rel="noopener">Neural Machine Translation by Jointly Learning to Align and Translate</a></li>
<li><a href="https://arxiv.org/abs/1506.05869" target="_blank" rel="noopener">A Neural Conversational Model</a></li>
<li><a href="https://github.com/cdlwhm1217096231/Machine_Learning/tree/master/%E4%B8%AD%E6%96%87NLP%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/05_Attention_Mechanism" target="_blank" rel="noopener">本文中的代码及数据下载地址</a></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>NLP</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>轻松优化Jupyter Notebook:技巧、诀窍、魔法</title>
    <url>/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E8%BD%BB%E6%9D%BE%E4%BC%98%E5%8C%96Jupyter-Notebook-%E6%8A%80%E5%B7%A7%E3%80%81%E8%AF%80%E7%AA%8D%E3%80%81%E9%AD%94%E6%B3%95/</url>
    <content><![CDATA[<h4 id="0-更换主题"><a href="#0-更换主题" class="headerlink" title="0.更换主题"></a>0.更换主题</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install </span><span class="keyword">jupyterthemes</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"># </span>使用暗黑主题</span><br><span class="line"><span class="keyword">jt </span>-t chesterish</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复默认主题</span></span><br><span class="line"><span class="keyword">jt </span>-r</span><br></pre></td></tr></table></figure>
<h4 id="1-常用技巧"><a href="#1-常用技巧" class="headerlink" title="1.常用技巧"></a>1.常用技巧</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl + <span class="built_in">shift</span> + p  <span class="comment"># 查看所有的快捷键按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在开头加上感叹号，则可以运行bash命令，例如： !pip install numpy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在某个函数的末尾加上分号来随时限制函数在最后一行代码上的输出</span></span><br><span class="line"></span><br><span class="line">ctr + /   <span class="comment"># 用来注释或者取消代码</span></span><br></pre></td></tr></table></figure>
<h4 id="2-MarkDown模式"><a href="#2-MarkDown模式" class="headerlink" title="2.MarkDown模式"></a>2.MarkDown模式</h4><p>在markdown模式下支持latex 例如：$p(A \mid B) = \frac{p(B \mid A)p(A)}{p(B)}$</p>
<h4 id="3-输出打印"><a href="#3-输出打印" class="headerlink" title="3.输出打印"></a>3.输出打印</h4><figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印出所有输出</span></span><br><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印最后一行输出</span></span><br><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"last_expr"</span></span><br></pre></td></tr></table></figure>
<h4 id="4-安装扩展插件"><a href="#4-安装扩展插件" class="headerlink" title="4.安装扩展插件"></a>4.安装扩展插件</h4><ul>
<li><p>安装Nbextensions</p>
<ul>
<li><p>pip安装</p>
  <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install </span><span class="keyword">jupyter_contrib_nbextensions</span></span><br><span class="line"><span class="keyword">jupyter </span>contrib nbextension <span class="keyword">install </span>--user</span><br></pre></td></tr></table></figure>
</li>
<li><p>Anaconda安装</p>
  <figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">conda <span class="keyword">install </span>-c conda-forge <span class="keyword">jupyter_contrib_nbextensions</span></span><br><span class="line"><span class="keyword">conda </span><span class="keyword">install </span>-c conda-forge <span class="keyword">jupyter_nbextensions_configurator</span></span><br><span class="line"><span class="keyword">jupyter </span>contrib nbextension <span class="keyword">install </span>--user</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="5-魔法函数"><a href="#5-魔法函数" class="headerlink" title="5.魔法函数"></a>5.魔法函数</h4><ul>
<li>line magic在一条线上使用,以%开头</li>
<li>cell magic    # 在整个cell上使用，以%%开头<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">lsmagic</span></span>   # 查看所有的魔法函数</span><br><span class="line"><span class="tag">%<span class="selector-tag">env</span></span>    # 查看环境变量</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="6-文件的导入与导出"><a href="#6-文件的导入与导出" class="headerlink" title="6.文件的导入与导出"></a>6.文件的导入与导出</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># 在cell中插入外部的<span class="keyword">py</span>文件</span><br><span class="line">%load basic_import.<span class="keyword">py</span></span><br><span class="line"></span><br><span class="line"># 将cell中的代码导出到一个<span class="keyword">py</span>文件中</span><br><span class="line">%%<span class="built_in">writefile</span> thiscode.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>
<h4 id="7-运行与查看导入的文件"><a href="#7-运行与查看导入的文件" class="headerlink" title="7.运行与查看导入的文件"></a>7.运行与查看导入的文件</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行py文件中的内容</span></span><br><span class="line">%<span class="keyword">run</span><span class="bash"> basic_import.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不确定脚本文件中的内容，可以随时显示它</span></span><br><span class="line">%pycat basic_import.py</span><br></pre></td></tr></table></figure>
<h4 id="8-设置自动保存"><a href="#8-设置自动保存" class="headerlink" title="8.设置自动保存"></a>8.设置自动保存</h4><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span>autosave <span class="number">60</span>  <span class="attr"># 每60</span>秒自动保存</span><br></pre></td></tr></table></figure>
<h4 id="9-显示图像"><a href="#9-显示图像" class="headerlink" title="9.显示图像"></a>9.显示图像</h4><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">matplotlib</span></span> inline</span><br></pre></td></tr></table></figure>
<h4 id="10-定时器"><a href="#10-定时器" class="headerlink" title="10.定时器"></a>10.定时器</h4><ul>
<li>%timeit和%%time放在需要指定的语句前，例如：%%time print(“hello python!”)<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">%%<span class="keyword">time</span>       <span class="comment"># 计算给出cell中的代码运行一次所花费的时间</span></span><br><span class="line">%timeit      <span class="comment"># 多次运行指定的代码计算平均值，使用的是python中的timeit模块</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="11-运行其他语言的代码"><a href="#11-运行其他语言的代码" class="headerlink" title="11.运行其他语言的代码"></a>11.运行其他语言的代码</h4><ul>
<li>在不同放入kernel中运行代码，在kernel的开头加上下面对应语言的语句才可以使用！<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">%%bash</span><br><span class="line">%%HTML</span><br><span class="line">%%<span class="keyword">python</span></span><br><span class="line">%%python2</span><br><span class="line">%%python3</span><br><span class="line">%%ruby</span><br><span class="line">%%perl</span><br><span class="line">%%capture</span><br><span class="line">%%javascript</span><br><span class="line">%%js</span><br><span class="line">%%latex</span><br><span class="line">%%markdown</span><br><span class="line">%%pypy</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="12-查看变量"><a href="#12-查看变量" class="headerlink" title="12.查看变量"></a>12.查看变量</h4><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找全局范围内的所有变量</span></span><br><span class="line">%who</span><br><span class="line">%who str  <span class="comment"># 只查看str类型的变量</span></span><br><span class="line"><span class="comment"># 查看执行某个函数花费的实际</span></span><br><span class="line">%prun 语句名</span><br><span class="line"><span class="comment"># 使用pdb进行调试</span></span><br><span class="line">必须在每个cell的开头，加上%pdb</span><br></pre></td></tr></table></figure>
<h4 id="13-提供高分辨率的图"><a href="#13-提供高分辨率的图" class="headerlink" title="13.提供高分辨率的图"></a>13.提供高分辨率的图</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">%<span class="built_in">config</span> InlineBackend.figure_format = <span class="string">'retina'</span></span><br></pre></td></tr></table></figure>
<h4 id="14-选择执行某些cell"><a href="#14-选择执行某些cell" class="headerlink" title="14.选择执行某些cell"></a>14.选择执行某些cell</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">%%<span class="keyword">script</span> <span class="literal">false</span>     <span class="comment"># 在cell的开头加上此句</span></span><br></pre></td></tr></table></figure>
<h4 id="15-当需要一直运行某段代码时，通过下面的方法提醒我们的代码何时跑完"><a href="#15-当需要一直运行某段代码时，通过下面的方法提醒我们的代码何时跑完" class="headerlink" title="15.当需要一直运行某段代码时，通过下面的方法提醒我们的代码何时跑完"></a>15.当需要一直运行某段代码时，通过下面的方法提醒我们的代码何时跑完</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 预先安装sox：</span></span><br><span class="line">brew install sox  (mac上)</span><br><span class="line"><span class="comment"># Linux/Mac系统上：</span></span><br><span class="line">import os</span><br><span class="line">duration = 1 // second</span><br><span class="line">freq=440</span><br><span class="line">os.system('play --no-show-progress --null --channels 1 synth %s sine %f' % (duration,freq))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Windows系统上：</span></span><br><span class="line">import winsound</span><br><span class="line">duration = 1000</span><br><span class="line">freq = 440</span><br><span class="line">winsound.Beep(freq.duration)</span><br></pre></td></tr></table></figure>
<h4 id="16-参考博客"><a href="#16-参考博客" class="headerlink" title="16.参考博客"></a>16.参考博客</h4><ul>
<li><a href="https://towardsdatascience.com/how-to-effortlessly-optimize-jupyter-notebooks-e864162a06ee" target="_blank" rel="noopener">博客原文</a></li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>Ubuntu</tag>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中虚函数可以是内联函数吗？</title>
    <url>/C/C-%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<ul>
<li>1.<strong>需要注意的几点</strong>：<ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
</li>
<li>2.代码实例如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="comment">// 基类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">virtual</span> ~Base()&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 派生类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span>&#123;   <span class="comment">// 不写inline时隐式内联</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。</span></span><br><span class="line">    Base b;</span><br><span class="line">    b.who();</span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。</span></span><br><span class="line">    Base *bptr = <span class="keyword">new</span> Derived();</span><br><span class="line">    bptr-&gt;who();</span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> bptr;</span><br><span class="line">    bptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的volatile关键字</title>
    <url>/C/C-%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h4 id="1-使用"><a href="#1-使用" class="headerlink" title="1.使用"></a>1.使用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-使用volatile时要几个注意的点："><a href="#2-使用volatile时要几个注意的点：" class="headerlink" title="2.使用volatile时要几个注意的点："></a>2.使用volatile时要几个注意的点：</h4><ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试知识点总结</title>
    <url>/C/C-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="一-static关键字的作用"><a href="#一-static关键字的作用" class="headerlink" title="一.static关键字的作用"></a>一.static关键字的作用</h4><ul>
<li>1.修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>2.修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>3.修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>4.修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ul>
<h4 id="二-C-和C的区别"><a href="#二-C-和C的区别" class="headerlink" title="二.C++和C的区别"></a>二.C++和C的区别</h4><ul>
<li>设计思想上：<ul>
<li>C++是面向对象的语言，而C是面向过程的结构化编程语言</li>
</ul>
</li>
<li>语法上：<ul>
<li>C++具有重载、继承和多态三种特性</li>
<li>C++相比C，增加多许多类型安全的功能，比如强制类型转换</li>
<li>C++支持范式编程，比如模板类、函数模板等</li>
</ul>
</li>
</ul>
<h4 id="三-c-中四种cast转换"><a href="#三-c-中四种cast转换" class="headerlink" title="三.c++中四种cast转换"></a>三.c++中四种cast转换</h4><ul>
<li>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast<ul>
<li>1.const_cast:对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。</li>
<li>2.static_cast:完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。</li>
<li>3.dynamic_cast:用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上(指的是子类向基类的转换)和向下转化(指的是基类向子类的转换)。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</li>
<li>4.reinterpret_cast:几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</li>
</ul>
</li>
</ul>
<h4 id="四-C-C-中指针和引用的区别？"><a href="#四-C-C-中指针和引用的区别？" class="headerlink" title="四.C/C++ 中指针和引用的区别？"></a>四.C/C++ 中指针和引用的区别？</h4><ul>
<li>1.指针有自己的一块空间，而引用只是一个别名；</li>
<li>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li>
<li>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li>
<li>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li>
<li>5.可以有const指针，但是没有const引用；</li>
<li>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li>
<li>7.指针可以有多级指针（**p），而引用只有一级</li>
<li>8.指针和引用使用++运算符的意义不一样；</li>
<li>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露</li>
</ul>
<h4 id="五-c-中的四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr"><a href="#五-c-中的四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr" class="headerlink" title="五.c++中的四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr"></a>五.c++中的四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr</h4><ul>
<li>智能指针出现的原因：智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。<ul>
<li>1.auto_ptr（c++98的方案，c++11已经抛弃）原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。</li>
<li>2.unique_ptr（替换auto_ptr）：是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。unique_ptr 用于取代 auto_ptr</li>
<li>3.shared_ptr：shared_ptr实现共享式拥有概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</li>
<li>4.weak_ptr：weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题。</li>
</ul>
</li>
</ul>
<h4 id="六-野指针"><a href="#六-野指针" class="headerlink" title="六.野指针"></a>六.野指针</h4><ul>
<li>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</li>
</ul>
<h4 id="七-为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数"><a href="#七-为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数" class="headerlink" title="七.为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数"></a>七.为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</h4><ul>
<li>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</li>
<li>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</li>
</ul>
<h4 id="八-函数指针"><a href="#八-函数指针" class="headerlink" title="八.函数指针"></a>八.函数指针</h4><ul>
<li>1.定义：函数指针是指向函数的指针变量。函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。<strong>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的</strong>。</li>
<li>2.用途：调用函数和做函数的参数，比如回调函数。</li>
<li>3.示例：  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">char * <span class="function"><span class="title">fun</span><span class="params">(char * p)</span></span>  &#123;…&#125;       <span class="comment">//  指针函数fun</span></span><br><span class="line">char * (*pf)(char * p);             <span class="comment">//  函数指针pf</span></span><br><span class="line">pf = <span class="function"><span class="keyword">fun</span>;                        // 函数指针pf指向函数<span class="keyword">fun</span></span></span><br><span class="line">pf(p);                        <span class="comment">// 通过函数指针pf调用函数fun</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="九-fork函数的作用"><a href="#九-fork函数的作用" class="headerlink" title="九.fork函数的作用"></a>九.fork函数的作用</h4><ul>
<li><p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用，如下所示</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p>
</li>
<li>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</li>
</ul>
<h4 id="十-C-中析构函数的作用"><a href="#十-C-中析构函数的作用" class="headerlink" title="十.C++中析构函数的作用"></a>十.C++中析构函数的作用</h4><ul>
<li>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</li>
<li>析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。<strong>只能有一个析构函数，不能重载</strong>。</li>
<li>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作，所以许多简单的类中没有用显式的析构函数。</li>
<li>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显式构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</li>
<li>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</li>
</ul>
<h4 id="十一-静态函数和虚函数的区别"><a href="#十一-静态函数和虚函数的区别" class="headerlink" title="十一.静态函数和虚函数的区别"></a>十一.静态函数和虚函数的区别</h4><ul>
<li>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。</li>
</ul>
<h4 id="十二-重载和重写"><a href="#十二-重载和重写" class="headerlink" title="十二.重载和重写"></a>十二.重载和重写</h4><ul>
<li>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中</li>
<li>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</li>
</ul>
<h4 id="十三-虚函数和多态"><a href="#十三-虚函数和多态" class="headerlink" title="十三.虚函数和多态"></a>十三.虚函数和多态</h4><ul>
<li>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。</li>
<li>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</li>
</ul>
<h4 id="十四-下面四个代码的区别const-char-arr-“123”-char-brr-“123”-const-char-crr-“123”-char-drr-“123”"><a href="#十四-下面四个代码的区别const-char-arr-“123”-char-brr-“123”-const-char-crr-“123”-char-drr-“123”" class="headerlink" title="十四.下面四个代码的区别const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;"></a>十四.下面四个代码的区别const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;</h4><ul>
<li>const char * arr = “123”;  // 字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</li>
<li>char * brr = “123”; // 字符串123保存在常量区，这个brr指针指向的是同一个位置，同样不能通过brr去修改”123”的值</li>
<li>const char crr[] = “123”;   // 这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</li>
<li>char drr[] = “123”;  // 字符串123保存在栈区，可以通过drr去修改</li>
</ul>
<h4 id="十五-const修饰成员函数的目的是什么？"><a href="#十五-const修饰成员函数的目的是什么？" class="headerlink" title="十五.const修饰成员函数的目的是什么？"></a>十五.const修饰成员函数的目的是什么？</h4><ul>
<li>const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</li>
</ul>
<h4 id="十六-C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#十六-C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="十六.C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>十六.C++里是怎么定义常量的？常量存放在内存的哪个位置？</h4><ul>
<li>对于局部常量，存放在栈区；对于全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；字面值常量，比如字符串，放在常量区。</li>
</ul>
<h4 id="十七-new-delete与malloc-free的区别是什么"><a href="#十七-new-delete与malloc-free的区别是什么" class="headerlink" title="十七.new/delete与malloc/free的区别是什么"></a>十七.new/delete与malloc/free的区别是什么</h4><ul>
<li>首先，new/delete是C++的关键字，而malloc/free是C语言的库函数；后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数。</li>
</ul>
<h4 id="十八-虚函数表具体是怎样实现运行时多态的"><a href="#十八-虚函数表具体是怎样实现运行时多态的" class="headerlink" title="十八.虚函数表具体是怎样实现运行时多态的?"></a>十八.虚函数表具体是怎样实现运行时多态的?</h4><ul>
<li>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</li>
</ul>
<h4 id="十九-C语言是怎么进行函数调用的？"><a href="#十九-C语言是怎么进行函数调用的？" class="headerlink" title="十九.C语言是怎么进行函数调用的？"></a>十九.C语言是怎么进行函数调用的？</h4><ul>
<li>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。</li>
</ul>
<h4 id="二十-C-如何处理返回值？"><a href="#二十-C-如何处理返回值？" class="headerlink" title="二十.C++如何处理返回值？"></a>二十.C++如何处理返回值？</h4><ul>
<li>生成一个临时变量，把它的引用作为函数参数传入函数内。</li>
</ul>
<h4 id="二十一-C-中拷贝赋值函数的形参能否进行值传递？"><a href="#二十一-C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="二十一.C++中拷贝赋值函数的形参能否进行值传递？"></a>二十一.C++中拷贝赋值函数的形参能否进行值传递？</h4><ul>
<li>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</li>
</ul>
<h4 id="二十二-malloc与new区别"><a href="#二十二-malloc与new区别" class="headerlink" title="二十二.malloc与new区别"></a>二十二.malloc与new区别</h4><ul>
<li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存大小，返回的指针不用强转。</li>
</ul>
<h4 id="二十三-fork-wait-exec函数的作用"><a href="#二十三-fork-wait-exec函数的作用" class="headerlink" title="二十三.fork,wait,exec函数的作用"></a>二十三.fork,wait,exec函数的作用</h4><ul>
<li>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存；exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0；调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1。</li>
</ul>
<h4 id="二十四-C-中类成员的访问权限"><a href="#二十四-C-中类成员的访问权限" class="headerlink" title="二十四.C++中类成员的访问权限"></a>二十四.C++中类成员的访问权限</h4><ul>
<li>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。</li>
</ul>
<h4 id="二十五-C-中struct和class的区别"><a href="#二十五-C-中struct和class的区别" class="headerlink" title="二十五. C++中struct和class的区别"></a>二十五. C++中struct和class的区别</h4><ul>
<li>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</li>
<li>区别：最本质的一个区别就是默认的访问控制<ul>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的</li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
</ul>
</li>
</ul>
<h4 id="二十六-C-类的内部可以定义引用数据成员吗？"><a href="#二十六-C-类的内部可以定义引用数据成员吗？" class="headerlink" title="二十六.C++类的内部可以定义引用数据成员吗？"></a>二十六.C++类的内部可以定义引用数据成员吗？</h4><ul>
<li>可以，必须通过成员函数初始化列表初始化  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> &amp;i):  a(<span class="number">1</span>),   b(i)&#123;         <span class="comment">//  构造函数初始化列表中是初始化工作</span></span><br><span class="line">        <span class="comment">//   在这里做的是赋值而非初始化工作</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> &amp;b;  <span class="comment">// 引用数据成员b,必须通过列表初始化！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="二十七-什么是右值引用，跟左值又有什么区别？"><a href="#二十七-什么是右值引用，跟左值又有什么区别？" class="headerlink" title="二十七.什么是右值引用，跟左值又有什么区别？"></a>二十七.什么是右值引用，跟左值又有什么区别？</h4><ul>
<li>左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。</li>
<li>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</li>
<li>右值引用和左值引用的区别：<ul>
<li>1.左值可以寻址，而右值不可以；</li>
<li>2.左值可以被赋值，右值不可以被赋值，可以用来给左值赋值；</li>
<li>3.左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</li>
</ul>
</li>
</ul>
<h4 id="二十八-C-源文件从文本到可执行文件经历的过程？"><a href="#二十八-C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="二十八.C++源文件从文本到可执行文件经历的过程？"></a>二十八.C++源文件从文本到可执行文件经历的过程？</h4><ul>
<li>对于C++源文件，从文本到可执行文件一般需要四个过程：<ul>
<li>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</li>
<li>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</li>
<li>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</li>
<li>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</li>
</ul>
</li>
</ul>
<h4 id="二十九-include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#二十九-include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="二十九.include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？"></a>二十九.include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h4><ul>
<li>include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。</li>
<li>双引号和尖括号的区别：<strong>编译器预处理阶段查找头文件的路径不一样</strong>。<strong>对于使用双引号包含的头文件</strong>，查找头文件路径的顺序为：当前头文件目录、编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）、系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径；<strong>对于使用尖括号包含的头文件</strong>，查找头文件的路径顺序为：编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）、系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径。</li>
</ul>
<h4 id="三十-什么时候会发生段错误？"><a href="#三十-什么时候会发生段错误？" class="headerlink" title="三十.什么时候会发生段错误？"></a>三十.什么时候会发生段错误？</h4><ul>
<li>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：<ul>
<li>使用野指针</li>
<li>试图修改字符串常量的内容</li>
</ul>
</li>
</ul>
<h4 id="三十一-C-11有哪些新特性？"><a href="#三十一-C-11有哪些新特性？" class="headerlink" title="三十一.C++11有哪些新特性？"></a>三十一.C++11有哪些新特性？</h4><ul>
<li>auto关键字：编译器可以根据初始值自动推导出类型，但是不能用于函数传参以及数组类型的推导；</li>
<li>nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。</li>
<li>智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。</li>
<li>初始化列表：使用初始化列表来对类进行初始化</li>
<li>右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</li>
<li>atomic原子操作用于多线程资源互斥操作</li>
<li>新增STL容器array以及tuple</li>
</ul>
<h4 id="三十二-const的作用"><a href="#三十二-const的作用" class="headerlink" title="三十二.const的作用"></a>三十二.const的作用</h4><ul>
<li>1.修饰变量，说明该变量不可以被修改</li>
<li>2.修饰指针，分为指向常量的指针(即常量指针)和指针常量</li>
<li>3.常量引用，经常用于形参类型，既避免了拷贝，又避免了函数对值的修改</li>
<li>4.修饰成员函数，说明该成员函数内不能修改成员变量</li>
<li>const用法如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 常量指针即常指针，指针的指向可以改变，但是所存的内容不能变</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* p2 = greeting;     <span class="comment">// 与const char* p2 等价</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 指针常量，指针是一个常量，即指针的指向不能改变，但是指针所存的内容可以改变</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 指向常量的常指针，指针和指针所存的内容都不能改变，本质是一个常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数为常量指针即指针所指的内容为常量不能变，指针指向可以改变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数为指针常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量即常量指针，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针即指针常量，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="三十三-this-指针"><a href="#三十三-this-指针" class="headerlink" title="三十三.this 指针"></a>三十三.this 指针</h4><ul>
<li>this 指针是一个隐含于每一个<strong>非静态成员函数</strong>中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li>this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li>this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。<br>在以下场景中，经常需要显式引用 this 指针：<ul>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 list。</li>
</ul>
</li>
</ul>
<h4 id="三十四-inline内联函数"><a href="#三十四-inline内联函数" class="headerlink" title="三十四.inline内联函数"></a>三十四.inline内联函数</h4><ul>
<li>内联函数的特点：<ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
</ul>
</li>
<li><p>内联函数的使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> A::doA() &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>编译器对内联函数的处理步骤</strong>:</p>
<ul>
<li>将 inline 函数体复制到 inline 函数调用点处；</li>
<li>为所用 inline 函数中的局部变量分配内存空间；</li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）</li>
</ul>
</li>
<li><strong>使用内联函数的优缺点</strong>:<ul>
<li>优点:<ul>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ul>
</li>
<li>缺点:<ul>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ul>
</li>
</ul>
</li>
<li><strong>虚函数可以是内联函数吗？</strong><ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
<li>虚函数内联使用实例如下:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。</span></span><br><span class="line">    Base b;</span><br><span class="line">    b.who();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。</span></span><br><span class="line">    Base *ptr = <span class="keyword">new</span> Derived();</span><br><span class="line">    ptr-&gt;who();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="三十五-volatile关键字"><a href="#三十五-volatile关键字" class="headerlink" title="三十五.volatile关键字"></a>三十五.volatile关键字</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改</strong>。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是volatile</li>
</ul>
<h4 id="三十六-assert"><a href="#三十六-assert" class="headerlink" title="三十六.assert()"></a>三十六.assert()</h4><ul>
<li><strong>断言是宏，而非函数</strong>。assert 宏的原型定义在 <assert.h>（C）、\<cassert\>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前。</assert.h></cassert\></assert.h></li>
<li>assert()使用<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="三十七-sizeof-运算符"><a href="#三十七-sizeof-运算符" class="headerlink" title="三十七.sizeof()运算符"></a>三十七.sizeof()运算符</h4><ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
<h4 id="三十八-pragma-pack-n"><a href="#三十八-pragma-pack-n" class="headerlink" title="三十八.#pragma pack(n)"></a>三十八.#pragma pack(n)</h4><ul>
<li>用途：设定结构体、联合以及类成员变量以 n 字节方式对齐</li>
<li>#pragma pack(n)使用实例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="三十九-extern-“C”"><a href="#三十九-extern-“C”" class="headerlink" title="三十九. extern “C”"></a>三十九. extern “C”</h4><ul>
<li>用途：extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</li>
<li>被 extern 限定的函数或变量是 extern 类型的；被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的</li>
<li>extern “C”实例如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="四十-struct-和-typedef-struct"><a href="#四十-struct-和-typedef-struct" class="headerlink" title="四十.struct 和 typedef struct"></a>四十.struct 和 typedef struct</h4><ul>
<li><p>C语言中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; S;</span><br><span class="line"><span class="comment">// 等价于下面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">S</span>;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++中：</p>
<ul>
<li><p>1.如果在类标识符空间定义了 struct Student {…};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。即表现为可以使用 Student 也可以使用 struct Student，如下：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，"struct" 关键字可省略</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 "Student" 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">me</span>;</span>      <span class="comment">// 或者 "S me";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="四十一-union联合体"><a href="#四十一-union联合体" class="headerlink" title="四十一.union联合体"></a>四十一.union联合体</h4><ul>
<li>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
</li>
<li>union使用实例如下：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> UnionTest &#123;</span><br><span class="line">    UnionTest() : i(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="四十二-explicit（显式）关键字"><a href="#四十二-explicit（显式）关键字" class="headerlink" title="四十二.explicit（显式）关键字"></a>四十二.explicit（显式）关键字</h4><ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化，必须显式初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但按语境转换 除外</li>
<li>explicit使用实例如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A(<span class="keyword">int</span>) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;        <span class="comment">// OK：直接初始化</span></span><br><span class="line">    A a2 = <span class="number">1</span>;       <span class="comment">// OK：复制初始化</span></span><br><span class="line">    A a3&#123; <span class="number">1</span> &#125;;      <span class="comment">// OK：直接列表初始化</span></span><br><span class="line">    A a4 = &#123; <span class="number">1</span> &#125;;       <span class="comment">// OK：复制列表初始化</span></span><br><span class="line">    A a5 = (A)<span class="number">1</span>;        <span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">    doA(<span class="number">1</span>);         <span class="comment">// OK：允许从 int 到 A 的隐式转换</span></span><br><span class="line">    <span class="keyword">if</span> (a1);        <span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">    <span class="keyword">bool</span> a6（a1）;        <span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">    <span class="keyword">bool</span> a7 = a1;       <span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">    <span class="keyword">bool</span> a8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a1);  <span class="comment">// OK ：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;        <span class="comment">// OK：直接初始化</span></span><br><span class="line">    B b2 = <span class="number">1</span>;       <span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span></span><br><span class="line">    B b3&#123; <span class="number">1</span> &#125;;      <span class="comment">// OK：直接列表初始化</span></span><br><span class="line">    B b4 = &#123; <span class="number">1</span> &#125;;       <span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span></span><br><span class="line">    B b5 = (B)<span class="number">1</span>;        <span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">    doB(<span class="number">1</span>);         <span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span></span><br><span class="line">    <span class="keyword">if</span> (b1);        <span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;        <span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">    <span class="keyword">bool</span> b7 = b1;       <span class="comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span></span><br><span class="line">    <span class="keyword">bool</span> b8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b1);  <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="四十三-friend友元类和友元函数"><a href="#四十三-friend友元类和友元函数" class="headerlink" title="四十三.friend友元类和友元函数"></a>四十三.friend友元类和友元函数</h4><ul>
<li>能访问私有成员、破坏封装性、友元关系不可传递、友元关系的单向性、友元声明的形式及数量不受限制</li>
</ul>
<h4 id="四十四-范围解析运算符"><a href="#四十四-范围解析运算符" class="headerlink" title="四十四.:: 范围解析运算符"></a>四十四.:: 范围解析运算符</h4><ul>
<li>种类：<ul>
<li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ul>
</li>
<li>使用实例：  <figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;        <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">count</span>; <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    ::<span class="keyword">count</span> = <span class="number">1</span>;      <span class="comment">// 设置全局的 count 的值为 1</span></span><br><span class="line"></span><br><span class="line">    A::<span class="keyword">count</span> = <span class="number">2</span>;     <span class="comment">// 设置类 A 的 count 为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;    <span class="comment">// 局部的 count</span></span><br><span class="line">    <span class="keyword">count</span> = <span class="number">3</span>;        <span class="comment">// 设置局部的 count 的值为 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="四十五-enum枚举类型"><a href="#四十五-enum枚举类型" class="headerlink" title="四十五.enum枚举类型"></a>四十五.enum枚举类型</h4><ul>
<li><p>限定作用域的枚举类型:</p>
  <figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> <span class="title">open_modes</span> &#123; <span class="title">input</span>, <span class="title">output</span>, <span class="title">append</span> &#125;;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不限定作用域的枚举类型:</p>
  <figure class="highlight capnproto"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> </span>&#123; red, yellow, green &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="四十六-decltype关键字"><a href="#四十六-decltype关键字" class="headerlink" title="四十六.decltype关键字"></a>四十六.decltype关键字</h4><ul>
<li>作用和用法：用于检查实体的声明类型或表达式的类型及值分类。语法：decltype ( expression )</li>
<li>decltype实例如下：  <figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="keyword">auto</span> fcn(It beg, It <span class="built_in">end</span>) -&gt; <span class="keyword">decltype</span>(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="built_in">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="keyword">auto</span> fcn2(It beg, It <span class="built_in">end</span>) -&gt; <span class="keyword">typename</span> remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="built_in">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="四十七-引用和宏"><a href="#四十七-引用和宏" class="headerlink" title="四十七.引用和宏"></a>四十七.引用和宏</h4><ul>
<li>左值引用：常规引用，一般表示对象的身份</li>
<li>右值引用：右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值；右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：<ul>
<li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li>
<li>能够更简洁明确地定义泛型函数。</li>
</ul>
</li>
<li>引用折叠： X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp;；X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp;</li>
<li>宏：宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，<strong>在宏展开的时候对 “参数” 进行的是一对一的替换</strong>。</li>
</ul>
<h4 id="四十八-必须使用成员初始化列表的场合"><a href="#四十八-必须使用成员初始化列表的场合" class="headerlink" title="四十八.必须使用成员初始化列表的场合"></a>四十八.必须使用成员初始化列表的场合</h4><ul>
<li>好处：更高效：少了一次调用默认构造函数的过程。</li>
<li><strong>有些场合必须要用初始化列表：</strong><ul>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li>
</ul>
</li>
</ul>
<h4 id="四十九-面向对象三大特征"><a href="#四十九-面向对象三大特征" class="headerlink" title="四十九.面向对象三大特征"></a>四十九.面向对象三大特征</h4><ul>
<li><strong>封装</strong>：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。<ul>
<li>public 成员：可以被任意实体访问</li>
<li>protected 成员：只允许被子类及本类的成员函数访问</li>
<li>private 成员：只允许被本类的成员函数、友元类或友元函数访问</li>
</ul>
</li>
<li><strong>继承</strong>：基类（父类）——&gt; 派生类（子类）</li>
<li><p><strong>多态</strong>：即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。<strong>多态是以封装和继承为基础的</strong>。</p>
<ul>
<li>C++ 多态分类及实现：<ul>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ul>
</li>
<li><p><strong>静态多态(编译期/早绑定)</strong></p>
<ul>
<li>函数重载实例:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>动态多态(运行期/晚绑定)</strong></p>
<ul>
<li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li>
<li><strong>注意：</strong><ul>
<li>普通函数（非类成员函数）不能是虚函数</li>
<li>静态函数（static）不能是虚函数</li>
<li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li>
<li>内联函数不能是表现多态性时的虚函数</li>
</ul>
</li>
<li>动态多态实例  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>                     // 形状类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> Rect(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;calcArea();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="五十-虚析构函数"><a href="#五十-虚析构函数" class="headerlink" title="五十.虚析构函数"></a>五十.虚析构函数</h4><ul>
<li>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</li>
<li>虚析构函数的使用如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape();                    <span class="comment">// 构造函数不能是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();           <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();</span><br><span class="line">    <span class="keyword">delete</span> shape1;  <span class="comment">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span></span><br><span class="line">    shape1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="五十一-纯虚函数"><a href="#五十一-纯虚函数" class="headerlink" title="五十一.纯虚函数"></a>五十一.纯虚函数</h4><ul>
<li>定义：纯虚函数是一种特殊的虚函数，<strong>在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做</strong>。</li>
<li>用法：  virtual int A() = 0;</li>
</ul>
<h4 id="五十二-虚函数、纯虚函数"><a href="#五十二-虚函数、纯虚函数" class="headerlink" title="五十二.虚函数、纯虚函数"></a>五十二.虚函数、纯虚函数</h4><ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li><strong>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</strong></li>
<li>虚基类是虚继承中的基类。</li>
</ul>
<h4 id="五十三-虚函数指针、虚函数表"><a href="#五十三-虚函数指针、虚函数表" class="headerlink" title="五十三.虚函数指针、虚函数表"></a>五十三.虚函数指针、虚函数表</h4><ul>
<li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li>
<li>虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚函数表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li>
</ul>
<h4 id="五十四-虚继承"><a href="#五十四-虚继承" class="headerlink" title="五十四.虚继承"></a>五十四.虚继承</h4><ul>
<li>用途：用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）</li>
<li>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</li>
</ul>
<h4 id="五十五-虚继承、虚函数"><a href="#五十五-虚继承、虚函数" class="headerlink" title="五十五.虚继承、虚函数"></a>五十五.虚继承、虚函数</h4><ul>
<li>相同点：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同点：<ul>
<li>虚继承：<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移</li>
</ul>
</li>
<li>虚函数：<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="五十六-模板类、成员模板、虚函数"><a href="#五十六-模板类、成员模板、虚函数" class="headerlink" title="五十六.模板类、成员模板、虚函数"></a>五十六.模板类、成员模板、虚函数</h4><ul>
<li>模板类中可以使用虚函数</li>
<li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li>
</ul>
<h4 id="五十七-抽象类、接口类、聚合类"><a href="#五十七-抽象类、接口类、聚合类" class="headerlink" title="五十七.抽象类、接口类、聚合类"></a>五十七.抽象类、接口类、聚合类</h4><ul>
<li>抽象类：含有纯虚函数的类</li>
<li>接口类：仅含有纯虚函数的抽象类</li>
<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
<h4 id="五十八-内存分配和管理"><a href="#五十八-内存分配和管理" class="headerlink" title="五十八.内存分配和管理"></a>五十八.内存分配和管理</h4><ul>
<li>malloc、calloc、realloc、alloca<ul>
<li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li>
<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li>
<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li>
<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li>
</ul>
</li>
<li><p>malloc和free</p>
<ul>
<li>用途：用于分配、释放内存</li>
<li><p>使用：</p>
<ul>
<li><p>申请内存，确认是否申请成功</p>
 <figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">char *str = (<span class="name">char*</span>) malloc(<span class="number">100</span>)<span class="comment">;</span></span><br><span class="line">assert(<span class="name">str</span> != nullptr)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>释放内存后指针置空</p>
  <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">free(p)<span class="comment">;</span></span><br><span class="line"><span class="attribute">p</span> = nullptr<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>new和delete</p>
<ul>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
<li>使用：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* t = <span class="keyword">new</span> T();     <span class="comment">// 先内存分配 ，再构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> t;           <span class="comment">// 先析构函数，再内存释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="五十九-delete-this-合法吗？"><a href="#五十九-delete-this-合法吗？" class="headerlink" title="五十九.delete this 合法吗？"></a>五十九.delete this 合法吗？</h4><ul>
<li>合法，但是：<ul>
<li>必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 delete this 后面没有调用 this 了</li>
<li>必须保证 delete this 后没有人使用了</li>
</ul>
</li>
</ul>
<h4 id="六十-如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#六十-如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="六十.如何定义一个只能在堆上（栈上）生成对象的类？"></a>六十.如何定义一个只能在堆上（栈上）生成对象的类？</h4><ul>
<li><strong>只能在堆上</strong><ul>
<li>方法： 将析构函数设置为私有</li>
<li>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</li>
</ul>
</li>
<li><strong>只能在栈上</strong><ul>
<li>方法：将 new 和 delete 重载为私有</li>
<li>原因： 在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</li>
</ul>
</li>
</ul>
<h4 id="六十一-强制类型转换运算符-4种"><a href="#六十一-强制类型转换运算符-4种" class="headerlink" title="六十一.强制类型转换运算符(4种)"></a>六十一.强制类型转换运算符(4种)</h4><ul>
<li>static_cast<ul>
<li>特点：静态转换，在编译处理期间。</li>
<li>应用场合： 主要用于C++中内置的基本数据类型之间的转换，但是没有运行时类型的检测来保证转换的安全性。<ul>
<li>a.用于基类和子类之间的指针或引用之间的转换，这种转换把子类的指针或引用转换为基类表示是安全的；进行下行转换，把积累的指针或引用转换为子类表示时，由于没有进行动态类型检测，所以是不安全的。</li>
<li>b.把void类型的指针转换成目标类型的指针（不安全）</li>
<li>c.不能用于两个不相关的类型转换</li>
<li>d.不能把const对象转换成非const对象</li>
</ul>
</li>
</ul>
</li>
<li>const_cast<ul>
<li>特点：去常转换，编译时执行。</li>
<li>应用场合： const_cast操作不能在不同的种类间转换。相反，它仅仅把它作用的表达式转换成常量。它可以使一个本来不是const类型的数据转换成const类型的，或者把const属性去掉。</li>
</ul>
</li>
<li>reinterpret_cast:<ul>
<li>特点：重解释类型转换</li>
<li>应用场合： 它有着和c风格强制类型转换同样的功能；它可以转化任何的内置数据类型为其他的类型，同时它也可以把任何类型的指针转化为其他的类型；它的机理是对二进制进行重新的解释，不会改变原来的格式。</li>
</ul>
</li>
<li>dynamic_cast &lt; type-id &gt; ( expression )<ul>
<li>特点：该运算符将expression转换成type_id类型的对象。type_id必须是类的指针，类的引用或者空类型的指针。</li>
<li>应用场合：<ul>
<li>a.如果type_id是一个指针类型，那么expression也必须是一个指针类型，如果type_id是一个引用类型，那么expression也必须是一个引用类型。</li>
<li>b.如果type_id是一个空类型的指针，在运行的时候，就会检测expression的实际类型，结果是一个由expression决定的指针类型。</li>
<li>c.如果type_id不是空类型的指针，在运行的时候指向expression对象的指针能否可以转换成type_id类型的指针</li>
<li>d.在运行的时候决定真正的类型，如果向下转换是安全的，就返回一个转换后的指针，若不安全，则返回一个空指针</li>
<li>e.主要用于上下行之间的转换，也可以用于类之间的交叉转换。上行转换时和static_cast效果一样，下行转换时，具有检测功能，比static_cast更安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="六十二-new-delete和malloc-free的联系和区别"><a href="#六十二-new-delete和malloc-free的联系和区别" class="headerlink" title="六十二.new delete和malloc free的联系和区别"></a>六十二.new delete和malloc free的联系和区别</h4><ul>
<li>malloc与free是C语言的标准库函数， new/delete是C++的运算符。它们都可用于申请动态内存和释放内存;</li>
<li>对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构<br>造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之<br>内，不能够把执行构造函数和析构函数的任务强加于malloc/free;</li>
<li>C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete，注意new/delete不是库函数。</li>
</ul>
<h4 id="六十三-hash冲突及解决方法"><a href="#六十三-hash冲突及解决方法" class="headerlink" title="六十三.hash冲突及解决方法"></a>六十三.hash冲突及解决方法</h4><ul>
<li>关键字值不同的元素可能会映射到哈希表的同一地址上就会发生哈希冲突。解决办法：<ul>
<li><strong>开放定址法</strong>：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。</li>
<li>再哈希法：同时构造多个不同的哈希函数</li>
<li>链地址法：将所有哈希地址为 i 的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个<br>单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况</li>
<li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</li>
</ul>
</li>
</ul>
<h4 id="六十四-多态是什么-多态的作用？"><a href="#六十四-多态是什么-多态的作用？" class="headerlink" title="六十四.多态是什么,多态的作用？"></a>六十四.多态是什么,多态的作用？</h4><ul>
<li>定义：同一个对象，在不同时刻体现出来的不同状态。</li>
<li>多态的前提：<ul>
<li>要有继承关系或实现关系（接口）</li>
<li>要有方法重写；</li>
<li>要有父类或者父接口引用指向子类Base b= new Derived()；</li>
</ul>
</li>
<li>作用：提高了代码的维护性（继承保证）；提高了代码的扩展性</li>
</ul>
<h4 id="六十五-继承含有纯虚函数的父类，子类能否实例化？"><a href="#六十五-继承含有纯虚函数的父类，子类能否实例化？" class="headerlink" title="六十五. 继承含有纯虚函数的父类，子类能否实例化？"></a>六十五. 继承含有纯虚函数的父类，子类能否实例化？</h4><ul>
<li>如果父类中存在纯虚函数，子类继承父类时，必须重写父类的纯虚函数，函数名、返回类型、参数个数和类型都不能改。若父类中的虚函数自己有定义，子类也可以不重写。之后便可以实例化子类。</li>
</ul>
<h4 id="六十六-构造函数是否可以用private修饰，如果可以，会有什么效果？"><a href="#六十六-构造函数是否可以用private修饰，如果可以，会有什么效果？" class="headerlink" title="六十六.构造函数是否可以用private修饰，如果可以，会有什么效果？"></a>六十六.构造函数是否可以用private修饰，如果可以，会有什么效果？</h4><ul>
<li>如果一个类的构造函数只有一个且为private，这是可以编译通过的；</li>
<li>如果一个类的构造函数只有一个且是private，如果类的内部没有专门创建实例的代码，则是无法创建任何实例的；</li>
<li>如果一个类的构造函数只有一个且是private，如果类的内部有专门创建实例的代码，则只能创建一个或多个实例（根据类内部声明的成员对象个数来定）；</li>
<li>如果一个类的构造函数不止一个，private 构造函数如果参数 为void(无参)，则子类无法编译；换言之，如果一个类构造函数只有private且存在子类，则无法编译，除非父类构造函数为public。</li>
</ul>
<h4 id="六十七-子类的指针能否转换为父类的指针？父类指针能否访问子类成员？"><a href="#六十七-子类的指针能否转换为父类的指针？父类指针能否访问子类成员？" class="headerlink" title="六十七.子类的指针能否转换为父类的指针？父类指针能否访问子类成员？"></a>六十七.子类的指针能否转换为父类的指针？父类指针能否访问子类成员？</h4><ul>
<li>当自己的类指针指向自己类的对象时，无论调用的是虚函数还是实函数，其调用的都是自己的</li>
<li>当指向父类对象的父类指针被强制转换成子类指针时候，子类指针调用函数时，只有非重写函数是自己的，虚函数是父类的；</li>
<li>当指向子类对象的子类指针被强制转换成父类指针的时候，也就是父类指针指向子类对象，此时，父类指针调用的虚函数都是子类的，而非虚函数都是自己的；</li>
</ul>
<h4 id="六十八-虚函数的实现机制"><a href="#六十八-虚函数的实现机制" class="headerlink" title="六十八.虚函数的实现机制"></a>六十八.虚函数的实现机制</h4><ul>
<li><a href="https://blog.csdn.net/jiangnanyouzi/article/details/3720807" target="_blank" rel="noopener">虚函数实现机制</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C++常用参考资料</title>
    <url>/%E5%B8%B8%E7%94%A8%E8%B5%84%E6%96%99/C-%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<h4 id="1-常用参考资料"><a href="#1-常用参考资料" class="headerlink" title="1.常用参考资料"></a>1.常用参考资料</h4><ul>
<li><a href="http://c.biancheng.net/stl/" target="_blank" rel="noopener">STL标准模板库的使用</a></li>
<li><a href="https://zh.cppreference.com/w/cpp" target="_blank" rel="noopener">C++参考手册</a></li>
</ul>
]]></content>
      <categories>
        <category>常用资料</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络中的批量归一化Batch Normalization(BN)原理总结</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%89%B9%E9%87%8F%E5%BD%92%E4%B8%80%E5%8C%96Batch-Normalization-BN-%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h4><ul>
<li><strong>深层神经网络存在的问题(从当前层的输入的分布来分析)</strong>：在深层神经网络中，中间层的输入是上一层神经网络的输出。因此，之前的层的神经网络参数的变化会导致当前层输入的分布发生较大的差异。在使用随机梯度下降法来训练神经网络时，每次参数更新都会导致网络中每层的输入分布发生变化。越是深层的神经网络，其输入的分布会改变的越明显。</li>
<li><strong>解决方法(归一化操作)</strong>：从机器学习角度来看，如果某层的输入分布发生了变化，那么其参数需要重新学习，这种现象称为<strong>内部协变量偏移</strong>。为了解决内部协变量偏移问题，就要使得每一层神经网络输入的分布在训练过程中要保持一致。最简单的方法是<strong>对每一层神经网络都进行归一化操作，使其分布保持稳定</strong>。</li>
</ul>
<h4 id="1-批量归一化"><a href="#1-批量归一化" class="headerlink" title="1.批量归一化"></a>1.批量归一化</h4><ul>
<li><strong>协变量偏移介绍</strong><ul>
<li>在传统机器学习中，一个常见的问题是协变量偏移。协变量是一个统计学概念，是可能影响预测结果的统计变量。在机器学习中，协变量可以看作是<strong>输入</strong>。一般的机器学习算法都要求输入在训练集和测试集上的分布式相似的。如果不满足这个假设，在训练集上学习到的模型在测试集上的表现会比较差，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-d93a5b732347ea1a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协变量偏移"></li>
</ul>
</li>
<li><strong>BN原理介绍</strong><ul>
<li>批量归一化方法是一种有效的逐层归一化的方法，可以对神经网络中任意的中间层进行归一化操作。对一个深层神经网络来说，令第l层的净输入为$\mathbf{z}^{(l)}$， 经过激活函数后的输出是$\mathbf{a}^{(l)}$，即<script type="math/tex; mode=display">
\mathbf{a}^{(l)}=f\left(\mathbf{z}^{(l)}\right)=f\left(W \mathbf{a}^{(l-1)}+\mathbf{b}\right)</script>其中，$f(\cdot)$是激活函数，W和b是权重和偏置参数。</li>
<li>为了减少内部协变量偏移问题，就要使得净输入$\mathbf{z}^{(l)}$的分布一致，比如都归一化到标准正态分布。虽然归一化操作可以应用在输入$\mathbf{a}^{(l-1)}$上，但其分布性质不如$\mathbf{z}^{(l)}$稳定。因此，<strong>在实践中归一化操作一般应用在仿射变换之后，在下一次激活函数之前</strong>。利用数据预处理方法对$\mathbf{z}^{(l)}$进行归一化，相当于每一层都进行一次数据预处理，从而加速收敛速度。但是，逐层归一化需要在中间层进行操作，要求效率比较高，因此复杂度比较高的白话方法就不太合适。为了提高归一化效率，一般使用标准归一化，将净输入$\mathbf{z}^{(l)}$的每一维都归一到标准正态分布。<script type="math/tex; mode=display">
\hat{\mathbf{z}}^{(l)}=\frac{\mathbf{z}^{(l)}-\mathbb{E}\left[\mathbf{z}^{(l)}\right]}{\sqrt{\operatorname{var}\left(\mathbf{z}^{(l)}\right)+\epsilon}}</script>其中，$\mathbb{E}\left[\mathbf{z}^{(l)}\right]$和$\operatorname{var}\left(\mathbf{z}^{(l)}\right)$是当前参数下，$\mathbf{z}^{(l)}$的每一维度在整个训练集上的期望和方差。因为目前主要的训练方法是基于Mini-Batch的随机梯度下降算法，所以准确地计算$\mathbf{z}^{(l)}$的期望和方差是不可行的。因此，$\mathbf{z}^{(l)}$的期望和方差通常用当前小批量Mini-Batch样本集的均值和方差近似估计。</li>
<li>给定一个包含K个样本的小批量样本集合，第l层神经元的净输入$\mathbf{z}^{(1,l)}$，….，$\mathbf{z}^{(K,l)}$的均值和方差为：<script type="math/tex; mode=display">
\begin{aligned} \mu_{\mathcal{B}} &=\frac{1}{K} \sum_{k=1}^{\mathrm{N}} \mathbf{z}^{(k, l)} \\ \sigma_{\mathcal{B}}^{2} &=\frac{1}{K} \sum_{k=1}^{K}\left(\mathbf{z}^{(k, l)}-\mu_{\mathcal{B}}\right) \odot\left(\mathbf{z}^{(k, l)}-\mu_{\mathcal{B}}\right) \end{aligned}</script></li>
<li>对净输入$\mathbf{z}^{(l)}$的标准归一化会使得其取值集中到0附近，如果使用sigmoid激活函数时，这个取值区间刚好是接近线性变换区间，从而减弱了神经网络非线性变换的性质。<strong>因此，为了使归一化操作不对网络的表示能力造成负面影响，可以通过一个附加的缩放和平移变换改变取值区间</strong>。<br>$\hat{\mathbf{z}}^{(l)}=\frac{\mathbf{z}^{(l)}-\mu<em>{\mathcal{B}}}{\sqrt{\sigma</em>{\mathcal{B}}^{2}+\epsilon}} \odot \gamma+\beta\triangleq \mathrm{BN}<em>{\gamma, \beta}\left(\mathbf{z}^{(l)}\right)$<br>其中，$\gamma$、$\beta$分别表示缩放和平移的参数向量。<strong>从最保守的角度考虑，可以通过标准归一化的逆变换来使得归一化的变量可以被还原为原来的值</strong>。即：当$\gamma=\sqrt{\sigma</em>{\mathcal{B}}^{2}}$，$\beta=\mu_{\mathcal{B}}$时，$\hat{\mathbf{z}}^{(l)}=\mathbf{z}^{(l)}$。</li>
<li>批量归一化操作可以看作是一个特殊的神经网络层，<strong>该层是加在每一层非线性激活函数之前</strong>，即：<script type="math/tex; mode=display">
\mathbf{a}^{(l)}=f\left(\mathbf{B} \mathbf{N}_{\gamma, \beta}\left(\mathbf{z}^{(l)}\right)\right)=f\left(\mathbf{B} \mathbf{N}_{\gamma, \beta}\left(W \mathbf{a}^{(l-1)}\right)\right)</script>其中，因为批量归一化本身具有平移变换，因此非线性变换$W \mathbf{a}^{(l-1)}$就不再需要偏置参数b。</li>
<li><strong>注意</strong>：每次小批量样本的$\mu<em>{\mathcal{B}}$和$\sigma</em>{\mathcal{B}}^{2}$是净输入$\mathbf{z}^{(l)}$的函数，而不是常量。因此，在计算参数梯度时，需要考虑$\mu<em>{\mathcal{B}}$和$\sigma</em>{\mathcal{B}}^{2}$的影响。当训练完成时，用整个数据集上的均值$\mu$和方差$\sigma^{2}$来分别替代每次小批量样本的$\mu<em>{\mathcal{B}}$和$\sigma</em>{\mathcal{B}}^{2}$。在实际中，$\mu<em>{\mathcal{B}}$和$\sigma</em>{\mathcal{B}}^{2}$也可以使用移动平均来计算。</li>
</ul>
</li>
</ul>
<h4 id="2-参考资料"><a href="#2-参考资料" class="headerlink" title="2.参考资料"></a>2.参考资料</h4><ul>
<li><a href="https://nndl.github.io/" target="_blank" rel="noopener">邱锡鹏：《神经网络与深度学习》</a></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的数据预处理方法总结</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h4 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h4><ul>
<li>一般而言，样本的原始特征中的每一维特征由于来源以及度量单位不同，其特征取值的分布范围往往差异很大。当我们计算不同样本之间的欧氏距离时，取值范围大的特征会起到主导作用。这样，对于基于相似度比较的机器学习方法（比如最近邻分类器KNN），必须先对样本进行预处理，将各个维度的特征归一化到同一个取值区间，并且消除不同特征之间的相关性，才能获得比较理想的结果。虽然神经网络可以通过参数的调整来适应不同特征的取值范围，但是会导致训练效率比较低。</li>
<li>假设一个只有一层的网络 $y=\tanh \left(w<em>{1} x</em>{1}+w<em>{2} x</em>{2}+b\right)$，其中$x<em>{1} \in[0,10]$，$x</em>{2} \in[0,1]$。因为tanh函数的导数在区间 [−2, 2]上是敏感的，其余地方的导数接近于 0。因此，如果 $w<em>{1} x</em>{1}+w<em>{2} x</em>{2}+b$过大或过小，都会导致梯度过小，难以训练。为了提高训练效率，我们需要使$w<em>{1} x</em>{1}+w<em>{2} x</em>{2}+b$在 [−2, 2]区间，我们需要将w1设得小一点，比如在 [−0.1,0.1]之间。可以想象，如果数据维数很多时，我们很难这样精心去选择每一个参数。因此，如果每一个特征的取值范围都在相似的区间，比如 [0, 1]或者 [−1, 1]，我们就不太需要区别对待每一个参数，减少人工干预。</li>
<li>当不同输入特征的取值范围差异比较大时，梯度下降法的效率也会受到影响。下图给出了数据归一化对梯度的影响。其中，图a为未归一化数据的等高线图。取值范围不同会造成在大多数位置上的梯度方向并不是最优的搜索方向。当使用梯度下降法寻求最优解时，会导致需要很多次迭代才能收敛。如果我们把数据归一化为取值范围相同，如图b所示，大部分位置的梯度方向近似于最优搜索方向。这样，在梯度下降求解时，每一步梯度的方向都基本指向最小值，训练效率会大大提高。<br>  <img src="https://upload-images.jianshu.io/upload_images/13407176-8d338f7c89713b24?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据归一化对梯度的影响"></li>
</ul>
<h4 id="1-常用的归一化方法"><a href="#1-常用的归一化方法" class="headerlink" title="1.常用的归一化方法"></a>1.常用的归一化方法</h4><ul>
<li><strong>1.1 缩放归一化</strong>：通过缩放将每一个特征的取值范围归一到 [0, 1]或 [−1, 1]之间。假设有 N 个样本$\left{\mathbf{x}^{(n)}\right}_{n=1}^{N}$，对每一维特征x，<script type="math/tex; mode=display">
\hat{x}^{(n)}=\frac{x^{(n)}-\min _{n}\left(x^{(n)}\right)}{\max _{n}\left(x^{(n)}\right)-\min _{n}\left(x^{(n)}\right)}</script>其中，min(x)和max(x)分别是特征x在所有样本上的最小值和最大值。</li>
<li><strong>1.2 标准归一化</strong>：将每一个维特征都处理为符合标准正态分布（均值为 0，标准差为 1）。假设有 N 个样本$\left{\mathbf{x}^{(n)}\right}_{n=1}^{N}$，对每一维特征x，先计算它的均值和标准差：<script type="math/tex; mode=display">
\begin{aligned} \mu &=\frac{1}{N} \sum_{n=1}^{N} x^{(n)} \\ \sigma^{2} &=\frac{1}{N} \sum_{n=1}^{N}\left(x^{(n)}-\mu\right)^{2} \end{aligned}</script>然后，将特征$x^{(n)}$减去均值，并除以标准差，得到新的特征$\hat{x}^{(n)}$。<script type="math/tex; mode=display">
\hat{x}^{(n)}=\frac{x^{(n)}-\mu}{\sigma}</script>这里$\sigma$不能为0，如果标准差为0，则说明这一维度的特征没有任务的区分性，可以直接删除。<strong>在标准归一化之后，每一维特征都服从标准正态分布。</strong></li>
<li><strong>1.3 白化</strong>：是一种重要的预处理方法，用来降低输入数据特征之间的冗余性。输入数据经过白化处理后，特征之间相关性较低，并且所有特征具有相同的方差。白化的一个主要实现方式是使用主成分分析PCA方法去除掉各个成分之间的相关性。<br>  <img src="https://upload-images.jianshu.io/upload_images/13407176-ef01f35e035469f9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标准归一化与PCA白化对比"></li>
</ul>
<h4 id="2-参考资料"><a href="#2-参考资料" class="headerlink" title="2. 参考资料"></a>2. 参考资料</h4><ul>
<li><a href="https://nndl.github.io/" target="_blank" rel="noopener">邱锡鹏：《神经网络与深度学习》</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复习02统计学习方法(感知机perceptron machine)---图片版</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A002%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%84%9F%E7%9F%A5%E6%9C%BAperceptron-machine-%E5%9B%BE%E7%89%87%E7%89%88/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-2a3396fbb18b0018.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库中的基本概念</title>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<!-- 文字增加背景色块 -->
<!-- <span id="inline-blue"> 站点配置文件 </span>
<span id="inline-purple"> 主题配置文件 </span>
<span id="inline-yellow"> 站点配置文件 </span>
<span id="inline-green"> 主题配置文件 </span> -->
<!-- 下载样式-->
<!-- <a id="download" href="https://git-scm.com/download/win"><i class="fa fa-download"></i><span> Download Now</span> </a> -->
<!-- 文档中增加图标 -->
<!-- <i class="fa fa-pencil"></i>支持Markdown -->
<h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><ul>
<li>数据（data）：描述事物的符号记录称为数据</li>
<li>数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点。</li>
<li><strong>数据库管理系统</strong>（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。</li>
<li>数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。</li>
<li><strong>实体</strong>（entity）：客观存在并可相互区别的事物称为实体。</li>
<li><strong>属性</strong>（attribute）：实体所具有的某一特性称为属性。</li>
<li>码（key）：唯一标识实体的属性集称为码。</li>
<li><strong>实体型</strong>（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</li>
<li><strong>实体集</strong>（entity set）：同一实体型的集合称为实体集。</li>
<li><strong>联系</strong>（relationship）：实体之间的联系通常是指不同实体集之间的联系。</li>
<li><strong>模式</strong>（schema）：<strong>模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述</strong>，是所有用户的公共数据视图。</li>
<li><strong>外模式</strong>（external schema）：<strong>外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述</strong>，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</li>
<li><strong>内模式</strong>（internal schema）：<strong>内模式也称为存储模式（storage schema），一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式</strong>。<h4 id="2-常用数据模型"><a href="#2-常用数据模型" class="headerlink" title="2.常用数据模型"></a>2.常用数据模型</h4></li>
<li>层次模型（hierarchical model）</li>
<li>网状模型（network model）</li>
<li><strong>关系模型</strong>（relational model）<ul>
<li>关系（relation）：一个关系对应通常说的一张表</li>
<li>元组（tuple）：表中的一行即为一个元组</li>
<li>属性（attribute）：表中的一列即为一个属性</li>
<li>码（key）：表中可以唯一确定一个元组的某个属性组</li>
<li>域（domain）：一组具有相同数据类型的值的集合</li>
<li>分量：元组中的一个属性值</li>
<li>关系模式：对关系的描述，一般表示为 关系名(属性1, 属性2, …, 属性n)</li>
</ul>
</li>
<li>面向对象数据模型（object oriented data model）</li>
<li>对象关系数据模型（object relational data model）</li>
<li>半结构化数据模型（semistructure data model）<h4 id="3-常用SQL操作"><a href="#3-常用SQL操作" class="headerlink" title="3.常用SQL操作"></a>3.常用SQL操作</h4><img src="https://upload-images.jianshu.io/upload_images/13407176-05998a954f653817?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常用SQL操作"></li>
<li>更多操作请参见<a href="https://blog.csdn.net/cdlwhm1217096231/article/details/88548483" target="_blank" rel="noopener">我之前总结的数据库基本操作</a><h4 id="4-关系型数据库"><a href="#4-关系型数据库" class="headerlink" title="4.关系型数据库"></a>4.关系型数据库</h4></li>
<li>基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改</li>
<li><strong>关系模型中的三类完整性约束</strong>：实体完整性、参照完整性、用户定义的完整性<h4 id="5-索引"><a href="#5-索引" class="headerlink" title="5.索引"></a>5.索引</h4></li>
<li>数据库索引：顺序索引、B+ 树索引、hash 索引</li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a><h4 id="6-数据库完整性"><a href="#6-数据库完整性" class="headerlink" title="6.数据库完整性"></a>6.数据库完整性</h4></li>
<li>数据库的完整性是指数据的正确性和相容性。<ul>
<li>完整性：为了防止数据库中存在不符合语义（不正确）的数据。</li>
<li>安全性：为了保护数据库防止恶意破坏和非法存取。</li>
</ul>
</li>
<li>触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。<h4 id="7-关系数据理论"><a href="#7-关系数据理论" class="headerlink" title="7.关系数据理论"></a>7.关系数据理论</h4></li>
<li>数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。</li>
<li>最重要的数据依赖：函数依赖、多值依赖。<h4 id="8-范式"><a href="#8-范式" class="headerlink" title="8.范式"></a>8.范式</h4></li>
<li>第一范式（1NF）：<strong>属性（字段）是最小单位不可再分</strong>。强调的是列的原子性，即列不能够再分成其他几列。</li>
<li>第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。首先是1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。</li>
<li>第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖）。首先是2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</li>
<li>鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。</li>
<li>第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。<h4 id="9-数据库恢复"><a href="#9-数据库恢复" class="headerlink" title="9.数据库恢复"></a>9.数据库恢复</h4></li>
<li>事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</li>
<li><strong>事物的 ACID 特性</strong>：原子性、一致性、隔离性、持续性。</li>
<li>恢复的实现技术：建立冗余数据 -&gt; 利用冗余数据实施数据库恢复。</li>
<li>建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。<h4 id="10-并发控制"><a href="#10-并发控制" class="headerlink" title="10.并发控制"></a>10.并发控制</h4></li>
<li><strong>事务是并发控制的基本单位</strong>。</li>
<li>并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。</li>
<li>并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。</li>
<li>基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。</li>
<li>活锁和死锁：<ul>
<li>活锁：事务永远处于等待状态，可通过先来先服务的策略避免。</li>
<li>死锁：事物永远不能结束<ul>
<li>预防：一次封锁法、顺序封锁法；</li>
<li>诊断：超时法、等待图法；</li>
<li>解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。</li>
</ul>
</li>
</ul>
</li>
<li>可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。<h4 id="11-一个完整的数据库设计一般分为以下六个阶段"><a href="#11-一个完整的数据库设计一般分为以下六个阶段" class="headerlink" title="11.一个完整的数据库设计一般分为以下六个阶段"></a>11.一个完整的数据库设计一般分为以下六个阶段</h4></li>
<li>⑴需求分析：分析用户的需求，包括数据、功能和性能需求； </li>
<li>⑵概念结构设计：主要采用E-R模型进行设计，包括画E-R图； </li>
<li>⑶逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型 的转换；   进行关系规范化。 </li>
<li>⑷数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径； </li>
<li>⑸数据库的实施：包括编程、测试和试运行； </li>
<li>⑹数据库运行与维护：系统的运行与数据库的日常维护。<h4 id="12-一个事务执行过程中，其正在访问的数据被其他事务所修改，导致处理结果不正确，这是由于违背了事务的隔离性而引起的！！！"><a href="#12-一个事务执行过程中，其正在访问的数据被其他事务所修改，导致处理结果不正确，这是由于违背了事务的隔离性而引起的！！！" class="headerlink" title="12.一个事务执行过程中，其正在访问的数据被其他事务所修改，导致处理结果不正确，这是由于违背了事务的隔离性而引起的！！！"></a>12.一个事务执行过程中，其正在访问的数据被其他事务所修改，导致处理结果不正确，这是由于违背了事务的<strong>隔离性</strong>而引起的！！！</h4><h4 id="13-having和group-by子句的问题"><a href="#13-having和group-by子句的问题" class="headerlink" title="13.having和group by子句的问题"></a>13.having和group by子句的问题</h4></li>
<li>SQL查询语句中where、group by、having 这些关键字区别和用法总结错误的是：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-6fd53730def4a39a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="问题.png"></li>
<li>A：<strong>1.having只能用在group by之后，对分组后的结果进行筛选，筛选行(即用having的前提条件是分组)</strong>；2.where肯定在group by 之前；3.where后的条件表达式里不允许使用聚合函数，而having可以。<h4 id="14-在视图上使用INSERT语句添加数据时，要遵循的规则："><a href="#14-在视图上使用INSERT语句添加数据时，要遵循的规则：" class="headerlink" title="14.在视图上使用INSERT语句添加数据时，要遵循的规则："></a>14.在视图上使用INSERT语句添加数据时，要遵循的规则：</h4></li>
<li>1.使用INSERT语句向数据表中插入数据时，用户必须有插入数据的权利。</li>
<li>2.由于视图只引用表中的部分字段，所以通过视图插入数据时只能明确指定视图中引用的字段的取值。而那些表中并未引用的字段，必须知道在没有指定取值的情况下如何填充数据，因此视图中未引用的字段必须具备下列条件之一：<ul>
<li>该字段允许空值。</li>
<li>该字段设有默认值。</li>
<li>该字段是标识字段，可根据标识种子和标识增量自动填充数据。</li>
<li>该字段的数据类型为timestamp或uniqueidentifier。</li>
</ul>
</li>
<li>3.视图中不能包含多个字段值的组合，或者包含使用统计函数的结果。</li>
<li>4.视图中不能包含DISTINCT或GROUP BY子句。</li>
<li>5.如果视图中使用了WITH CHECK OPTION，那么该子句将检查插入的数据是否符合视图定义中SELECT语句所设置的条件。如果插入的数据不符合该条件，SQL Server会拒绝插入数据。</li>
<li>6.不能在一个语句中对多个基础表使用数据修改语句。因此，如果要向一个引用了多个数据表的视图添加数据时，必须使用多个INSERT语句进行添加。<h4 id="15-CASCADE与RESTRICT的区别"><a href="#15-CASCADE与RESTRICT的区别" class="headerlink" title="15.CASCADE与RESTRICT的区别"></a>15.CASCADE与RESTRICT的区别</h4></li>
<li>CASCADE表示表的删除没有限制条件，在删除基本表的同时，相关的依赖对象（如视图）都将被删除。</li>
<li>RESTRICT表示表的删除是有条件限制的，要删除的基本表不能被其他表的约束所引用，不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则表不能被删除<h4 id="16-实体完整性、参照完整性和用户定义完整性"><a href="#16-实体完整性、参照完整性和用户定义完整性" class="headerlink" title="16.实体完整性、参照完整性和用户定义完整性"></a>16.实体完整性、参照完整性和用户定义完整性</h4></li>
<li>实体完整性：这条规定的现实意义是，关系模型对应的是现实世界的数据实体，而关键字是实体唯一性的表现，没有关键字就没有实体，所有关键字不能是空值。这是实体存在的最基本的前提，所以称之为实体完整性。</li>
<li>参照完整性：参照完整性规则也可称为引用完整性规则。这条规则是对关系外部关键字的规定，要求外部关键字的取值必须是客观存在的，即不允许在一个关系中引用另一个关系不存在的元组。</li>
<li>用户定义完整性：由用户根据实际情况，对数据库中数据的内容所作的规定称为用户定义的完整性规则。通过这些限制数据库中接受符合完整性约束条件的数据值，不接受违反约束条件的数据，从而保证数据库的数据合理可靠。<h4 id="17-InnoDB和MylSAM"><a href="#17-InnoDB和MylSAM" class="headerlink" title="17.InnoDB和MylSAM"></a>17.InnoDB和MylSAM</h4></li>
<li>InnoDB执行DELETE FROM table 命令时，不会重新建表</li>
<li>MylSAM的索引和数据是分开保存的<h4 id="18-数据库中的DDL-DML-DCL-DQL"><a href="#18-数据库中的DDL-DML-DCL-DQL" class="headerlink" title="18.数据库中的DDL DML DCL DQL"></a>18.数据库中的DDL DML DCL DQL</h4></li>
<li>DDL：数据库模式定义语言，关键字：create、alter、 drop</li>
<li>DML：数据操作语言，关键字：Insert、delete、update</li>
<li>DCL：数据库控制语言 ，关键字：grant、remove</li>
<li>DQL：数据库查询语言，关键字：select<h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4></li>
<li><a href="https://blog.csdn.net/qq_35246620/article/details/70823903" target="_blank" rel="noopener">数据库简明教程</a></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
