<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Curry_Coder的空间</title>
  
  <subtitle>好好学习，天天向上！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cdlwhm1217096231.github.io/"/>
  <updated>2019-08-09T08:12:00.256Z</updated>
  <id>https://cdlwhm1217096231.github.io/</id>
  
  <author>
    <name>Curry_Coder</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++中的基本变量类型介绍</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的基本变量类型介绍/</id>
    <published>2019-08-09T08:11:06.000Z</published>
    <updated>2019-08-09T08:12:00.256Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-cpp变量类型"><a href="#1-cpp变量类型" class="headerlink" title="1.cpp变量类型"></a>1.cpp变量类型</h3><ul><li>变量实际上是存储空间的名称，cpp中每个变量都有指定的类型，类型决定变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可以作用在变量上。</li><li>变量名可以是字母 数字 下划线组成，必须以字母或下划线开头。区分大小写</li><li>几种基本的变量类型：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-160f888c7e02b4fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本的变量类型.png"><h3 id="2-cpp中的变量定义"><a href="#2-cpp中的变量定义" class="headerlink" title="2.cpp中的变量定义"></a>2.cpp中的变量定义</h3></li><li><p>变量定义就是<strong>告诉编译器在何处创建变量的存储，以及如何创建变量的存储</strong>。变量的定义指定一个数据类型，并包含该类型的一个或多个变量的列表，例如：</p>  <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：<span class="keyword">type</span> variable_list;</span><br></pre></td></tr></table></figure></li><li><p>type必须是基本数据类型或用户自定义的数据类型(如 类)，variable_list可以由一个或多个标识符名称组成，<strong>多个标识符之间用逗号分隔</strong>，例如：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, k;  <span class="comment">// 声明并定义了变量i, j, k,指示编译器创建类型为int的名为i,j,k的变量</span></span><br><span class="line"><span class="keyword">char</span> c, d, e;</span><br><span class="line"><span class="keyword">float</span> f, ss;</span><br><span class="line"><span class="keyword">double</span> d;</span><br></pre></td></tr></table></figure></li><li><p>变量可以在声明的时候被初始化，初始化器由一个等号后跟一个常量表达式组成,例如：</p>  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式:  type variable_name = <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> d = <span class="number">3</span>, f = <span class="number">6</span>;  <span class="comment">// d 和 f 的声明</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">3</span>, f = <span class="number">5</span>;  <span class="comment">// 定义并初始化 d 和 f</span></span><br><span class="line"><span class="keyword">byte</span> z = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">char</span> x = <span class="string">'x'</span>;</span><br></pre></td></tr></table></figure></li><li><p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的</p><h3 id="3-cpp中的变量声明"><a href="#3-cpp中的变量声明" class="headerlink" title="3.cpp中的变量声明"></a>3.cpp中的变量声明</h3></li><li>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。<strong>变量声明只在编译时有它的意义</strong>，在程序连接时编译器需要实际的变量声明。</li><li><p>当使用多个文件且<strong>只在其中一个文件中定义变量时</strong>（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。可以使用extern关键字在任何地方声明一个变量。虽然可以在C++程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 变量的定义</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="comment">// 实际初始化</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量的声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 变量的定义</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="comment">// 实际初始化</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="keyword">int</span> i = func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-cpp中的左值和右值"><a href="#4-cpp中的左值和右值" class="headerlink" title="4.cpp中的左值和右值"></a>4.cpp中的左值和右值</h3><ul><li>cpp中的两种类型的表达式：<ul><li>左值：<strong>指向内存位置的表达式被称为左值（lvalue）表达式</strong>。左值可以出现在赋值号的左边或右边。</li><li>右值：<strong>存储在内存中某些地址的数值</strong>。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li></ul></li><li>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int g = <span class="number">20</span>;</span><br><span class="line"><span class="number">10</span> = <span class="number">20</span>;  报错！</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-变量的类型转换"><a href="#5-变量的类型转换" class="headerlink" title="5.变量的类型转换"></a>5.变量的类型转换</h3><ul><li><p>变量的类型间是可以互相转换的，转换又分为自动转换和强制转换。</p><ul><li><p>自动转换规则</p><ul><li>若参与运算量的类型不同，则先转换成同一类型，然后进行运算。</li><li>转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int量转成long型后再进行运算。<ul><li>a、若两种类型的字节数不同，转换成字节数高的类型</li><li>b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型</li></ul></li><li>所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。</li><li>char型和short型参与运算时，必须先转换成int型。</li><li>在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> aa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> bb = <span class="number">2.1</span>;</span><br><span class="line">aa = bb;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"aa = "</span> &lt;&lt; aa &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为 2，丢失小数部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为a + b = 3.1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>强制转换规则</p><ul><li>强制类型转### 1.cpp变量类型</li></ul></li></ul></li><li>变量实际上是存储空间的名称，cpp中每个变量都有指定的类型，类型决定变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可以作用在变量上。</li><li>变量名可以是字母 数字 下划线组成，必须以字母或下划线开头。区分大小写</li><li>几种基本的变量类型：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-160f888c7e02b4fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本的变量类型.png"><h3 id="2-cpp中的变量定义-1"><a href="#2-cpp中的变量定义-1" class="headerlink" title="2.cpp中的变量定义"></a>2.cpp中的变量定义</h3></li><li><p>变量定义就是<strong>告诉编译器在何处创建变量的存储，以及如何创建变量的存储</strong>。变量的定义指定一个数据类型，并包含该类型的一个或多个变量的列表，例如：</p>  <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：<span class="keyword">type</span> variable_list;</span><br></pre></td></tr></table></figure></li><li><p>type必须是基本数据类型或用户自定义的数据类型(如 类)，variable_list可以由一个或多个标识符名称组成，<strong>多个标识符之间用逗号分隔</strong>，例如：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, k;  <span class="comment">// 声明并定义了变量i, j, k,指示编译器创建类型为int的名为i,j,k的变量</span></span><br><span class="line"><span class="keyword">char</span> c, d, e;</span><br><span class="line"><span class="keyword">float</span> f, ss;</span><br><span class="line"><span class="keyword">double</span> d;</span><br></pre></td></tr></table></figure></li><li><p>变量可以在声明的时候被初始化，初始化器由一个等号后跟一个常量表达式组成,例如：</p>  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式:  type variable_name = <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> d = <span class="number">3</span>, f = <span class="number">6</span>;  <span class="comment">// d 和 f 的声明</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">3</span>, f = <span class="number">5</span>;  <span class="comment">// 定义并初始化 d 和 f</span></span><br><span class="line"><span class="keyword">byte</span> z = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">char</span> x = <span class="string">'x'</span>;</span><br></pre></td></tr></table></figure></li><li><p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的</p><h3 id="3-cpp中的变量声明-1"><a href="#3-cpp中的变量声明-1" class="headerlink" title="3.cpp中的变量声明"></a>3.cpp中的变量声明</h3></li><li>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。<strong>变量声明只在编译时有它的意义</strong>，在程序连接时编译器需要实际的变量声明。</li><li><p>当使用多个文件且<strong>只在其中一个文件中定义变量时</strong>（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。可以使用extern关键字在任何地方声明一个变量。虽然可以在C++程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 变量的定义</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="comment">// 实际初始化</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量的声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 变量的定义</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="comment">// 实际初始化</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="keyword">int</span> i = func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-cpp中的左值和右值-1"><a href="#4-cpp中的左值和右值-1" class="headerlink" title="4.cpp中的左值和右值"></a>4.cpp中的左值和右值</h3><ul><li>cpp中的两种类型的表达式：<ul><li>左值：<strong>指向内存位置的表达式被称为左值（lvalue）表达式</strong>。左值可以出现在赋值号的左边或右边。</li><li>右值：<strong>存储在内存中某些地址的数值</strong>。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li></ul></li><li>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int g = <span class="number">20</span>;</span><br><span class="line"><span class="number">10</span> = <span class="number">20</span>;  报错！</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-变量的类型转换-1"><a href="#5-变量的类型转换-1" class="headerlink" title="5.变量的类型转换"></a>5.变量的类型转换</h3><ul><li><p>变量的类型间是可以互相转换的，转换又分为自动转换和强制转换。</p><ul><li><p>自动转换规则</p><ul><li>若参与运算量的类型不同，则先转换成同一类型，然后进行运算。</li><li>转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int型转成long型后再进行运算。<ul><li>a、若两种类型的字节数不同，转换成字节数高的类型</li><li>b、<strong>若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型</strong></li></ul></li><li>所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。</li><li>char型和short型参与运算时，必须先转换成int型。</li><li>在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> aa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> bb = <span class="number">2.1</span>;</span><br><span class="line">aa = bb;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"aa = "</span> &lt;&lt; aa &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为 2，丢失小数部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为a + b = 3.1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>强制转换规则</p><ul><li>强制类型转换是通过类型转换运算来实现的。其一般形式为：<strong>（类型说明符）表达式</strong>其功能是把表达式的运算结果强制转换成类型说明符所表示的类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt; a + (<span class="keyword">int</span>)b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为a + b = 3</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="6-变量定义与声明的区别"><a href="#6-变量定义与声明的区别" class="headerlink" title="6.变量定义与声明的区别"></a>6.变量定义与声明的区别</h3><ul><li>定义包含了声明，但是声明不包含定义,<strong>变量声明是不会为变量开辟内存空间的</strong>,当初始化时，初始化必须有存储空间来进行，此时开始分配内存。如：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;     <span class="comment">//定义并声明了变量 a</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;  <span class="comment">//只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-cpp变量类型&quot;&gt;&lt;a href=&quot;#1-cpp变量类型&quot; class=&quot;headerlink&quot; title=&quot;1.cpp变量类型&quot;&gt;&lt;/a&gt;1.cpp变量类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;变量实际上是存储空间的名称，cpp中每个变量都有指定的类型，类型决定变量
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的基本数据类型介绍</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的基本数据类型介绍/</id>
    <published>2019-08-09T08:08:54.000Z</published>
    <updated>2019-08-09T08:09:33.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-cpp中的基本内置数据类型（7种）"><a href="#1-cpp中的基本内置数据类型（7种）" class="headerlink" title="1.cpp中的基本内置数据类型（7种）"></a>1.cpp中的基本内置数据类型（7种）</h3><ul><li>bool  char  int float double void(无类型) wchar_t(宽字符型)：typedef wchar_t short int;</li><li>一个基本类型可以被一个或多个类型修饰符来修饰。<ul><li>signed</li><li>unsigned</li><li>short</li><li>long</li></ul></li><li>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值(<strong>变量的大小会根据编译器和所使用的电脑而有所不同</strong>)<br><img src="https://upload-images.jianshu.io/upload_images/13407176-b102c5b08a016185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本数据类型.png"><h3 id="2-typedef声明"><a href="#2-typedef声明" class="headerlink" title="2.typedef声明"></a>2.typedef声明</h3></li><li><p>使用typedef为已有的类型取一个新的名字，语法如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：typedef<span class="built_in"> type </span>name;</span><br><span class="line">例如：typedef int feet;  feet是int的另一个名称</span><br><span class="line">     feet distance;  创建一个整型变量distance</span><br></pre></td></tr></table></figure></li><li><p>typedef 可以声明各种类型名，但不能用来定义变量。用 typedef 可以声明数组类型、字符串类型，使用比较方便。</p></li><li>用typedef只是对已经存在的类型增加一个类型名，而没有创造新的类型。</li><li>当在不同源文件中用到同一类型数据（尤其是像数组、指针、结构体、共用体等类型数据）时，常用 typedef 声明一些数据类型，把它们单独放在一个头文件中，然后在需要用到它们的文件中用 ＃include 命令把它们包含进来，以提高编程效率。</li><li>使用 typedef 有利于程序的通用与移植。有时程序会依赖于硬件特性，用 typedef 便于移植。</li><li><p>typedef 与 #define 的区别</p><ul><li><p>2.1 执行时间不同</p><ul><li>关键字 typedef 在编译阶段有效，由于是在编译阶段，因此 typedef 有类型检查的功能。</li><li>#define 则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    UINT value = <span class="string">"abc"</span>;  <span class="comment">// 类型检测，将会报错</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) x*x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>, b = <span class="number">2</span>, c;</span><br><span class="line">    c = f(a) / f(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>2.2 功能上的差异</p><ul><li>typedef 用来定义类型的别名，定义与平台无关的数据类型，与 struct 的结合使用等。</li><li>#define 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</li></ul></li><li><p>2.3 作用域不同</p><ul><li>#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而 typedef 有自己的作用域。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏的作用域</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> HW <span class="meta-string">"helloworld"</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = HW;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// typedef的作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// UNIT uvalue = 5;  报错！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">        UINT uvalueA;</span><br><span class="line">        A(): uvalueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">        <span class="comment">// UINT uvalueB;  报错</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 在B类中使用UINT会出错，因为UINT只在类A的作用域中。</span></span><br><span class="line">    <span class="comment">// 此外，在类中用typedef定义的类型别名还具有相应的访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AA</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">        UINT valueA;</span><br><span class="line">        AA(): valueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// AA::UINT i = 1;报错，在typedef前加上public权限则可以</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>2.4 对指针的操作——二者修饰指针类型时，作用不同</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* pint;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINT int*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> pint p1 = &amp;i1;  <span class="comment">// 等价于int * const p;指针常量:指针p是一个常量,p不可更改，p指向的内容可以更改</span></span><br><span class="line"><span class="keyword">const</span> PINT p2 = &amp;i2;  <span class="comment">// 等价于const int *p/int const *p，p可以更改，p指向的内容不可更改，常量指针</span></span><br><span class="line"></span><br><span class="line">pint s1, s2;  <span class="comment">// s1 和 s2都是int类型指针</span></span><br><span class="line">PINT s3, s4;  <span class="comment">// 相当于 int * s3, s4;只有一个是指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// p1 = &amp;i2; 指针常量p1不能被修改</span></span><br><span class="line">    *p1 = <span class="number">5</span>;   <span class="comment">// 但是p1指向的内容可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// *p2 = 5; 常量指针p2能被修改</span></span><br><span class="line">    p2 = &amp;i1;   <span class="comment">// 但是p2指向的内容不可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-枚举类型"><a href="#3-枚举类型" class="headerlink" title="3.枚举类型"></a>3.枚举类型</h3><ul><li>枚举类型是cpp中的一种派生数据类型，是由用户定义的若干枚举常量的集合</li><li>如果一个变量只有几种可能的值，可以定义为枚举类型。“枚举”就是将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</li><li><p>创建枚举，需要用到关键字enum，枚举类型的一般形式为:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名&#123;</span></span><br><span class="line">    标识符[=整型常量];</span><br><span class="line">    标识符[=整型常量];</span><br><span class="line">    ....</span><br><span class="line">    标识符[=整型常量];</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure></li><li><p>如果枚举没有初始化，即省略掉’=整型常数’时,则从第一个标识开始，如下面的例子，变量c的类型是color,最后被赋值为blue。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>&#123;</span></span><br><span class="line">    red, green, blue</span><br><span class="line">&#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure></li><li><p>默认情况下，第一个名称的值是0，第二个名称的值是1，第三个名称的值是2，依次类推。可以在定义枚举类型时，对枚举元素赋值。此时，赋值的枚举值为所赋的值，而其他没有赋值的枚举值在为前一个枚举值加1，例如下面：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>&#123;</span></span><br><span class="line">    red, greed = <span class="number">5</span>, blue</span><br><span class="line">&#125;;</span><br><span class="line">blue = <span class="number">6</span>,默认情况下，每个名称都会比前一个名称大，但red的值仍然是<span class="number">0</span>.</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-相关代码"><a href="#4-相关代码" class="headerlink" title="4.相关代码"></a>4.相关代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"limits"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x)  x*x  <span class="comment">// 宏定义</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 typedef执行时间不同</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// UINT value = "abc";  类型检测，将出错</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; value &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 作用域不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> HW <span class="meta-string">"helloworld"</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = HW;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// typedef的作用域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// UNIT uvalue = 5;  报错！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">    UINT uvalueA;</span><br><span class="line">    A(): uvalueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="comment">// UINT uvalueB;  报错</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在B类中使用UINT会出错，因为UINT只在类A的作用域中。</span></span><br><span class="line"><span class="comment">// 此外，在类中用typedef定义的类型别名还具有相应的访问权限</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">    UINT valueA;</span><br><span class="line">    AA(): valueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// AA::UINT i = 1;报错，在typedef前加上public权限则可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 对指针的操作---二者修饰指针类型时，作用不同</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* pint;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINT int*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> pint p1 = &amp;i1;  <span class="comment">// 等价于int * const p;指针常量:指针p是一个常量,p不可更改，p指向的内容可以更改</span></span><br><span class="line"><span class="keyword">const</span> PINT p2 = &amp;i2;  <span class="comment">// 等价于const int *p/int const *p，p可以更改，p指向的内容不可更改，常量指针</span></span><br><span class="line"></span><br><span class="line">pint s1, s2;  <span class="comment">// s1 和 s2都是int类型指针</span></span><br><span class="line">PINT s3, s4;  <span class="comment">// 相当于 int * s3, s4;只有一个是指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// p1 = &amp;i2; 指针常量p1不能被修改</span></span><br><span class="line">    *p1 = <span class="number">5</span>;   <span class="comment">// 但是p1指向的内容可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// *p2 = 5; 常量指针p2能被修改</span></span><br><span class="line">    p2 = &amp;i1;   <span class="comment">// 但是p2指向的内容不可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> color&#123;</span><br><span class="line">    red, green, blue=<span class="number">5</span>, yellow</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bool: "</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"char: "</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed char: "</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"short int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned short int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed short int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">short</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed long  int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned long  int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"float: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"double: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long double: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"wchar_t: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> feet;   <span class="comment">// typedef声明,但typedef int feet = 100;错误！</span></span><br><span class="line">    feet distance;</span><br><span class="line">    <span class="comment">// 1 宏定义执行时间不同</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>, b = <span class="number">6</span>, c;</span><br><span class="line">    c = f(a) / f(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TestPointer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"red = "</span> &lt;&lt; red &lt;&lt; <span class="string">" yellow = "</span> &lt;&lt; yellow &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 枚举类型举例</span></span><br><span class="line">    <span class="keyword">enum</span> days&#123;</span><br><span class="line">        one, two, three</span><br><span class="line">    &#125;day;</span><br><span class="line">    day = one;</span><br><span class="line">    <span class="keyword">switch</span>(day)&#123;</span><br><span class="line">        <span class="keyword">case</span> one:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"one"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> two:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"two"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"默认输出"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-cpp中的基本内置数据类型（7种）&quot;&gt;&lt;a href=&quot;#1-cpp中的基本内置数据类型（7种）&quot; class=&quot;headerlink&quot; title=&quot;1.cpp中的基本内置数据类型（7种）&quot;&gt;&lt;/a&gt;1.cpp中的基本内置数据类型（7种）&lt;/h3&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的参数传递方式：传值、传地址、传引用总结</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BC%A0%E5%80%BC%E3%80%81%E4%BC%A0%E5%9C%B0%E5%9D%80%E3%80%81%E4%BC%A0%E5%BC%95%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的参数传递方式：传值、传地址、传引用总结/</id>
    <published>2019-08-09T08:07:01.000Z</published>
    <updated>2019-08-09T08:08:17.786Z</updated>
    
    <content type="html"><![CDATA[<ul><li>指针：指针是一个变量，只不过这个变量中存储的是一个地址，指向内存中的一个单元。</li><li>引用：引用和原变量是同一个东西，只不过是原变量的一个别名。  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">10</span><span class="comment">;  定义一个整型变量a</span></span><br><span class="line">int *p = &amp;a<span class="comment">;  定义一个指向整型变量的指针变量p，该指针指向a的存储单元，即p的值是a存储单元的地址</span></span><br><span class="line">int &amp;<span class="keyword">b </span>= a<span class="comment">;   定义一个整型变量a的引用，a和b是同一个东西，在内存中占用同一个存储单元</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="一、引用的特性："><a href="#一、引用的特性：" class="headerlink" title="一、引用的特性："></a>一、引用的特性：</h3><ul><li>引用在定义时必须初始化</li><li>一个变量可以有多个引用</li><li>引用一旦绑定某个实体，就不能再是其他变量的引用。</li></ul><h3 id="二、引用和指针的区别与联系："><a href="#二、引用和指针的区别与联系：" class="headerlink" title="二、引用和指针的区别与联系："></a>二、引用和指针的区别与联系：</h3><ul><li>1.相同点：<ul><li>底层的实现方式相同，都是按照指针的方式实现的</li></ul></li><li>2.不同点：<ul><li>引用定义的时候必须初始化，指针可以不用初始化；</li><li>引用一旦初始化为指向一个对象，就不能再指向其他对象，而指针可以在任何时候指向任何一个同类型的对象；</li><li>没有空引用，但是有空指针；</li><li>在sizeof中的含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节的个数(在32为平台下，指针求sizeof永远是4)；</li><li>引用++改变的是变量的内容，指针++改变的是指针的指向；</li><li>有多级指针，没有多级引用；</li><li>引用使用起来比指针安全；</li><li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；<h3 id="三、传值、传地址、传引用的区别，哪个更高效？"><a href="#三、传值、传地址、传引用的区别，哪个更高效？" class="headerlink" title="三、传值、传地址、传引用的区别，哪个更高效？"></a>三、传值、传地址、传引用的区别，哪个更高效？</h3></li></ul></li><li>1.传值<ul><li>这种传递方式中，实参和形参是两个不同的地址空间，参数传递的实质是将原函数中变量的值，复制到被调用函数形参所在的存储空间中，这个形参的地址空间在函数执行完毕后，会被回收掉。整个被调用函数对形参的操作，只影响形参对应的地址空间，不影响原函数中变量的值，因为这两个不是同一个存储空间。<br><strong>即使形参的值在函数中发生了变化，实参的值也完全不会受到影响，仍为调用前的值。</strong></li></ul></li><li>2.传地址<ul><li>这种传递方式中，实参是变量的地址，形参是指针类型的变量，在函数中对指针变量的操作，就是对实参（变量地址）所对应的变量的操作，函数调用结束后，原函数中的变量的值将会发生改变。<br><strong>被调用函数中对形参指针所指向的地址中内容的任何改变都会影响到实参。</strong></li></ul></li><li>3.传引用<ul><li>这种传递方式中，形参是引用类型变量，其实就是实参的一个别名，在被调用函数中，对引用变量的所有操作等价于对实参的操作。这样，整个函数执行完毕后，原先的实参的值将会发生改变。<br><strong>被调函数对形参做的任何操作都影响了主调函数中的实参变量。</strong></li></ul></li><li>4.哪种更高效？<ul><li>在内置类型当中三种传递方式的效率上都差不多；</li><li>在自定义类型当中，传引用方式效率的更高效一些，因为它没有对形参进行一次拷贝<h3 id="四、常引用"><a href="#四、常引用" class="headerlink" title="四、常引用"></a>四、常引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;  等价于 <span class="keyword">int</span> *<span class="keyword">const</span> b = a;即引用是一个指针常量（又称常指针，即一个常量，其类型是指针）</span><br><span class="line">常引用：<span class="keyword">const</span> <span class="keyword">int</span> &amp;a=b;等价于<span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> a=b;不仅仅是a这个地址不可修改，而且其指向的内存空间也不可修改。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="五、引用的使用场景"><a href="#五、引用的使用场景" class="headerlink" title="五、引用的使用场景"></a>五、引用的使用场景</h3><ul><li><p>1.给变量起别名</p>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a<span class="comment">;</span></span><br><span class="line">int &amp;<span class="keyword">b </span>= a<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>2.将引用作为函数的参数</p><ul><li>使用引用类型就不必在swap中声明形参是指针变量，指针变量要另外开辟内存单元，其内容是地址。而引用变量不是一个独立的变量，不单独占内存单元。而且在调用swap函数时，只需要传值即可，将引用作为函数的形参更加简单、直观、方便。  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">swap(int </span>&amp;a, int &amp;<span class="keyword">b)</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   int temp<span class="comment">;</span></span><br><span class="line">    temp = a<span class="comment">;</span></span><br><span class="line">    a = <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">b </span>= temp<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>3.返回值</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> _iLeft, <span class="keyword">int</span> _iRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _iLeft + _iRight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引用返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp; _iLeft, <span class="keyword">int</span>&amp; _iRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> iResult = _iLeft + _iRight;</span><br><span class="line"><span class="keyword">return</span> iResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="六、代码实例"><a href="#六、代码实例" class="headerlink" title="六、代码实例"></a>六、代码实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_value</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_pointer</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_reference</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++的函数参数传递方式，可以是传值方式，也可以是传引用方式。</span></span><br><span class="line"><span class="comment">传值的本质是：形参是实参的一份复制。</span></span><br><span class="line"><span class="comment">传引用的本质是：形参和实参是同一个东西。</span></span><br><span class="line"><span class="comment">传值和传引用，对大多数常见类型都是适用的。指针、数组，它们都是数据类型的一种，没啥特殊的</span></span><br><span class="line"><span class="comment">因此,指针作为函数参数传递时，也区分为传值和传引用两种方式。</span></span><br><span class="line"><span class="comment">void fun_1(int a); int类型，传值(复制产生新的变量)</span></span><br><span class="line"><span class="comment">void fun_2(int &amp;a); int类型，传引用(形参和实参是同一个东西)</span></span><br><span class="line"><span class="comment">void fun_3(int *pi); 指针类型，传值(复制产生新的变量)</span></span><br><span class="line"><span class="comment">void fun_4(int *&amp;pi); 指针类型，传引用(形参和实参是同一个东西)</span></span><br><span class="line"><span class="comment">如果希望通过将参数传递到函数中，从而来改变变量的值（比如变量是T a，T表示类型)，</span></span><br><span class="line"><span class="comment">则可以有这2种方式选择：</span></span><br><span class="line"><span class="comment">    1.传a的引用： void my_fun(T &amp;a);</span></span><br><span class="line"><span class="comment">    2.传a的地址： void my_fun(T *a);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 值传递</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">形参意思是被调用函数的参数/变量，实参意思是主调函数中放到括号中的参数/变量。</span></span><br><span class="line"><span class="comment">传值方式下，形参是实参的拷贝：重新建立了变量，变量取值和实参一样。</span></span><br><span class="line"><span class="comment">即实参a和b的值为20和10,形参x和y的值都是20和10；而a与x的地址、b与y的地址并不相同</span></span><br><span class="line"><span class="comment">表明形参x和y是新建的变量，也即实参a, b是从形参复制了一份</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap_by_value(a, b); <span class="comment">// 值传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*-------------------------分界线1------------------*/</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap_by_pointer(&amp;a, &amp;b); <span class="comment">// 值传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*-------------------------分界线2------------------*/</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap_by_reference(a, b); <span class="comment">// 引用传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_value</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 传指针(地址),实质还是传值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_pointer</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 传引用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传引用，传递的是实参本身，而不是实参的一个拷贝，形参的修改就是实参的修改,即值相同，地址也相同</span></span><br><span class="line"><span class="comment">相比于传值，传引用的好处是省去了复制，节约了空间和时间。</span></span><br><span class="line"><span class="comment">假如不希望修改变量的值，那么请选择传值而不是传引用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_reference</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 总结</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">“引用”类型变量的声明方式：变量类型 &amp;变量名;   int &amp;b;</span></span><br><span class="line"><span class="comment">“指针”类型的声明方式：基类型 *变量名;  int *pi;</span></span><br><span class="line"><span class="comment">“指针的引用类型”应当这样声明：基类型 *&amp;变量名   int *&amp;pi;</span></span><br><span class="line"><span class="comment">指针类型，也是有传值、传引用两种函数传参方式的：</span></span><br><span class="line"><span class="comment">    1.指针的传值方式</span></span><br><span class="line"><span class="comment">        void my_fun(int *a, int n);</span></span><br><span class="line"><span class="comment">    2.指针的传引用方式</span></span><br><span class="line"><span class="comment">        void my_fun(int *&amp;pi, int n);</span></span><br><span class="line"><span class="comment">// 普通类型，以int a为例</span></span><br><span class="line"><span class="comment">void myfun(int a)    //传值，产生复制</span></span><br><span class="line"><span class="comment">void myfun(int &amp;a)   //传引用，不产生复制</span></span><br><span class="line"><span class="comment">void myfun(int *a)   //传地址，产生复制，本质上是一种传值，这个值是地址</span></span><br><span class="line"><span class="comment">// 指针类型，以int *a为例</span></span><br><span class="line"><span class="comment">void myfun(int *a)   //传值，产生复制</span></span><br><span class="line"><span class="comment">void myfun(int *&amp;a)  //传引用，不产生复制</span></span><br><span class="line"><span class="comment">void myfun(int **a)   //传地址，产生复制，本质上是一种传值，这个值是指针的地址</span></span><br><span class="line"><span class="comment">// 数组类型，以int a[10]为例</span></span><br><span class="line"><span class="comment">void myfun(int a[], int n) //传值，产生复制</span></span><br><span class="line"><span class="comment">void myfun(int* a, int n) //传值，产生复制，传递的数组首地址</span></span><br><span class="line"><span class="comment">void myfun(int (&amp;arr)[10]) //传引用，不产生复制。需要硬编码数组长度</span></span><br><span class="line"><span class="comment">template&lt;size_t size&gt; void myfun(int (&amp;arr)[size]) //传引用，不产生复制。不需要硬编码数组长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="七、参考博客"><a href="#七、参考博客" class="headerlink" title="七、参考博客"></a>七、参考博客</h3><p><a href="http://www.cnblogs.com/zjutzz" target="_blank" rel="noopener">1.Chris的技术博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;指针：指针是一个变量，只不过这个变量中存储的是一个地址，指向内存中的一个单元。&lt;/li&gt;
&lt;li&gt;引用：引用和原变量是同一个东西，只不过是原变量的一个别名。  &lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>常引用、常量指针、指针常量、指向常量的常指针、空指针与野指针解释</title>
    <link href="https://cdlwhm1217096231.github.io/C/%E5%B8%B8%E5%BC%95%E7%94%A8%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E3%80%81%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E3%80%81%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E5%B8%B8%E6%8C%87%E9%92%88%E3%80%81%E7%A9%BA%E6%8C%87%E9%92%88%E4%B8%8E%E9%87%8E%E6%8C%87%E9%92%88%E8%A7%A3%E9%87%8A/"/>
    <id>https://cdlwhm1217096231.github.io/C/常引用、常量指针、指针常量、指向常量的常指针、空指针与野指针解释/</id>
    <published>2019-08-09T08:05:33.000Z</published>
    <updated>2019-08-09T08:06:20.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、一-基础知识"><a href="#1、一-基础知识" class="headerlink" title="1、一.基础知识"></a>1、一.基础知识</h3><ul><li>引用并非对象</li><li>引用必须初始化</li><li>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</li><li><p>类型要严格匹配</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">10</span>;             <span class="comment">//错误：引用类型的初始值必须是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;              <span class="comment">//错误：此处引用类型的初始值必须是int型对象</span></span><br></pre></td></tr></table></figure></li><li><p>指针本身就是对象</p></li><li>指针的类型要和它指向的对象严格匹配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"><span class="keyword">double</span> *pd = &amp;dval;      <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">double</span> *pd2 = pd;        <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi = pd;            <span class="comment">//错误：指针pi的类型和pd的类型不匹配</span></span><br><span class="line">pi = &amp;dval;              <span class="comment">//错误：试图把double型对象的地址赋给int型指针</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="二-常量引用"><a href="#二-常量引用" class="headerlink" title="二.常量引用"></a>二.常量引用</h3><ul><li>初始化常量引用时允许用任意表达式作为初始值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;       <span class="comment">//正确：允许将const int &amp; 绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;      <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>;        <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;    <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;</span><br><span class="line">r1 = <span class="number">0</span>;                  <span class="comment">//正确</span></span><br><span class="line">r2 = <span class="number">0</span>;                  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="三-常量指针"><a href="#三-常量指针" class="headerlink" title="三.常量指针"></a>三.常量指针</h3><ul><li>定义： 又叫常指针，可以理解为常量的指针，也即这个是指针，但指向的是个常量，这个常量是指针的值（地址），而不是地址指向的值。</li><li>关键点：<ul><li>1.常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改；</li><li>2.常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值；指针指向的地址可以改变，但指针指向的地址所对应的内容不可以改变</li><li>3.指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；</li></ul></li><li>代码形式：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;  <span class="keyword">const</span> <span class="keyword">int</span>* p;</span><br></pre></td></tr></table></figure></li></ul><h3 id="四-指针常量"><a href="#四-指针常量" class="headerlink" title="四.指针常量"></a>四.指针常量</h3><ul><li>定义：本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。</li><li>关键点：<ul><li>1.指针常量的值是指针，这个值是常量，不能被修改；指向的地址不可以改变，但指向的地址所对应的内容可以改变</li><li>2.指针本身是常量，指针指向的地址不可以变化,但是指针指向的地址所对应的内容可以变化；</li></ul></li><li>代码形式:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure></li></ul><h3 id="五-指向常量的常指针"><a href="#五-指向常量的常指针" class="headerlink" title="五.指向常量的常指针"></a>五.指向常量的常指针</h3><ul><li>定义：指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。</li><li>关键点：<ul><li>1.一个指针常量，指向的是一个指针对象；</li><li>2.它指向的指针对象且是一个常量，即它指向的对象不能变化；</li></ul></li><li>代码形式：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure></li></ul><h3 id="六-那如何区分这几类呢"><a href="#六-那如何区分这几类呢" class="headerlink" title="六.那如何区分这几类呢?"></a>六.那如何区分这几类呢?</h3><ul><li><p>带两个const的肯定是指向常量的常指针，很容易理解，主要是如何区分常量指针和指针常量.</p><ul><li><p>一种方式是看 * 和 const 的排列顺序，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;    <span class="comment">//const * 即常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;    <span class="comment">//const * 即常量指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;    <span class="comment">//* const 即指针常量</span></span><br></pre></td></tr></table></figure></li><li><p>还一种方式是看const离谁近，即从右往左看，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;    <span class="comment">//const修饰的是*p，即*p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改；</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;    <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;    <span class="comment">//const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------常量指针-------</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line">a = <span class="number">300</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line"><span class="comment">//*p1 = 56;  //Error,*p1是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">p1 = &amp;b;     <span class="comment">//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针常量-------//</span></span><br><span class="line"><span class="keyword">int</span>*  <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">a = <span class="number">500</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line">*p2 = <span class="number">400</span>;   <span class="comment">//OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</span></span><br><span class="line"><span class="comment">//p2 = &amp;b;     //Error,因为p2是const 指针，因此不能改变p2指向的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指向常量的常量指针-------//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">//*p3 = 1;    //Error</span></span><br><span class="line"><span class="comment">//p3 = &amp;b;    //Error</span></span><br><span class="line">a = <span class="number">5000</span>;    <span class="comment">//OK,仍然可以通过原来的声明修改值</span></span><br></pre></td></tr></table></figure></li><li><p>在实际应用中，常量指针要比指针常量用的多，比如常量指针经常用在函数传参中，以避免函数内部修改内容。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>* src); <span class="comment">//常量指针，src的值不可改变；</span></span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> b[] = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">size_t</span> a1 = <span class="built_in">strlen</span>(a);</span><br><span class="line"><span class="keyword">size_t</span> b1 = <span class="built_in">strlen</span>(b);</span><br><span class="line">虽然a、b是可以修改的，但是可以保证在<span class="built_in">strlen</span>函数内部不会修改a、b的内容。</span><br></pre></td></tr></table></figure></li></ul><h3 id="七-空指针与野指针"><a href="#七-空指针与野指针" class="headerlink" title="七.空指针与野指针"></a>七.空指针与野指针</h3><ul><li>空指针就是保存地址为空的指针，使用指针时必须先判断是否空指针，很多问题都是这一步导致的。</li><li>野指针是在delete掉指针之后，没有置0，导致指针随意指向了一个内存地址，如果继续使用，会造成不可预知的内存错误。另外指针的误用很容易造成BUG或者内存泄漏。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------空指针-------//</span></span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//printf("%d",*p4); //运行Error，使用指针时必须先判断是否空指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------野指针（悬浮、迷途指针）-------//</span></span><br><span class="line"><span class="keyword">int</span> *p5 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">delete</span> p5;</span><br><span class="line">p5 = <span class="literal">NULL</span>; <span class="comment">//一定要有这一步</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*p5);  <span class="comment">//隐藏bug，delete掉指针后一定要置0，不然指针指向位置不可控，运行中可导致系统挂掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针的内存泄漏-------//</span></span><br><span class="line"><span class="keyword">int</span> *p6 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">6</span>);</span><br><span class="line">p6 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">7</span>); <span class="comment">//p6原本指向的那块内存尚未释放，结果p6又指向了别处，原来new的内存无法访问，也无法delete了，造成memory leak</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="八-参考资料"><a href="#八-参考资料" class="headerlink" title="八.参考资料"></a>八.参考资料</h3><ul><li><a href="http://www.runoob.com/w3cnote/c-constant-pointer.html" target="_blank" rel="noopener">1.菜鸟教程</a></li><li><a href="http://www.cnblogs.com/lizhenghn/p/3630405.html" target="_blank" rel="noopener">2.C++中指针常量和常量指针的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、一-基础知识&quot;&gt;&lt;a href=&quot;#1、一-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1、一.基础知识&quot;&gt;&lt;/a&gt;1、一.基础知识&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;引用并非对象&lt;/li&gt;
&lt;li&gt;引用必须初始化&lt;/li&gt;
&lt;li&gt;引用只能绑定在
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++实现斐波那契数列</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-实现斐波那契数列/</id>
    <published>2019-08-09T08:00:45.000Z</published>
    <updated>2019-08-09T08:01:40.590Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方法和循环方法的对比</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归方法代码实现比较简洁，但是性能不如循环方法，还会出现栈溢出的问题，优先采用递归的方法！</span></span><br><span class="line"><span class="comment">搜索路径的题目：一般使用回溯法，回溯法很适合使用递归方法的代码来实现！当要求不能使用递归实现的时候，考虑使用栈模拟递归的过程</span></span><br><span class="line"><span class="comment">求某个问题的最优解时，并且该问题可以拆分为多个子问题时：可以尝试使用动态规划的方法！在使用自上而下的递归思路去分析动态规划问题时，会发现子问题之间存在重叠</span></span><br><span class="line"><span class="comment">的更小的子问题。为了避免不必要的重复计算，使用自下而上的循环代码来实现，即把子问题的最优解先计算出来并用数组保存下来，然后基于子问题的解计算大问题的解。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特殊情况：在分解子问题的时候存在某个特殊的选择，采用这个特殊的选择将一定那个得到最优解，则此题目可能适用于贪心算法！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FibByRecursive</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> FibByRecursive(n<span class="number">-1</span>) + FibByRecursive(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first=<span class="number">0</span>, second=<span class="number">1</span>, third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            second = first;</span><br><span class="line">            third = second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的文件读写操作(4)</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-4/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的文件读写操作-4/</id>
    <published>2019-08-09T08:00:03.000Z</published>
    <updated>2019-08-09T08:00:23.616Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sstream"</span>    <span class="comment">// 使用istringstream所需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">string头文件定义了三个类型来支持内存IO:</span></span><br><span class="line"><span class="comment">    istringstream向string读取数据</span></span><br><span class="line"><span class="comment">    ostringstrream向string写入数据</span></span><br><span class="line"><span class="comment">    stringstream既可以从string读数据也可以向string写数据，就像string是一个IO流一样</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// istringstream的用法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"hello world! I am Lee."</span>;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(is &gt;&gt; s)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的文件读写操作(3)</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-3/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的文件读写操作-3/</id>
    <published>2019-08-09T07:58:51.000Z</published>
    <updated>2019-08-09T07:59:40.615Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 如果源文件中的每行数据数量不一样，demo2中的方法就不行了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Num_3, Num_2;</span><br><span class="line">    <span class="keyword">int</span> v, w, weight;</span><br><span class="line">    ifstream infile;  <span class="comment">// 读操作,输入流</span></span><br><span class="line">    ofstream outfile; <span class="comment">// 写操作，输出流</span></span><br><span class="line">    infile.open(<span class="string">"E:\\C++\\cpp_Code\\data1.txt"</span>, ios::in);</span><br><span class="line">    <span class="keyword">if</span> (!infile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件操作失败...\n"</span>;</span><br><span class="line">    infile &gt;&gt; Num_3 &gt;&gt; Num_2;  <span class="comment">// 先读取第一行</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>!=Num_3)&#123;  <span class="comment">// 读取第3个数据</span></span><br><span class="line">        infile &gt;&gt; v &gt;&gt; w &gt;&gt; weight;</span><br><span class="line">        cost[v][w] = weight;</span><br><span class="line">        cost[w][v] = weight;</span><br><span class="line">        Num_3--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>!=Num_2)&#123;  <span class="comment">// 读取第2个数据</span></span><br><span class="line">        infile &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        cost[v][w] = <span class="number">100</span>;</span><br><span class="line">        cost[w][v] = <span class="number">100</span>;</span><br><span class="line">        Num_2--;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    outfile.open(<span class="string">"E:\\C++\\cpp_Code\\result1.txt"</span>, ios::out);</span><br><span class="line">    <span class="keyword">if</span>(!outfile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败\n"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">10</span>;j++)&#123;</span><br><span class="line">            outfile &lt;&lt; i &lt;&lt; <span class="string">"\t"</span> &lt;&lt; j &lt;&lt; <span class="string">"\t"</span> &lt;&lt; cost[i][j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的文件读写操作(2)</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-2/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的文件读写操作-2/</id>
    <published>2019-08-09T07:57:52.000Z</published>
    <updated>2019-08-09T07:58:30.591Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo1中是向文件中写入string类型，下面是向文件中写入int类型</span></span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v, w, weight;</span><br><span class="line">    ifstream infile;  <span class="comment">// 读操作</span></span><br><span class="line">    ofstream outfile;  <span class="comment">// 写操作</span></span><br><span class="line">    infile.open(<span class="string">"E:\\C++\\cpp_Code\\data.txt"</span>, ios::in);</span><br><span class="line">    <span class="keyword">if</span> (! infile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(!infile.eof())&#123;</span><br><span class="line">        infile &gt;&gt; v &gt;&gt; w &gt;&gt; weight;</span><br><span class="line">        cost[v][w] = weight;</span><br><span class="line">        cost[w][v] = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line"></span><br><span class="line">    outfile.open(<span class="string">"E:\\C++\\cpp_Code\\result.txt"</span>, ios::app);</span><br><span class="line">    <span class="keyword">if</span>(!outfile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j!=<span class="number">10</span>;++j)&#123;</span><br><span class="line">            outfile &lt;&lt; i &lt;&lt; <span class="string">"\t"</span> &lt;&lt; j &lt;&lt; <span class="string">"\t"</span> &lt;&lt; cost[i][j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的文件读写操作(1)</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-1/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的文件读写操作-1/</id>
    <published>2019-08-09T07:55:56.000Z</published>
    <updated>2019-08-09T07:56:47.424Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">ofstream  文件写操作，内存写入存储设备</span></span><br><span class="line"><span class="comment">ifstream  文件读操作，存储设备读取到内存中</span></span><br><span class="line"><span class="comment">fstream   读写操作，对打开的文件可进行读写操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件打开模式：</span></span><br><span class="line"><span class="comment">    ios::in   只读</span></span><br><span class="line"><span class="comment">    ios::out  只写</span></span><br><span class="line"><span class="comment">    ios::app  从文件末尾开始写，防止丢失文本中原有的内容，追加模式</span></span><br><span class="line"><span class="comment">    ios::binary 二进制模式</span></span><br><span class="line"><span class="comment">    ios::nocreate 打开一个文件时，如果文件不存在，不创建</span></span><br><span class="line"><span class="comment">    ios::noreplace 打开一个文件时，如果文件不存在，创建该文件</span></span><br><span class="line"><span class="comment">    ios::trunc   打开一个文件时，然后清空内容</span></span><br><span class="line"><span class="comment">    ios::ate     打开一个文件时，将位置移动到文件末尾</span></span><br><span class="line"><span class="comment">文件指针位置的C++中的用法：</span></span><br><span class="line"><span class="comment">    ios::beg   文件开头</span></span><br><span class="line"><span class="comment">    ios::end   文件末尾</span></span><br><span class="line"><span class="comment">    ios::cur   文件当前位置</span></span><br><span class="line"><span class="comment">    举个例子：</span></span><br><span class="line"><span class="comment">        file.seekg(0, ios::beg)  让文件指针定位到文件开头</span></span><br><span class="line"><span class="comment">        file.seekg(0, ios::end)  让文件指针定位到文件末尾</span></span><br><span class="line"><span class="comment">        file.seekg(10, ios::cur) 让文件指针从当前位置向文件末尾方向移动10个字节</span></span><br><span class="line"><span class="comment">        file.seekg(-10, ios::cur) 让文件指针从当前位置向文件开始方向移动10个字节</span></span><br><span class="line"><span class="comment">        file.seekg(10,ios::beg)   让文件指针定位到离文件开头10个字节的位置</span></span><br><span class="line"><span class="comment">常用的错误判断方法:</span></span><br><span class="line"><span class="comment">    good()   如果文件打开成功</span></span><br><span class="line"><span class="comment">    bad()    打开文件时发生错误</span></span><br><span class="line"><span class="comment">    eof()    到达文件尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取hello.txt文件中的字符串，写入out.txt中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"E:\\C++\\cpp_Code\\hello.txt"</span>)</span></span>;  <span class="comment">// 读操作</span></span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"E:\\C++\\cpp_Code\\out.txt"</span>)</span></span>;   <span class="comment">// 写操作</span></span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(! infile.is_open())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(getline(infile, temp))&#123;  </span><br><span class="line">        outfile &lt;&lt; temp;</span><br><span class="line">        outfile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">getline()函数的作用：从输入字节流中读入字符，存到string变量中</span></span><br><span class="line"><span class="comment">直到遇到下面的情况停止：</span></span><br><span class="line"><span class="comment">    读入了文件结束标志</span></span><br><span class="line"><span class="comment">    读到一个新行</span></span><br><span class="line"><span class="comment">    达到字符串的最大穿长度</span></span><br><span class="line"><span class="comment">    如果getline没有读入字符，将返回false，用于判断文件是否结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>复习07统计学习方法(支持向量机SVM)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A007%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习07统计学习方法-支持向量机SVM-图片版/</id>
    <published>2019-08-08T09:19:10.000Z</published>
    <updated>2019-08-08T09:19:38.978Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-e4c4763e681374ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-c1ff663b44869d2d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-de40ae539a1594b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-06a7b0733b4a897f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-9e0578690b11ea48.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-e4c4763e681374ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习06统计学习方法(Logistic回归与最大熵模型)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A006%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-Logistic%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习06统计学习方法-Logistic回归与最大熵模型-图片版/</id>
    <published>2019-08-08T09:18:28.000Z</published>
    <updated>2019-08-08T09:18:51.537Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-23330af289b7990d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-c546a04832004463.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-43f59ed14e078287.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-f62301a284aa666e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-23330af289b7990d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习05统计学习方法(决策树算法Decision Tree)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A005%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95Decision-Tree-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习05统计学习方法-决策树算法Decision-Tree-图片版/</id>
    <published>2019-08-08T09:17:29.000Z</published>
    <updated>2019-08-08T09:18:03.467Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-949bf3d21a6cd513.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-89551868a0657f58.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-db3b56affe58f09f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-fb1b2f4fd7c44637.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-15c3694d44fe89d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-949bf3d21a6cd513.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习04统计学习方法(朴素贝叶斯算法Naive Bayes)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A004%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95Naive-Bayes-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习04统计学习方法-朴素贝叶斯算法Naive-Bayes-图片版/</id>
    <published>2019-08-08T09:16:37.000Z</published>
    <updated>2019-08-08T09:17:08.698Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-6db2674e97151f85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-9ca54696ca36e9db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-6db2674e97151f85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习03统计学习方法(K近邻算法KNN)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A003%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95KNN-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习03统计学习方法-K近邻算法KNN-图片版/</id>
    <published>2019-08-08T09:15:49.000Z</published>
    <updated>2019-08-08T09:16:18.163Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-a32e76e75c8fe185.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KNN"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-a32e76e75c8fe185.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常见的距离函数总结</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/常见的距离函数总结/</id>
    <published>2019-08-08T09:14:30.000Z</published>
    <updated>2019-08-08T09:37:55.424Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-距离函数总结"><a href="#1-距离函数总结" class="headerlink" title="1.距离函数总结"></a>1.距离函数总结</h4><ul><li><strong>闵可夫斯基距离</strong>：<script type="math/tex; mode=display">\text { distance( }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left(\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{p}\right)^{1 / p}</script></li><li>当p=2时，闵可夫斯基距离就是<strong>欧式距离</strong>：<script type="math/tex; mode=display">\operatorname{distance}\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{2}=\sqrt{\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{2}}</script></li><li>当p=1时，闵可夫斯基距离就是<strong>曼哈顿距离</strong>：<script type="math/tex; mode=display">\text { distance }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{1}=\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|</script></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-距离函数总结&quot;&gt;&lt;a href=&quot;#1-距离函数总结&quot; class=&quot;headerlink&quot; title=&quot;1.距离函数总结&quot;&gt;&lt;/a&gt;1.距离函数总结&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;闵可夫斯基距离&lt;/strong&gt;：&lt;script type=&quot;m
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习01统计学习方法(机器学习中的重要概念)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A001%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习01统计学习方法-机器学习中的重要概念-图片版/</id>
    <published>2019-08-08T09:12:35.000Z</published>
    <updated>2019-08-08T09:13:51.004Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-f39bf23781f1aac2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-fa87d164d7048479?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-f39bf23781f1aac2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; al
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法岗面试常见问题大集合</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E5%B2%97%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%A7%E9%9B%86%E5%90%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/算法岗面试常见问题大集合/</id>
    <published>2019-07-30T14:51:47.000Z</published>
    <updated>2019-08-01T07:08:31.550Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-参考博客"><a href="#1-参考博客" class="headerlink" title="1.参考博客"></a>1.参考博客</h4><ul><li><a href="https://www.nowcoder.com/ta/review-ml?query=&amp;asc=true&amp;order=&amp;page=1" target="_blank" rel="noopener">算法岗面试常见问题大集合</a></li><li><a href="http://www.huaxiaozhuan.com/" target="_blank" rel="noopener">算法工程师手册</a></li></ul><h4 id="2-模型过拟合的解决方法"><a href="#2-模型过拟合的解决方法" class="headerlink" title="2.模型过拟合的解决方法"></a>2.模型过拟合的解决方法</h4><ul><li>L1/L2正则化（原理奥卡姆剃刀）:L2正则化也叫作权重衰减，目标函数中增加所有权重w参数的平方之和，迫使所有w可能趋向0但不为0；L1正则化在损失函数中加入所有权重参数w的绝对值之和，迫使更多的w为0，使特征变得稀疏。</li><li>Batch Normalization（对神经网络中下一层的输入进行归一化处理，使得输入量的均值为0，方差为1，即通过特征归一化，加速模型的训练）</li><li>shortcut-connect(使用残差网络Residual network)</li><li>数据增强(增加样本的数量)</li><li>early stopping</li><li>Dropout：在训练过程中，让神经元以超参数p的概率被激活(也就是说1-p的概率被设置为0)，类似于bagging算法</li></ul><h4 id="3-如何解决样本类别的不均衡问题？"><a href="#3-如何解决样本类别的不均衡问题？" class="headerlink" title="3.如何解决样本类别的不均衡问题？"></a>3.如何解决样本类别的不均衡问题？</h4><ul><li>a.过采样/上采样：增加类别少的样本数量实现样本数量的均衡。具体是通过复制类别上的样本构成多条数据。此方法的缺点是当样本的特征很少时，容易出现过拟合。需要对过采样方法进行改进，改进的方法是：在类别少的样本中加入噪声、干扰数据或通过一定的规则产生新合成的样本，如smote算法。</li><li>b.欠采样/下采样：减少类别多的样本数量，一般的方法是随机地去掉一些类别多的样本。</li><li>c.调整正负样本的惩罚权重：对类别少的样本赋予高的权重，对类别多的样本赋予低的权重。</li><li>d.通过集成学习的方法：每次生成训练集时，使用所有类别少的样本，同时从类别多的样本中随机抽取数据与类别少的样本合并起来，构成一个新的训练集。</li><li>e.使用特征选择：一般样本不均衡也会导致特征不均衡。但如果类别少的样本量具有一定的规模时，则意味着其特征的分布较为均匀，可以选择出具有显著特征配合参与解决样本不均衡的问题。</li></ul><h4 id="4-在神经网络训练过程中，为什么会出现梯度消失的问题？如何防止？"><a href="#4-在神经网络训练过程中，为什么会出现梯度消失的问题？如何防止？" class="headerlink" title="4.在神经网络训练过程中，为什么会出现梯度消失的问题？如何防止？"></a>4.在神经网络训练过程中，<strong>为什么会出现梯度消失的问题？如何防止</strong>？</h4><ul><li>原因：使用了不合适的激活函数，例如sigmoid函数。此时，当神经网络的层数很深时，利用链式求导法则计算梯度时，损失函数的梯度连乘，导致乘积会变得越来越小接近于0，从而神经网络无法学习到新的信息。</li><li>解决方法：<ul><li>预训练加微调</li><li>梯度剪切</li><li>权重正则化</li><li>使用不同的激活函数</li><li>使用Batch Normalization</li><li>使用残差网络ResNet</li><li>使用LSTM网络</li></ul></li></ul><h4 id="5-介绍一下TensorFlow中的计算图"><a href="#5-介绍一下TensorFlow中的计算图" class="headerlink" title="5.介绍一下TensorFlow中的计算图"></a>5.介绍一下TensorFlow中的计算图</h4><ul><li>TensorFlow是一个通过计算图的形式来表述计算的编程系统，计算图也叫作数据流图。可以把计算图看做是一种有向图，TensorFlow中的每个节点都是计算图上的一个张量Tensor，而节点之间的边描述了计算之间的依赖关系和数学运算。</li></ul><h4 id="6-K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。"><a href="#6-K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。" class="headerlink" title="6.K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。"></a>6.K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。</h4><ul><li>欧式距离最常见的是两个或多个点之间的距离表示法，又称为欧几里得距离。也就是通常所说的L2范数，公式如下。欧式距离的缺点是它将样本的不同属性之间的差别等同看待，这一点有时候不能满足实际要求。<script type="math/tex; mode=display">d(x, y) :=\sqrt{\left(x_{1}-y_{1}\right)^{2}+\left(x_{2}-y_{2}\right)^{2}+\cdots+\left(x_{n}-y_{n}\right)^{2}}=\sqrt{\sum_{i=1}^{n}\left(x_{i}-y_{i}\right)^{2}}</script></li><li>曼哈顿距离，也就是欧式空间中的在直角坐标系上两个点所形成的线段对轴产生的投影的距离总和。也就是我们所说的L1距离。例如，坐标(x1,y1)的点P1与坐标(x2, y2)的点P2的曼哈顿距离计算公式为：<script type="math/tex; mode=display">\left|x_{1}-x_{2}\right|+\left|y_{1}-y_{2}\right|</script></li></ul><h4 id="7-参数模型与非参数模型"><a href="#7-参数模型与非参数模型" class="headerlink" title="7.参数模型与非参数模型"></a>7.参数模型与非参数模型</h4><ul><li>参数模型：根据预先设计的规则，例如方差损失最小，进行学习，参数模型例子：回归（线性回归、逻辑回归）模型；最好可以看一下或者直接进行一下相关的推导；根据规则，拥有少部分数据就可以；</li><li>非参数模型：不需要事先假设规则，直接挖掘潜在数据中的规则；非参数模型例子：KNN，决策树，挖掘数据潜在的特征，所以比较灵活；</li></ul><h4 id="8-生成模型与判别模型"><a href="#8-生成模型与判别模型" class="headerlink" title="8.生成模型与判别模型"></a>8.生成模型与判别模型</h4><ul><li>生成模型：根据数据学习联合概率分布P(x,y)，从而计算出条件概率分布P(y|x)作为预测的模型。常用于含有隐变量的模型，例如HMM，朴素贝叶斯算法、高斯混合模型GMM、文档主题生成模型LDA、限制玻尔兹曼机等</li><li>判别模型：根据数据直接学习条件概率分布P(x|y)或者决策函数Y=f(X)作为预测模型。例如：逻辑回归、RF、SVM、神经网络、感知机、KNN、CRF等</li><li>两者的对比：<ul><li>使用生成式方法得到的模型，可以还原出模型的联合概率分布，而判别模型不可以；</li><li>生成式方法得到的模型收敛速度更快。当样本数增加时，生成式方法得到的模型能更快的收敛到真实模型；</li><li>存在隐变量时，只能使用生成模型；</li><li>使用判别式方法学习得到的模型，直接面对预测，学习的准确率通常更高，可以简化学习问题。</li></ul></li></ul><h4 id="9-LR和SVM的联系和区别？"><a href="#9-LR和SVM的联系和区别？" class="headerlink" title="9.LR和SVM的联系和区别？"></a>9.LR和SVM的联系和区别？</h4><ul><li>联系：<ul><li>LR和SVM都可以处理分类问题，且一般都用于处理线性二分类问题</li><li>两个方法都可以增加不同的正则化项，如L1、L2正则化项</li></ul></li><li>区别：<ul><li>LR是参数模型，SVM是非参数模型</li><li>从损失函数来看，LR使用的是交叉熵损失函数，SVM使用的hinge损失函数，这两个损失函数的目的都是增加对分类影响较大的样本点的权重，减小与分类关系比较小的数据点的权重。</li><li>SVM的处理方法只考虑支持向量，也就是只考虑和分类最相关的少数样本点来学习分类器。而逻辑回归通过非线性映射，大大减小了离分离超平面远的样本点权重，相对提升了与分类最相关的样本点的权重。</li><li>LR模型相对来说简单好理解，一般用于大规模的线性分类。SVM的理解和优化比较复杂，在处理复制非线性分类时，使用核技巧来计算优势明显。</li><li>LR能做的SVM也能做，但可能准确率是上有问题，但SVM能做的LR做不了。</li></ul></li></ul><h4 id="10-神经网络中参数量parameters和FLOPs计算"><a href="#10-神经网络中参数量parameters和FLOPs计算" class="headerlink" title="10.神经网络中参数量parameters和FLOPs计算"></a>10.神经网络中参数量parameters和FLOPs计算</h4><ul><li>CNN中的parameters分为两种：W和b，<strong>对于某一个卷积层，它的parameters的个数为</strong>:<script type="math/tex; mode=display">\left(K_{h} * K_{w} * C_{i n}\right) * C_{o u t}+C_{o u t}</script>其中，$K<em>{h}$是卷积核的高度，$K</em>{w}$是卷积核的宽度,$C<em>{in}$是输入的通道数，$C</em>{out}$是输出的通道数</li><li><strong>对于某个全连接层</strong>，如果输入的数据有$N<em>{in}$个节点，输出的数据有$N</em>{out}$个节点，它的参数个数为：<script type="math/tex; mode=display">N_{i n} * N_{o u t}+N_{o u t}</script></li><li>FLOPs：<strong>全称是floating point operations per second，指的是每秒浮点运算次数，即用来衡量硬件的计算性能</strong></li><li><strong>对于某个卷积层</strong>,它的FLOPs数量是：<script type="math/tex; mode=display">\left[\left(K_{h} * K_{w} * C_{i n}\right) * C_{o u t}+C_{o u t}\right] *(H * W)=n u m_{-} \text { params } *(H * W)</script>其中，$num_{params}$表示该层参数的数量，H是输出图片的高，W是输出图片的宽</li><li><strong>例题1：假设你的输入是一个300×300的彩色（RGB）图像，而你没有使用卷积神经网络。 如果第一个隐藏层有100个神经元，每个神经元与输入层进行全连接，那么这个隐藏层有多少个参数（包括偏置参数）</strong>？</li><li>A1：因为输入的节点数量是300*300*3,输出的节点数量是100。然后加上偏置项b，因为隐藏层有100个节点，每个节点都有一个偏置，所以b=100。利用上面计算全连接网络的公式，故3*300*300*100+100</li><li><strong>例题2：假设你的输入是300×300彩色（RGB）图像，并且你使用卷积层和100个过滤器，每个过滤器都是5×5的大小，请问这个隐藏层有多少个参数（包括偏置参数）</strong>？</li><li>A2：首先，参数和输入的图片大小是没有关系的，无论你给的图像像素有多大，参数值都是不变的，在这个题中，参数值只与过滤器有关。单个过滤器的大小是5*5,由于输入的是RGB图像，所以输入通道数目是3。因此一个过滤器的组成是5*5*3,每一过滤器只有一个偏置项b,因此一个过滤器所拥有的参数是5*5*3+1=76，一共用了100个过滤器，所以隐藏层含有76*100=7600个参数。其实，也就是上面的公式计算CNN的参数量。</li></ul><h4 id="11-SVM中常见的几种核函数"><a href="#11-SVM中常见的几种核函数" class="headerlink" title="11.SVM中常见的几种核函数"></a>11.SVM中常见的几种核函数</h4><ul><li>线性核函数：内积公式<script type="math/tex; mode=display">\kappa\left(x_{1}, x_{2}\right)=\left\langle x_{1}, x_{2}\right\rangle</script></li><li>多项式核函数<script type="math/tex; mode=display">K(x, z)=(x \cdot z+1)^{p}</script></li><li>高斯核函数<script type="math/tex; mode=display">K(x, z)=\exp \left(-\frac{\|x-z\|^{2}}{2 \sigma^{2}}\right)</script></li><li>字符串核函数：详见李航统计学习方法</li></ul><h4 id="12-逻辑回归与线性回归的联系与区别"><a href="#12-逻辑回归与线性回归的联系与区别" class="headerlink" title="12.逻辑回归与线性回归的联系与区别"></a>12.逻辑回归与线性回归的联系与区别</h4><ul><li>联系：逻辑回归和线性回归首先都是广义的线性回归；逻辑回归的模型本质上是一个对数线性回归模型，逻辑回归都是以线性回归为理论支持的。但线性回归模型无法做到sigmoid的非线性形式，sigmoid可以轻松处理0/1分类问题。</li><li>区别：<ul><li>线性模型的优化目标函数是最小二乘，而逻辑回归则是似然函数</li><li>线性回归在整个实数域范围内进行预测，敏感度一致；而分类范围，需要在[0,1]。逻辑回归就是一种减小预测范围，将预测值限定为[0,1]间的一种回归模型，因而对于这类问题来说，逻辑回归的鲁棒性比线性回归的要好。</li></ul></li></ul><h4 id="13-XGBoost为什么要用泰勒公式展开，优势在哪"><a href="#13-XGBoost为什么要用泰勒公式展开，优势在哪" class="headerlink" title="13.XGBoost为什么要用泰勒公式展开，优势在哪?"></a>13.XGBoost为什么要用泰勒公式展开，优势在哪?</h4><ul><li>XGBoost使用了一阶和二阶偏导, 二阶导数有利于梯度下降的更快更准。使用泰勒展开取得二阶倒数形式, 可以在不选定损失函数具体形式的情况下用于算法优化分析.本质上也就把损失函数的选取和模型算法优化和参数选择分开了，这种去耦合增加了XGBoost的适用性。</li></ul><h4 id="14-XGBoost如何寻找最优特征？是有放回还是无放回？"><a href="#14-XGBoost如何寻找最优特征？是有放回还是无放回？" class="headerlink" title="14.XGBoost如何寻找最优特征？是有放回还是无放回？"></a>14.XGBoost如何寻找最优特征？是有放回还是无放回？</h4><ul><li>XGBoost在训练过程中给各个特征的增益评分，最大增益的特征会被选出来作为分裂的依据，从而记忆了每个特征对在模型训练时的重要性。XGBoost属于boosting的集成学习方法，样本是无放回的，因此每轮计算样本不重复。XGBoost支持子采样，即每轮计算不使用全部样本，以减少过拟合。</li></ul><h4 id="15-决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？"><a href="#15-决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？" class="headerlink" title="15.决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？"></a>15.决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？</h4><ul><li>bagging与boosting的区别：<ul><li>bagging方法有放回的采样相同数量样本训练学习器，然后再一起投票。学习器之间不存在强的依赖关系，学习器可以并行训练生成。集成方式一般为投票法。随机森林属于Bagging的代表，放回抽样，每个学习器随机选择部分特征去优化。</li><li>Boosting方法使用全部样本，依次训练每个学习器，迭代集成。学习器之间不存在强依赖关系，学习器可并行训练生成，集成方式为加权和；Adaboost属于Boosting，采用指数损失函数代替原本分类任务中的0-1损失函数；GBDT属于Boosting的优秀代表，对函数残差近似值进行梯度下降，用CRAT树作为基本的学习器，集成模型为回归模型。XGBoost属于Boosting的集大成者，对函数残差近似值进行梯度下降，迭代时利用二阶梯度信息，集成模型可用于分类也可以用于回归。</li></ul></li><li>决策树的学习过程：从根开始建立树，也就是如何选择特征进行分裂。ID3算法使用信息增益、C4.5使用信息增益比、CART树采用基尼系数计算最优分类点，XGBoost使用二阶泰勒展开系数计算最优分裂点。</li></ul><h4 id="16-GBDT与XGBoost的对比，XGBoost的优点"><a href="#16-GBDT与XGBoost的对比，XGBoost的优点" class="headerlink" title="16.GBDT与XGBoost的对比，XGBoost的优点"></a>16.GBDT与XGBoost的对比，XGBoost的优点</h4><ul><li>损失函数用泰勒展开二项逼近，而不是像GBDT中用的就是一阶导数</li><li>对树的结构进行了正则化约束，防止模型过于复杂，降低了过拟合的可能性</li><li>节点的分裂方式不同，GBDT使用的是基尼系数，XGBoost使用的是经过优化推导后的算法(穷举法选择最佳的分裂节点、通过加权分位数方法近似选择最佳的分裂节点、针对稀疏特征的分裂点选择法)</li></ul><h4 id="17-L1和L2范数的区别"><a href="#17-L1和L2范数的区别" class="headerlink" title="17.L1和L2范数的区别"></a>17.L1和L2范数的区别</h4><ul><li>L1 norm:向量中各个元素绝对值之和，也称为稀疏规则算子，L1范数可以使权重稀疏，方便特征提取；L1正则化先验服从拉普拉斯分布</li><li>L2 norm:向量中各个元素平方和的1/2次方，又称为Frobenius范数，L2范数可以防止过拟合，提升模型的泛化能力；L2正则化先验服从高斯分布</li></ul><h4 id="18-阐述Adaboost算法的流程，并写出权重更新的公式"><a href="#18-阐述Adaboost算法的流程，并写出权重更新的公式" class="headerlink" title="18.阐述Adaboost算法的流程，并写出权重更新的公式"></a>18.阐述Adaboost算法的流程，并写出权重更新的公式</h4><ul><li><a href="https://www.jianshu.com/p/aae31290189e" target="_blank" rel="noopener">详细原理</a></li></ul><h4 id="19-LSTM的结构推导，为什么比普通的RNN好？"><a href="#19-LSTM的结构推导，为什么比普通的RNN好？" class="headerlink" title="19.LSTM的结构推导，为什么比普通的RNN好？"></a>19.LSTM的结构推导，为什么比普通的RNN好？</h4><ul><li><a href="https://www.jianshu.com/p/7c429d049b09" target="_blank" rel="noopener">详细原理</a></li></ul><h4 id="20-为什么朴素贝叶斯算法如此朴素？"><a href="#20-为什么朴素贝叶斯算法如此朴素？" class="headerlink" title="20.为什么朴素贝叶斯算法如此朴素？"></a>20.为什么朴素贝叶斯算法如此朴素？</h4><ul><li>因为它假设所有的特征在数据集中的作用都是同样重要的，而且相互独立的。这个假设在现实中基本上是不存在的，但特征相关性很小的实际情况还很多，岁月这个模型还可以工作的很好。</li></ul><h4 id="21-EM算法原理说明"><a href="#21-EM算法原理说明" class="headerlink" title="21.EM算法原理说明"></a>21.EM算法原理说明</h4><ul><li>有时候样本的产生和隐含变量有关(隐变量是不能观察的)，而求模型的参数时一般都采用极大似然估计，由于含有隐变量，所以对似然函数的参数求导数是求不出来的，这时候用EM算法来求模型的参数，典型的用法是用在GMM和HMM中。步骤如下：<ul><li>E步：选择一组参数，求出在此参数下隐变量的条件概率值<script type="math/tex; mode=display">  Q_{i}\left(z^{(i)}\right) :=p\left(z^{(i)} | x^{(i)} ; \theta\right)</script></li><li>M步：结合E步求出的隐变量的条件概率值，求出似然函数的下界函数(即某个期望函数)最大值。<script type="math/tex; mode=display">  \theta :=\arg \max _{\theta} \sum_{i} \sum_{z^{(i)}} Q_{i}\left(z^{(i)}\right) \log \frac{p\left(x^{(i)}, z^{(i)} ; \theta\right)}{Q_{i}\left(z^{(i)}\right)}</script></li><li>重复进行上面的两步，直至收敛为止。</li></ul></li><li>M步中下界函数的推导过程：<script type="math/tex; mode=display">\begin{aligned} \sum_{i} \log p\left(x^{(i)} ; \theta\right) &=\sum_{i} \log \sum_{z^{(i)}} p\left(x^{(i)}, z^{(i)} ; \theta\right) \\ &=\sum_{i} \log \sum_{z^{(i)}} Q_{i}\left(z^{(i)}\right) \frac{p\left(x^{(i)}, z^{(i)} ; \theta\right)}{Q_{i}\left(z^{(i)}\right)} \\ & \geq \sum_{i} \sum_{z^{(i)}} Q_{i}\left(z^{(i)}\right) \log \frac{p\left(x^{(i)}, z^{(i)} ; \theta\right)}{Q_{i}\left(z^{(i)}\right)} \end{aligned}</script></li></ul><h4 id="22-GMM算法原理说明"><a href="#22-GMM算法原理说明" class="headerlink" title="22.GMM算法原理说明"></a>22.GMM算法原理说明</h4><ul><li>EM算法的常用例子是高斯混合模型GMM，每个样本都有可能由K个高斯模型产生，只不过每个高斯模型的产生概率不同，因此每个样本都有对应的高斯分布(K个模型中的一个)，此时的隐变量就是每个样本对应的某个高斯分布。<ul><li>GMM算法的E步(计算每个样本对应每个高斯模型的概率)<script type="math/tex; mode=display">  w_{j}^{(i)} :=p\left(z^{(i)}=j | x^{(i)} ; \phi, \mu, \Sigma\right)</script>具体的计算公式为：<script type="math/tex; mode=display">  p\left(z^{(i)}=j | x^{(i)} ; \phi, \mu, \Sigma\right)=\frac{p\left(x^{(i)} | z^{(i)}=j ; \mu, \Sigma\right) p\left(z^{(i)}=j ; \phi\right)}{\sum_{l=1}^{k} p\left(x^{(i)} | z^{(i)}=l ; \mu, \Sigma\right) p\left(z^{(i)}=l ; \phi\right)}</script></li><li>M步计算公式(计算每个高斯模型的权重，均值，方差3个参数)：<script type="math/tex; mode=display">  \begin{aligned} \phi_{j} & :=\frac{1}{m} \sum_{i=1}^{m} w_{j}^{(i)} \\ \mu_{j} & :=\frac{\sum_{i=1}^{m} w_{j}^{(i)} x^{(i)}}{\sum_{i=1}^{m} w_{j}^{(i)}} \\ \Sigma_{j} & :=\frac{\sum_{i=1}^{m} w_{j}^{(i)}\left(x^{(i)}-\mu_{j}\right)\left(x^{(i)}-\mu_{j}\right)^{T}}{\sum_{i=1}^{m} w_{j}^{(i)}} \end{aligned}</script></li></ul></li></ul><h4 id="23-KNN算法中K是如何选择的"><a href="#23-KNN算法中K是如何选择的" class="headerlink" title="23.KNN算法中K是如何选择的?"></a>23.KNN算法中K是如何选择的?</h4><ul><li>如果选择较小的K值，就相当于用较小的邻域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大。换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；</li><li>如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。</li><li>K=N，此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的累，模型过于简单，忽略了训练实例中大量有用信息。</li><li>实际中，使用交叉验证的方法选择最优的K的取值。</li></ul><h4 id="24-机器学习中，为什么经常需要对数据进行归一化？"><a href="#24-机器学习中，为什么经常需要对数据进行归一化？" class="headerlink" title="24.机器学习中，为什么经常需要对数据进行归一化？"></a>24.机器学习中，为什么经常需要对数据进行归一化？</h4><ul><li>归一化能提高梯度下降算法求解的速度</li><li>归一化有可能提高精度</li></ul><h4 id="25-神经网络中的批量归一化Batch-Normalization-BN-原理"><a href="#25-神经网络中的批量归一化Batch-Normalization-BN-原理" class="headerlink" title="25.神经网络中的批量归一化Batch Normalization(BN)原理"></a>25.神经网络中的批量归一化Batch Normalization(BN)原理</h4><ul><li><a href="https://blog.csdn.net/cdlwhm1217096231/article/details/95391398" target="_blank" rel="noopener">详细原理</a></li></ul><h4 id="26-哪些机器学习算法不需要进行归一化操作？"><a href="#26-哪些机器学习算法不需要进行归一化操作？" class="headerlink" title="26.哪些机器学习算法不需要进行归一化操作？"></a>26.哪些机器学习算法不需要进行归一化操作？</h4><ul><li>概率模型不需要做归一化操作，因为它们不关心变量的值，而关心的是变量分布和变量之间的条件概率，如决策树。但是，像Adaboost、SVM、LR、KNN、Kmeans等最优化问题就需要归一化。</li></ul><h4 id="27-为什么树形结构不需要归一化？"><a href="#27-为什么树形结构不需要归一化？" class="headerlink" title="27.为什么树形结构不需要归一化？"></a>27.为什么树形结构不需要归一化？</h4><ul><li>数值缩放，不影响分裂点位置。因为第一步都是按照特征值进行排序的，排序的顺序不变，那么所属的分支以及分裂点就不会变。对于线性模型，比如说LR，假设有两个特征，一个是(0,1)的，一个是(0,10000)的，这样运用梯度下降时候，损失等高线是一个椭圆的形状，这样想迭代到最优点，就需要很多次迭代，但是如果进行了归一化，那么等高线就是圆形的，那么SGD就会往原点迭代，需要的迭代次数较少。另外，注意树模型是不能进行梯度下降的，因为树模型是阶跃的，阶跃点是不可导的，并且求导没意义，所以树模型（回归树）寻找最优点是通过寻找最优分裂点完成的。</li></ul><h4 id="28-一个完整机器学习项目的流程"><a href="#28-一个完整机器学习项目的流程" class="headerlink" title="28.一个完整机器学习项目的流程"></a>28.一个完整机器学习项目的流程</h4><ul><li>抽象成数学问题、获取数据、特征预处理与特征选择、训练模型与调优、模型诊断、模型融合、上线运行</li></ul><h4 id="29-条件随机场CRF模型相对于HMM模型-隐马尔科夫模型-和MEMM模型-最大熵隐马尔科夫模型-的优势。"><a href="#29-条件随机场CRF模型相对于HMM模型-隐马尔科夫模型-和MEMM模型-最大熵隐马尔科夫模型-的优势。" class="headerlink" title="29.条件随机场CRF模型相对于HMM模型(隐马尔科夫模型)和MEMM模型(最大熵隐马尔科夫模型)的优势。"></a>29.条件随机场CRF模型相对于HMM模型(隐马尔科夫模型)和MEMM模型(最大熵隐马尔科夫模型)的优势。</h4><ul><li>HMM模型中一个最大的缺点即其输出独立性假设，由于输出独立性假设的缺点导致HMM模型不能考虑上下文的特征，限制了特征的选择。</li><li>MEMM模型则解决了HMM模型的最大的缺点，可以任意选择特征，但是由于其每一个节点都要进行归一化，所以只能找到局部最优值。同时，也带来了标记偏见的问题即凡是在训练语料库中未出现的情况都被忽略掉了。CRF模型很好的解决了这个问题，它并不在每一节点进行归一化，而是所有特征进行全局归一化，因此可以求出全局的最优值。</li></ul><h4 id="30-什么是熵？"><a href="#30-什么是熵？" class="headerlink" title="30.什么是熵？"></a>30.什么是熵？</h4><ul><li>熵的定义：离散随机事件的出现概率。一个系统越是有序，信息熵就越低。信息熵可以被认为是系统有序化程度的一个度量。</li></ul><h4 id="31-BP反向传播算法推导及python实现"><a href="#31-BP反向传播算法推导及python实现" class="headerlink" title="31.BP反向传播算法推导及python实现"></a>31.BP反向传播算法推导及python实现</h4><p><img src="https://upload-images.jianshu.io/upload_images/13407176-4e2c5d2d7e253c9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-bc9a950264c79a8c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-d451c71b72960fc2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p><ul><li>python代码实现：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">import numpy <span class="keyword">as</span> np</span><br><span class="line">import matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">class MLP():</span><br><span class="line">    def __init__(<span class="keyword">self</span>, name=<span class="symbol">'nn</span>', layer_structure=[], task_model=<span class="literal">None</span>, batch_size=<span class="number">1</span>, load_model=<span class="literal">None</span>):</span><br><span class="line">        <span class="string">""</span><span class="string">"layer_number : 神经网络的层数</span></span><br><span class="line"><span class="string">           layer_structure = [输入的特征个数，第1层神经元个数，第2层神经元个数，...，最后一层神经元个数输出层特征个数]，</span></span><br><span class="line"><span class="string">           如网络层数设为layer_number=3, layer_structure=[20,10,5,1]：输入特征是20个，第一层有10个神经元，第二层5个，第三层1个.</span></span><br><span class="line"><span class="string">           output_model = 'regression'/'logistic'</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.layer_number = len(layer_structure) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.layer_structure = layer_structure</span><br><span class="line">        <span class="keyword">self</span>.task_model = task_model</span><br><span class="line">        <span class="keyword">self</span>.W = []</span><br><span class="line">        <span class="keyword">self</span>.B = []</span><br><span class="line">        <span class="keyword">self</span>.batch_size = batch_size</span><br><span class="line">        <span class="keyword">self</span>.total_loss = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.task_model == <span class="symbol">'logistic</span>' or <span class="keyword">self</span>.task_model == <span class="symbol">'multi</span>':</span><br><span class="line">            <span class="keyword">self</span>.total_accuracy = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> load_model == <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">"Initializing the network from scratch ..."</span>)</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">                <span class="keyword">self</span>.W.append(np.random.randn(<span class="keyword">self</span>.layer_structure[index], <span class="keyword">self</span>.layer_structure[index+<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">self</span>.B.append(np.random.randn(<span class="number">1</span>, <span class="keyword">self</span>.layer_structure[index+<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Initializing the network from trained model ..."</span>)</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">                <span class="keyword">self</span>.W.append(np.loadtxt(load_model + <span class="keyword">self</span>.name + <span class="string">"_layer_"</span> + <span class="built_in">str</span>(index) + <span class="string">"_W.txt"</span>).reshape(<span class="keyword">self</span>.layer_structure[index], <span class="keyword">self</span>.layer_structure[index+<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">self</span>.B.append(np.loadtxt(load_model + <span class="keyword">self</span>.name + <span class="string">"_layer_"</span> + <span class="built_in">str</span>(index) + <span class="string">"_B.txt"</span>).reshape(<span class="number">1</span>, <span class="keyword">self</span>.layer_structure[index+<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    def normal_parameters(<span class="keyword">self</span>, means, sigmas):</span><br><span class="line">        <span class="keyword">self</span>.means = means</span><br><span class="line">        <span class="keyword">self</span>.sigams = sigmas</span><br><span class="line"></span><br><span class="line">    def sigmoid(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line">    def sigmoid_gradient(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.sigmoid(x)*(<span class="number">1</span>-<span class="keyword">self</span>.sigmoid(x))</span><br><span class="line"></span><br><span class="line">    def softmax(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="keyword">return</span> np.exp(x)/np.sum(np.exp(x), axis = <span class="number">1</span>, keepdims = True)</span><br><span class="line"></span><br><span class="line">    def forward(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            intput : x = [batch_size, features]</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.before_activation = []</span><br><span class="line">        <span class="keyword">self</span>.activations = [x]</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="keyword">self</span>.layer_number - <span class="number">1</span>:</span><br><span class="line">                Z = np.dot(<span class="keyword">self</span>.activations[index], <span class="keyword">self</span>.W[index]) + <span class="keyword">self</span>.B[index]</span><br><span class="line">                <span class="keyword">self</span>.before_activation.append(Z)</span><br><span class="line">                <span class="keyword">self</span>.activations.append(<span class="keyword">self</span>.sigmoid(Z))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.task_model == <span class="symbol">'logistic</span>':</span><br><span class="line">                    Z = np.dot(<span class="keyword">self</span>.activations[index], <span class="keyword">self</span>.W[index]) + <span class="keyword">self</span>.B[index]</span><br><span class="line">                    <span class="keyword">self</span>.before_activation.append(Z)</span><br><span class="line">                    <span class="keyword">self</span>.activations.append(<span class="keyword">self</span>.sigmoid(Z))</span><br><span class="line">                elif <span class="keyword">self</span>.task_model == <span class="symbol">'regression</span>':</span><br><span class="line">                    Z = np.dot(<span class="keyword">self</span>.activations[index], <span class="keyword">self</span>.W[index]) + <span class="keyword">self</span>.B[index]</span><br><span class="line">                    <span class="keyword">self</span>.before_activation.append(Z)</span><br><span class="line">                    <span class="keyword">self</span>.activations.append(Z)</span><br><span class="line">                elif <span class="keyword">self</span>.task_model == <span class="symbol">'multi</span>':</span><br><span class="line">                    Z = np.dot(<span class="keyword">self</span>.activations[index], <span class="keyword">self</span>.W[index]) + <span class="keyword">self</span>.B[index]</span><br><span class="line">                    <span class="keyword">self</span>.before_activation.append(Z)</span><br><span class="line">                    <span class="keyword">self</span>.activations.append(<span class="keyword">self</span>.softmax(Z))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.activations[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    def __call__(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.forward(x)</span><br><span class="line"></span><br><span class="line">    def lossfunction(<span class="keyword">self</span>, inputs, target):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.task_model == <span class="symbol">'regression</span>':</span><br><span class="line">            <span class="keyword">return</span>(np.mean(np.sum((inputs - target)**<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line">        elif <span class="keyword">self</span>.task_model == <span class="symbol">'logistic</span>':</span><br><span class="line">            <span class="keyword">return</span> np.mean(np.sum(-target*np.log(inputs+<span class="number">1e-14</span>) - (<span class="number">1</span>-target)*np.log(<span class="number">1</span>-inputs+<span class="number">1e-14</span>), <span class="number">1</span>))</span><br><span class="line">        elif <span class="keyword">self</span>.task_model == <span class="symbol">'multi</span>':</span><br><span class="line">            <span class="keyword">return</span> np.mean(np.sum(-target*np.log(inputs+<span class="number">1e-14</span>), <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    def back_forward(<span class="keyword">self</span>, targets=<span class="literal">None</span>, loss=<span class="literal">None</span>, regularization=False):</span><br><span class="line">        <span class="keyword">self</span>.dWs = []</span><br><span class="line">        <span class="keyword">self</span>.dBs = []</span><br><span class="line">        <span class="keyword">self</span>.dAs = []</span><br><span class="line">        W_reverse = <span class="keyword">self</span>.W[::-<span class="number">1</span>]</span><br><span class="line">        activations_reverse = <span class="keyword">self</span>.activations[::-<span class="number">1</span>]</span><br><span class="line">        before_activation_reverse = <span class="keyword">self</span>.before_activation[::-<span class="number">1</span>]</span><br><span class="line">        # 从最后一层开始往回传播</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">if</span> loss == <span class="symbol">'MSE</span>' or loss == <span class="symbol">'CE</span>' or loss == <span class="symbol">'BE</span>':</span><br><span class="line">                    dZ = activations_reverse[k] - targets</span><br><span class="line">                    dW = <span class="number">1</span>/<span class="keyword">self</span>.batch_size*np.dot(activations_reverse[k+<span class="number">1</span>].T, dZ)</span><br><span class="line">                    dB = <span class="number">1</span>/<span class="keyword">self</span>.batch_size*np.sum(dZ, axis = <span class="number">0</span>, keepdims = True)</span><br><span class="line">                    dA_before = np.dot(dZ, W_reverse[k].T)</span><br><span class="line">                    <span class="keyword">self</span>.dWs.append(dW)</span><br><span class="line">                    <span class="keyword">self</span>.dBs.append(dB)</span><br><span class="line">                    <span class="keyword">self</span>.dAs.append(dA_before)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dZ = <span class="keyword">self</span>.dAs[k-<span class="number">1</span>]*<span class="keyword">self</span>.sigmoid_gradient(before_activation_reverse[k])</span><br><span class="line">                dW = <span class="number">1</span>/<span class="keyword">self</span>.batch_size*np.dot(activations_reverse[k+<span class="number">1</span>].T,dZ)</span><br><span class="line">                dB = <span class="number">1</span>/<span class="keyword">self</span>.batch_size*np.sum(dZ, axis = <span class="number">0</span>, keepdims = True)</span><br><span class="line">                dA_before = np.dot(dZ, W_reverse[k].T)</span><br><span class="line">                <span class="keyword">self</span>.dWs.append(dW)</span><br><span class="line">                <span class="keyword">self</span>.dBs.append(dB)</span><br><span class="line">                <span class="keyword">self</span>.dAs.append(dA_before)</span><br><span class="line">        <span class="keyword">self</span>.dWs = <span class="keyword">self</span>.dWs[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">self</span>.dBs = <span class="keyword">self</span>.dBs[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    def steps(<span class="keyword">self</span>, lr=<span class="number">0.001</span>, lr_decay=False):</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(<span class="keyword">self</span>.dWs)):</span><br><span class="line">            <span class="keyword">self</span>.W[index] -= lr*<span class="keyword">self</span>.dWs[index]</span><br><span class="line">            <span class="keyword">self</span>.B[index] -= lr*<span class="keyword">self</span>.dBs[index]</span><br><span class="line"></span><br><span class="line">    def train(<span class="keyword">self</span>, train_datas=<span class="literal">None</span>, train_targets=<span class="literal">None</span>, train_epoch=<span class="number">1</span>, lr=<span class="number">0.001</span>, lr_decay=False, loss=<span class="symbol">'MSE</span>', regularization=False, display=False):</span><br><span class="line">        train_counts = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(train_epoch):</span><br><span class="line">            <span class="keyword">if</span> epoch == int(train_epoch * <span class="number">0.7</span>) and lr_decay == True:</span><br><span class="line">                lr *= <span class="number">0.1</span></span><br><span class="line">            train_steps = train_datas.shape[<span class="number">0</span>] <span class="comment">// self.batch_size</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(train_steps):</span><br><span class="line">                input_data = train_datas[<span class="keyword">self</span>.batch_size*i : <span class="keyword">self</span>.batch_size*(i+<span class="number">1</span>), :].reshape(<span class="keyword">self</span>.batch_size, train_datas.shape[<span class="number">1</span>])</span><br><span class="line">                targets = train_targets[<span class="keyword">self</span>.batch_size*i : <span class="keyword">self</span>.batch_size*(i+<span class="number">1</span>), :].reshape(<span class="keyword">self</span>.batch_size, train_targets.shape[<span class="number">1</span>])</span><br><span class="line">                prediction = <span class="keyword">self</span>.forward(input_data)</span><br><span class="line">                forward_loss = <span class="keyword">self</span>.lossfunction(prediction, targets)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.task_model==<span class="symbol">'logistic</span>':</span><br><span class="line">                    accuracy = np.sum((prediction&gt;<span class="number">0.6</span>) == targets) / targets.shape[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">self</span>.total_accuracy.append(accuracy)</span><br><span class="line">                elif <span class="keyword">self</span>.task_model==<span class="symbol">'multi</span>':</span><br><span class="line">                    accuracy = np.sum(np.argmax(prediction,<span class="number">1</span>) == np.argmax(targets,<span class="number">1</span>)) / targets.shape[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">self</span>.total_accuracy.append(accuracy)</span><br><span class="line">                <span class="keyword">self</span>.total_loss.append(forward_loss)</span><br><span class="line">                <span class="keyword">if</span> display:</span><br><span class="line">                    <span class="keyword">if</span> train_counts % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">self</span>.task_model == <span class="symbol">'logistic</span>' or <span class="keyword">self</span>.task_model == <span class="symbol">'multi</span>':</span><br><span class="line">                            print(<span class="string">"After "</span> + <span class="built_in">str</span>(train_counts) + <span class="string">", loss is "</span>, forward_loss,</span><br><span class="line">                            <span class="string">", accuracy is "</span>, accuracy)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            print(<span class="string">"After "</span> + <span class="built_in">str</span>(train_counts) + <span class="string">", loss is "</span>, forward_loss)</span><br><span class="line">                <span class="keyword">self</span>.back_forward(targets=targets, loss=loss, regularization=regularization)</span><br><span class="line">                <span class="keyword">self</span>.steps(lr=lr, lr_decay=lr_decay)</span><br><span class="line">                train_counts += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    def save_model(<span class="keyword">self</span>, path):</span><br><span class="line">        print(<span class="string">"Saving the "</span> + <span class="keyword">self</span>.name + <span class="string">" model ..."</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">            np.savetxt(path  + <span class="keyword">self</span>.name + <span class="string">"_layer_"</span> + <span class="built_in">str</span>(i) + <span class="string">"_W.txt"</span>, <span class="keyword">self</span>.W[i])</span><br><span class="line">            np.savetxt(path  + <span class="keyword">self</span>.name + <span class="string">"_layer_"</span> + <span class="built_in">str</span>(i) + <span class="string">"_B.txt"</span>, <span class="keyword">self</span>.B[i])</span><br><span class="line">        print(<span class="string">"Model saved !!!"</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="32-K-Means算法的原理"><a href="#32-K-Means算法的原理" class="headerlink" title="32.K_Means算法的原理"></a>32.K_Means算法的原理</h4><ul><li>聚类算法综述：聚类算法是一种无监督学习算法，它是将相似的对象归到同一个簇中。K均值算法中的K可以理解用户想要聚类成K个不同的簇，K是一个用户可以自行定义的超参数。</li><li>K均值聚类的优缺点：<ul><li>优点：容易实现</li><li>缺点：可能收敛到局部最小值，在大规模的数据上收敛慢</li><li>适用场合：数值型数据</li></ul></li><li>K_Means算法的基本流程：<ul><li>1.随机选择K个点作为起始的聚类中心</li><li>2.遍历每个样本，计算每个样本到K个聚类中心的距离，找出”距离”聚类中心最近的样本，并将此样本聚集到离它最近的那一个簇中。<strong>注：K_Means算法的性能会受到所选距离计算方法的影响</strong>。</li><li>3.所有样本都聚集到K个簇完成后，计算K个簇的均值，并将聚类中心移动到K个簇的均值处作为新的聚类中心。</li><li>4.重复上述步骤2~3，直到最大迭代次数就停止。</li></ul></li><li><strong>K_Means算法的优化(为了克服收敛于局部最小值提出)</strong>：如何知道生成的簇比较好？一种用来衡量K_Means算法聚类效果的指标是SSE误差平方和(预测数据与原始数据之间误差的平方和),SSE越小表示样本点越接近于聚类中心点，聚类效果越好。<strong>因为对误差取了平方，因此更加重视那些远离聚类中心的点(未理解)</strong>。降低SSE值的方法是增加簇的个数，但是簇的个数K在算法一开始运行时就固定了，不能改变。聚类的目标是在保持原有簇数目不变的条件下，提高簇的质量。<strong>常用思想是：对生成的簇进行后处理，将具有最大SSE值的簇划分成两个簇。为了保持簇的总数不变，可以将某两个簇进行合并</strong>。可以有下面两种方法合并：<ul><li>1.合并最近的聚类中心：计算所有聚类中心之间的距离，合并距离最近的两个聚类中心点。</li><li>2.合并两个使得SSE增加最小的聚类中心：合并两个簇，然后计算总的SSE。必须在所有可能的两个簇上重复上述处理过程，直到找到合并最佳的两个簇。</li></ul></li></ul><h4 id="33-常见的距离函数总结"><a href="#33-常见的距离函数总结" class="headerlink" title="33.常见的距离函数总结"></a>33.常见的距离函数总结</h4><ul><li>闵可夫斯基距离：给定样本$\overrightarrow{\mathbf{x}}<em>{i}=\left(x</em>{i, 1}, x<em>{i, 2}, \cdots, x</em>{i, n}\right)^{T}$,$\overrightarrow{\mathbf{x}}<em>{j}=\left(x</em>{j, 1}, x<em>{j, 2}, \cdots, x</em>{j, n}\right)^{T}$，则闵可夫斯基距离定义为：<script type="math/tex; mode=display">\text { distance( }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left(\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{p}\right)^{1 / p}</script></li><li>当p=2时，闵可夫斯基距离就是<strong>欧式距离</strong>：<script type="math/tex; mode=display">\operatorname{distance}\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{2}=\sqrt{\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{2}}</script></li><li>当p=1时，闵可夫斯基距离就是<strong>曼哈顿距离</strong>：<script type="math/tex; mode=display">\text { distance }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{1}=\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|</script></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-参考博客&quot;&gt;&lt;a href=&quot;#1-参考博客&quot; class=&quot;headerlink&quot; title=&quot;1.参考博客&quot;&gt;&lt;/a&gt;1.参考博客&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nowcoder.com/ta/review-ml?q
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点总结</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/操作系统/操作系统知识点总结/</id>
    <published>2019-07-30T13:11:15.000Z</published>
    <updated>2019-08-08T09:07:39.906Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h4><ul><li>对于有线程系统：<ul><li>进程是资源分配的独立单位</li><li>线程是资源调度的独立单位</li></ul></li><li>对无无线程系统：<ul><li>进程是资源调度、分配的独立单位</li></ul></li></ul><h4 id="2-进程间的通信方式及优缺点"><a href="#2-进程间的通信方式及优缺点" class="headerlink" title="2.进程间的通信方式及优缺点"></a>2.进程间的通信方式及优缺点</h4><ul><li><strong>管道</strong><ul><li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信。<ul><li>优点：可以实现任意关系的进程间的通信</li><li>缺点：<ul><li>a.长期存于系统中，使用不当容易出错</li><li>b.缓冲区有限</li></ul></li></ul></li><li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul><li>优点：简单方便</li><li>缺点：<ul><li>a.局限于单向通信</li><li>b.只能创建在它的进程以及其有亲缘关系的进程之间</li><li>c.缓冲区有限</li></ul></li></ul></li></ul></li><li><strong>信号量</strong>：一个计数器，可以用来控制多个线程对共享资源的访问<ul><li>优点：可以同步进程</li><li>缺点：信号量有限</li></ul></li><li><strong>信号</strong>: 一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li><li><strong>消息队列</strong>: 是消息的链表，存放在内核中并由消息队列标识符标识<ul><li>优点： 可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li><li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li></ul></li><li><strong>共享内存</strong>：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul><li>优点：无须复制，快捷，信息量大</li><li>缺点：<ul><li>a.通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li><li>b.利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li></ul></li></ul></li><li><strong>套接字</strong>：可用于不同及其间的进程通信<ul><li>优点：<ul><li>a.传输数据为字节级，传输数据可自定义，数据量小效率高</li><li>b.传输数据时间短，性能高</li><li>c.适合于客户端和服务器端之间信息实时交互</li><li>d.可以加密,数据安全性强</li></ul></li><li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li></ul></li></ul><h4 id="3-线程之间的通信方式"><a href="#3-线程之间的通信方式" class="headerlink" title="3.线程之间的通信方式"></a>3.线程之间的通信方式</h4><ul><li><strong>锁机制</strong>：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul><li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>自旋锁（spin lock）：与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li><li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li><strong>信号量机制</strong><ul><li>无名线程信号量</li><li>有名线程信号量</li></ul></li><li><strong>信号机制(Signal)</strong>：类似进程间的信号处理</li><li><strong>屏障</strong>：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li></ul><h4 id="4-进程之间私有和共享的资源"><a href="#4-进程之间私有和共享的资源" class="headerlink" title="4.进程之间私有和共享的资源"></a>4.进程之间私有和共享的资源</h4><ul><li>私有：地址空间、堆、全局变量、栈、寄存器</li><li>共享：代码段，公共数据，进程目录，进程 ID</li></ul><h4 id="5-线程之间私有和共享的资源"><a href="#5-线程之间私有和共享的资源" class="headerlink" title="5.线程之间私有和共享的资源"></a>5.线程之间私有和共享的资源</h4><ul><li>私有：线程栈，寄存器，程序寄存器</li><li>共享：堆，地址空间，全局变量，静态变量</li></ul><h4 id="6-多进程与多线程间的对比、优劣与选择"><a href="#6-多进程与多线程间的对比、优劣与选择" class="headerlink" title="6.多进程与多线程间的对比、优劣与选择"></a>6.多进程与多线程间的对比、优劣与选择</h4><p><img src="https://upload-images.jianshu.io/upload_images/13407176-f1d727410790e1b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="特点对比.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-c113b6d4576c9f27.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优缺点对比.jpg"></p><ul><li>线程与进程选用规则：<ul><li>需要频繁创建销毁的优先用线程</li><li>需要进行大量计算的优先使用线程</li><li>强相关的处理用线程，弱相关的处理用进程</li><li>可能要扩展到多机分布的用进程，多核分布的用线程</li><li>都满足需求的情况下，用你最熟悉、最拿手的方式</li></ul></li></ul><h4 id="7-Linux的内核同步方式"><a href="#7-Linux的内核同步方式" class="headerlink" title="7.Linux的内核同步方式"></a>7.Linux的内核同步方式</h4><ul><li><strong>为什么需要内核同步？</strong>：在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程、多线程编程一样也需要一些同步机制来同步<strong>各执行单元对共享数据的访问</strong>。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</li><li><strong>内核同步方式</strong>:<ul><li>原子操作</li><li>信号量（semaphore）</li><li>读写信号量（rw_semaphore）</li><li>自旋锁（spinlock）</li><li>大内核锁（BKL，Big Kernel Lock）</li><li>读写锁（rwlock）</li><li>大读者锁（brlock-Big Reader Lock）</li><li>读-拷贝修改(RCU，Read-Copy Update)</li><li>顺序锁（seqlock）</li></ul></li></ul><h4 id="8-死锁"><a href="#8-死锁" class="headerlink" title="8.死锁"></a>8.死锁</h4><ul><li>定义：<strong>是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。</strong></li><li><strong>死锁产生的条件</strong>：<ul><li>互斥</li><li>请求和保持</li><li>不可剥夺</li><li>环路等待</li></ul></li><li><strong>预防死锁</strong>：<ul><li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li><li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li><li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li><li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li><li>有序资源分配法</li><li><a href="https://blog.csdn.net/jgm20475/article/details/81265947" target="_blank" rel="noopener">银行家算法</a></li></ul></li></ul><h4 id="9-页面置换算法"><a href="#9-页面置换算法" class="headerlink" title="9.页面置换算法"></a>9.页面置换算法</h4><ul><li><strong>页面置换</strong>：在地址映射过程中，如果在页面中发现所要访问的页面不存在于内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</li><li><p><strong>分类</strong>：</p><ul><li>全局置换：在整个内存空间置换<ul><li>工作集算法</li><li>缺失率置换算法</li></ul></li><li><p>局部置换：在本进程中进行置换</p><ul><li>最佳置换算法(OPT)<ul><li>原理：从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 <a href="https://blog.csdn.net/jack450250844/article/details/84986690" target="_blank" rel="noopener">详见原理</a></li></ul></li><li><p>先进先出置换算法(FIFO)</p><ul><li>原理：该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老的页面。但该算法与进程实际运行的规律不相适应，因为在进程中，有些页面经常被访问，比如，含有全局变量、常用函数、例程等的页面，FIFO算法并不能保证这些页面不被淘汰。<a href="https://blog.csdn.net/jack450250844/article/details/85019950" target="_blank" rel="noopener">详见原理</a></li></ul></li><li><p>最近最久未使用算法(LRU)</p><ul><li>原理：根据页面调入内存后的使用情况做出决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有也面中t值最大的，即最近最久未使用的页面予以淘汰。<a href="https://blog.csdn.net/jack450250844/article/details/85019898" target="_blank" rel="noopener">详见原理</a></li></ul></li><li>时钟置换算法(Clock)<ul><li>原理：淘汰访问位为0的页框中的页面，被访问过的页面将其页框的访问位数值置1。<a href="https://blog.csdn.net/Long_H_Zhu/article/details/84184563" target="_blank" rel="noopener">详见原理</a></li></ul></li></ul></li><li>局部置换的三种算法C++代码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> page[] = &#123; <span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FIFO</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OPT</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RLU</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inArray</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    FIFO();</span><br><span class="line">    OPT();</span><br><span class="line">    RLU();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FIFO算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FIFO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">3</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"FIFO:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (page[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inArray(temp, <span class="number">3</span>, page[num])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            error++;</span><br><span class="line">            <span class="keyword">bool</span> hasChanged = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (time[i] == <span class="number">0</span> &amp;&amp; hasChanged == <span class="literal">false</span>) &#123;</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    hasChanged = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (time[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    time[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误率:"</span> &lt;&lt; error &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inArray</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == a[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OPT算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OPT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//OPT已知未来的页数为20</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"OPT:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (page[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = page[num];</span><br><span class="line">        <span class="keyword">if</span> (inArray(temp, <span class="number">3</span>, page[num])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            error++;</span><br><span class="line">            <span class="keyword">bool</span> fuck = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    fuck = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fuck == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> distance[<span class="number">3</span>] = &#123; <span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span> &#125;;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= num; i--) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (temp[j] == page[i] &amp;&amp; (i - num) &lt; distance[j]) &#123;</span><br><span class="line">                            distance[j] = i - num;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (max &lt; distance[i]) &#123;</span><br><span class="line">                        max = distance[i];</span><br><span class="line">                        k = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                temp[k] = page[num];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误率:"</span> &lt;&lt; error &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RLU算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RLU</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"RLU:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (page[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = page[num];</span><br><span class="line">        <span class="keyword">if</span> (inArray(temp, <span class="number">3</span>, page[num])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//bool Changed = false;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == page[num]) &#123;</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//Changed = true;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] != page[num]&amp;&amp;time[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">                    time[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            error++;</span><br><span class="line">            <span class="comment">//bool hasChange = false;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(time[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    time[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误率:"</span> &lt;&lt; error &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="10-进程状态转换图"><a href="#10-进程状态转换图" class="headerlink" title="10.进程状态转换图"></a>10.进程状态转换图</h4><p><img src="https://upload-images.jianshu.io/upload_images/13407176-2d3db5b8d56f27a8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程的五种基本状态"></p><ul><li>进程的五种基本状态：<ul><li>创建状态：进程正在被创建</li><li>就绪状态：进程被加入到就绪队列中等待CPU调度运行</li><li>执行状态：进程正在被运行</li><li>等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行</li><li>终止状态：进程运行完毕</li></ul></li></ul><h4 id="11-软链接和硬链接的区别"><a href="#11-软链接和硬链接的区别" class="headerlink" title="11.软链接和硬链接的区别"></a>11.软链接和硬链接的区别</h4><ul><li>软链接也叫符号链接，软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</li><li>硬链接：通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</li></ul><h4 id="12-协程"><a href="#12-协程" class="headerlink" title="12.协程"></a>12.协程</h4><ul><li><p>定义：又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。例如：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span> :</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'2'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'3'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span> :</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'x'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'y'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'z'</span></span><br></pre></td></tr></table></figure></li><li><p>上面协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。</p></li></ul><h4 id="13-协程与线程的区别"><a href="#13-协程与线程的区别" class="headerlink" title="13.协程与线程的区别"></a>13.协程与线程的区别</h4><ul><li>协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制。因此，没有线程切换的开销。协程和多线程相比，线程数量越多，协程的性能优势就越明显。</li><li>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突。在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li></ul><h4 id="14-进程同步的几种方式"><a href="#14-进程同步的几种方式" class="headerlink" title="14.进程同步的几种方式"></a>14.进程同步的几种方式</h4><ul><li><strong>信号量</strong>：用于进程间传递信号的一个整数值。</li><li>在信号量上只有三种操作可以进行：初始化、P操作、V操作，这三种操作都是原子操作。<strong>P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程</strong>。</li><li>原理：两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。该信号即为信号量s。为通过信号量s传送信号，进程可执行原语semSignal(s);为通过信号量s接收信号，进程可执行原语semWait(s);如果相应的信号仍然没有发送，则进程被阻塞，直到发送完为止。可把信号量视为一个具有整数值的变量，在它之上定义三个操作：<ul><li>一个信号量可以初始化为非负数；</li><li>semWait操作使信号量s减1.若值为负数，则执行semWait的进程被阻塞。否则进程继续执行；</li><li>semSignal操作使信号量加1，若值大于或等于零，则被semWait操作阻塞的进程被解除阻塞</li></ul></li><li><strong>管程</strong>：由一个或多个过程、一个初始化序列和局部数据组成的软件模块，其主要特点如下：<ul><li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问；</li><li>一个进程通过调用管程的一个过程进入管程；</li><li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用；</li></ul></li><li><strong>消息传递</strong>：是进程间进程消息传递所需要的最小操作集。一个进程以消息的形式给另一个指定的目标进程发送消息；进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。</li></ul><h4 id="15-线程同步的几种方式"><a href="#15-线程同步的几种方式" class="headerlink" title="15.线程同步的几种方式"></a>15.线程同步的几种方式</h4><ul><li><strong>临界区</strong>:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</li><li><strong>互斥量</strong>:采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。</li><li><strong>信号量</strong>:它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</li><li><strong>事件</strong>:通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。<h4 id="16-操作系统中程序的内存结构"><a href="#16-操作系统中程序的内存结构" class="headerlink" title="16.操作系统中程序的内存结构"></a>16.操作系统中程序的内存结构</h4><img src="https://upload-images.jianshu.io/upload_images/13407176-51b3576acab2510c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="操作系统中的内存结构"></li><li><strong>一个程序本质上都是由BSS段、数据段(data段)、text段(代码段)三个组成的</strong>。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</li><li><strong>BSS段（未初始化数据区）</strong>：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</li><li><strong>数据段</strong>：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</li><li><strong>代码段</strong>：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。<ul><li>BSS段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中，其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</li><li>data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。<strong>包含数据段和BSS段的整个区段此时通常称为数据区</strong>。</li></ul></li><li><strong>可执行程序在运行时又多出两个区域：栈区和堆区</strong>。<ul><li>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</li><li>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-进程与线程&quot;&gt;&lt;a href=&quot;#1-进程与线程&quot; class=&quot;headerlink&quot; title=&quot;1.进程与线程&quot;&gt;&lt;/a&gt;1.进程与线程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;对于有线程系统：&lt;ul&gt;
&lt;li&gt;进程是资源分配的独立单位&lt;/li&gt;
&lt;li&gt;线程是资源
      
    
    </summary>
    
      <category term="操作系统" scheme="https://cdlwhm1217096231.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://cdlwhm1217096231.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的文件打包与压缩方法总结</title>
    <link href="https://cdlwhm1217096231.github.io/Linux/Linux%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/Linux/Linux中的文件打包与压缩方法总结/</id>
    <published>2019-07-29T11:45:34.000Z</published>
    <updated>2019-07-29T11:55:17.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、文件打包和解压缩"><a href="#一、文件打包和解压缩" class="headerlink" title="一、文件打包和解压缩"></a>一、文件打包和解压缩</h3><ul><li>在windows系统上最常见的压缩文件不外乎这三种*.zip,*.rar,*.7z后缀的压缩文件，而在Linux系统上常见常用的除了以上的三种之外，还有*.gz,*.xz,*.bz2,*.tar,*tar.gz,*tar.xz,*.tar.bz2等后缀的压缩文件。</li><li><p>1..zip压缩打包程序</p><ul><li><p>1.1 打包文件夹<br>zip -r -q -o njust.zip /home/cdl</p><ul><li>参数说明:<ul><li>-r：表示递归打包包含子目录的全部内容</li><li>-q：表示为安静模式，即不向屏幕输出信息</li><li>-o：表示输出文件，需要在其后紧跟打包输出文件名</li></ul></li><li>查看压缩文件的信息：  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">du -<span class="keyword">h</span> njust.<span class="keyword">zip</span></span><br><span class="line"><span class="keyword">file</span> njust.<span class="keyword">zip</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>1.2 设置压缩等级(9最小,1最大)<br>  zip -r 9 -q -o njust_9.zip /home/cdl -x ~/*.zip<br>  zip -r -1 -q -o njust_1.zip /home/cdl -x ~/*.zip<br>这里添加了一个参数用于设置压缩级别[1-9],1表示最快压缩但体积大，9表示体积最小但耗时最久。最后那个-x是为了排除上一次创建的zip文件，否则又会被打包进这一次的压缩文件中。这里只能使用绝对路径！！！</p><ul><li><p>再使用du命令分别查看默认压缩等级、最低和最高压缩级别及未压缩的文件的大小：</p>   <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">du</span> -h -d <span class="number">0</span> <span class="regexp">*.zip</span> | sort</span><br></pre></td></tr></table></figure></li><li><p>通过man手册可知：</p><ul><li>-h：输入人类可以解释的信息</li><li>-d：所查看文件的深度</li></ul></li></ul></li><li>1.3 创建加密zip包(使用-e参数可以创建加密压缩包)<br>  zip -r -e -o njust_encryption.zip /home/cdl<ul><li>注意：关于zip命令，因为windows系统与Linux在文本文件格式上的兼容问题，比如换行符(为不可见字符)，在windows为回车加换行，Linux上为换行；所以如果不加处理的话，在Linux上编辑的文本文件，在windows系统上打开可能看起来是没有换行的。如果想让在Linux创建的zip压缩文件在Windows系统上解压后没有任何问题，那么还需要对命令进行修改：<br>  zip -r -l -o njust.zip /home/cdl   需要加上-l参数将换行转为回车加换行</li></ul></li></ul></li><li><p>2.使用unzip命令解压缩zip文件</p><ul><li>将njust.zip解压到当前目录下：<br>  unzip njust.zip</li><li>使用安静模式，将文件解压到指定目录，指定目录不存在，会自动创建：<br>  unzip -q njust.zip -d ziptest</li><li>如果不想解压只想查看压缩包的内容，可以使用-l参数：<br>  unzip -l njust.zip<br>  注意：使用unzip解压文件时同样应该注意兼容问题，不过这里此时关心的不再是上面的问题，而是中文编码的问题。通常windows系统上创建的压缩文件，如果有包含中文的文档或以中文作为文件名的文件时，默认会采用GBK或其他编码，而Linux上默认使用utf-8编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题(有时候它会帮你自动处理)。为了解决这个问题，可以在解压时指定编码类型。</li><li>使用-O(大写的字母O)参数指定编码类型： <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">unzip</span> <span class="selector-tag">-O</span> <span class="selector-tag">GBK</span> 中文压缩文件<span class="selector-class">.zip</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>3..rar文件打包压缩命令</p><ul><li>rar也是windows上常用的一种压缩文件的格式，在Linux上可以使用rar和unrar工具分别创建和解压rar压缩包</li><li>首先使用需要安装rar和unrar工具：<br>  sudo apt-get update<br>  sudo apt-get install rar unrar</li><li>在使用rar、unrar命令时，应该注意命令参数前不加-，否则会报错！<br>  rm *.zip<br>  rar a njust.rar<br>上面的命令使用a参数添加一个目录~到一个归档文件中，如果该文件不存在就会自动创建。</li><li>如果不解压只是查看文件，可以使用参数l：<br>  rar l njust.rar</li><li>全路径解压：<br>  unrar x njust.rar</li><li>去掉全路径解压：<br>  mkdir temp<br>  unrar e njust.rar temp/</li></ul></li><li>4..tar打包工具<ul><li>在Linux上面更常用的是tar工具，tar原本只是一个打包工具，只是同时还实现了对7z，gizp，xz，bzip2等工具的支持</li><li>创建一个tar包：<br>tar -cf njust.tar ~   (此命令会自动去掉表示绝对路径的/，也可以使用-P保留绝对路径符)</li><li>参数说明：</li><li>-c：创建一个tar包文件</li><li>-f：指定创建文件的名，注意文件名必须紧跟在-f参数后，不能写成tar -fc njust.tar!可以写成tar -f njust.tar -c ~</li><li>-v：以可视的方式输出打包的文件</li><li>解压一个文件(-x参数)到指定路径的已存在目录(-C参数)：<br>mkdir tardir<br>tar -xf njust.tar -C tardir</li><li>只查看不解压文件-t参数：<br>tar -tf njust.tar</li><li>对于创建不同压缩格式的文件时，对于tar来说是非常简单，需要的只是换一个参数，这里以使用gzip工具创建.tar.gz文件为例来说明。只需要在创建tar文件的基础上加一个-z参数，使用gzip来压缩文件：tar -czf njust.tar.gz ~</li><li>解压*.tar.gz文件到当前文件夹：<br>tar -xzf njust.tar.gz</li><li>现在要使用其他的压缩工具创建或解压相应文件时，只需要更改一个参数即可：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-34cfcf22721e7015.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tar解压命令.png"></li><li>此外，还有gzip和gunzip(相当于gzip -d)：压缩和解压命令，解压文件为.gz后缀</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、文件打包和解压缩&quot;&gt;&lt;a href=&quot;#一、文件打包和解压缩&quot; class=&quot;headerlink&quot; title=&quot;一、文件打包和解压缩&quot;&gt;&lt;/a&gt;一、文件打包和解压缩&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在windows系统上最常见的压缩文件不外乎这三种*.zip,*
      
    
    </summary>
    
      <category term="Linux" scheme="https://cdlwhm1217096231.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://cdlwhm1217096231.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow中的RNNCell基本单元使用</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow%E4%B8%AD%E7%9A%84RNNCell%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83%E4%BD%BF%E7%94%A8/"/>
    <id>https://cdlwhm1217096231.github.io/深度学习/TensorFlow中的RNNCell基本单元使用/</id>
    <published>2019-07-29T11:43:57.000Z</published>
    <updated>2019-07-29T11:44:51.378Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-charRNN基础介绍"><a href="#0-charRNN基础介绍" class="headerlink" title="0.charRNN基础介绍"></a>0.charRNN基础介绍</h3><ul><li>charRNN 是N vs N的循环神经网络，要求输入序列长度等于输出序列长度。<br>原理：用已经输入的字母去预测下一个字母的概率。一个句子是hello!,例如输入序列是hello,则输出序列是ello!<br>预测时：首先选择一个x1当作起始的字符，然后用训练好的模型得到下一个字符出现的概率。根据这个概率选择一个字符输出，然后将此字符当作下一步的x2输入到模型中。依次递推，得到任意长度的文字。<strong>注意：输入的单个字母是以one-hot形式进行编码的！</strong></li><li>对中文进行建模时，每一步输入模型的是一个汉字，由于汉字的种类太多，导致模型太大，一般采用下面的方法进行优化：<ul><li>1.取最常用的N个汉字，将剩下的汉字变成单独的一类，用一个\<unk\>字符来进行标注</unk\></li><li>2.在输入时，可以加入一个embedding层，将汉字的one-hot编码转为稠密的词嵌入表示。对单个字母不使用embedding是由于单个字母不具备任何的含义，只需要使用one-hot编码即可。单个汉字是具有一定的实际意义的，所以使用embedding层</li></ul></li></ul><h3 id="1-实现RNN的基本单元RNNCell抽象类————有两种直接使用的子类-BasicRNNCell-基本的RNN-和LSTMCell-基本的LSTM"><a href="#1-实现RNN的基本单元RNNCell抽象类————有两种直接使用的子类-BasicRNNCell-基本的RNN-和LSTMCell-基本的LSTM" class="headerlink" title="1.实现RNN的基本单元RNNCell抽象类————有两种直接使用的子类:BasicRNNCell(基本的RNN)和LSTMCell(基本的LSTM)"></a>1.实现RNN的基本单元RNNCell抽象类————有两种直接使用的子类:BasicRNNCell(基本的RNN)和LSTMCell(基本的LSTM)</h3><ul><li>RNNCell有三个属性:<ul><li>1.类方法call:所有的子类都会实现一个<strong>call</strong>函数，可以实现RNN的单步计算，调用形式：(output,next<em>state)=\</em>_call__(input, state)</li><li>2.类属性state<em>size:隐藏层的大小，输入数据是以batch_size的形式进行输入的即input=(batch_size, input_size),调用\</em>_call__函数时隐藏层的形状是(batch_size, state_size),输出层的形状是(batch_size, output_size)</li><li>3.类属性output_size:输出向量的大小</li></ul></li></ul><h3 id="2-定义一个基本的RNN单元"><a href="#2-定义一个基本的RNN单元" class="headerlink" title="2.定义一个基本的RNN单元"></a>2.定义一个基本的RNN单元</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">rnn_cell = tf<span class="selector-class">.nn</span><span class="selector-class">.rnn_cell</span><span class="selector-class">.BasicRNNCell</span>(num_units=<span class="number">128</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"rnn_cell.state_size:"</span>, rnn_cell.state_size)</span></span></span><br></pre></td></tr></table></figure><h3 id="3-定义一个基本的LSTM的基本单元"><a href="#3-定义一个基本的LSTM的基本单元" class="headerlink" title="3.定义一个基本的LSTM的基本单元"></a>3.定义一个基本的LSTM的基本单元</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lstm_cell = tf.nn.rnn_cell.LSTMCell(<span class="attribute">num_units</span>=128)</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"lstm_cell.state_size:"</span>, lstm_cell.state_size)</span><br><span class="line"></span><br><span class="line">lstm_cell = tf.nn.rnn_cell.LSTMCell(<span class="attribute">num_units</span>=128) # <span class="attribute">batch_size</span>=32, <span class="attribute">input_size</span>=100</span><br><span class="line">inputs = tf.placeholder(np.float32, shape=(32, 100))</span><br><span class="line">h0 = lstm_cell.zero_state(32, np.float32)  # 通过zero_state得到一个全0的初始状态</span><br><span class="line">output, h1 = lstm_cell.__call__(inputs, h0)</span><br><span class="line"><span class="builtin-name">print</span>(h1.c)</span><br><span class="line"><span class="builtin-name">print</span>(h1.h)</span><br></pre></td></tr></table></figure><h3 id="4-对RNN进行堆叠：MultiRNNCell"><a href="#4-对RNN进行堆叠：MultiRNNCell" class="headerlink" title="4.对RNN进行堆叠：MultiRNNCell"></a>4.对RNN进行堆叠：MultiRNNCell</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次调用这个函数返回一个BasicRNNCell</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_a_cell</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.rnn_cell.BasicRNNCell(num_units=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用MultiRNNCell创建3层RNN</span></span><br><span class="line">cell = tf.nn.rnn_cell.MultiRNNCell([get_a_cell() <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)])</span><br><span class="line"><span class="comment"># 得到的RNN也是RNNCell的子类,state_size=(128, 128, 128):三个隐层状态，每个隐层状态的大小是128</span></span><br><span class="line">print(cell.state_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32是batch_size, 100是input_size</span></span><br><span class="line">inputs = tf.placeholder(np.float32, shape=(<span class="number">32</span>, <span class="number">100</span>))</span><br><span class="line">h0 = cell.zero_state(<span class="number">32</span>, np.float32)</span><br><span class="line">output, h1 = cell.__call__(inputs, h0)</span><br><span class="line">print(h1)</span><br></pre></td></tr></table></figure><h3 id="5-使用tf-nn-dunamic-rnn按时间展开：相当于增加了一个时间维度time-steps-通过-h0-x1-x2…-xn-得到-h1-h2-h3-…hn"><a href="#5-使用tf-nn-dunamic-rnn按时间展开：相当于增加了一个时间维度time-steps-通过-h0-x1-x2…-xn-得到-h1-h2-h3-…hn" class="headerlink" title="5.使用tf.nn.dunamic_rnn按时间展开：相当于增加了一个时间维度time_steps,通过{h0,x1,x2…,xn}得到{h1,h2,h3,…hn}"></a>5.使用tf.nn.dunamic_rnn按时间展开：相当于增加了一个时间维度time_steps,通过{h0,x1,x2…,xn}得到{h1,h2,h3,…hn}</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inputs: shape=(batch_size, time_steps, input_size)  <span class="comment"># 输入数据的格式是(batch_size, time_steps, input_size)</span></span><br><span class="line">initial_state:  shape(batch_size,cell.state_size)  <span class="comment"># 初始状态,一般可以取零矩阵</span></span><br><span class="line">outputs, <span class="keyword">state</span> = tf.nn.dynamic_rnn(cell,inputs,initial_state)</span><br><span class="line"><span class="comment"># outputs是time_steps中所有的输出，形状是(batch_size, time_steps, cell.output_size)</span></span><br><span class="line"><span class="comment"># state是最后一步的隐状态，形状是(batch_size,cell.state_size)</span></span><br></pre></td></tr></table></figure><ul><li>注意：输入数据的形状是(time_steps,batch_size, input_size),可以调用tf.nn.dynamic_rnn()函数中设定参数time_major=True。此时，得到的outputs的形状是(time_steps, batch_size, cell.output_size);state的形状不变化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-charRNN基础介绍&quot;&gt;&lt;a href=&quot;#0-charRNN基础介绍&quot; class=&quot;headerlink&quot; title=&quot;0.charRNN基础介绍&quot;&gt;&lt;/a&gt;0.charRNN基础介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;charRNN 是N vs N的循环神经
      
    
    </summary>
    
      <category term="深度学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow" scheme="https://cdlwhm1217096231.github.io/tags/TensorFlow/"/>
    
  </entry>
  
</feed>
