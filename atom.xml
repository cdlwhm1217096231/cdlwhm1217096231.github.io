<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Curry_Coder的空间</title>
  
  <subtitle>好好学习，天天向上！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cdlwhm1217096231.github.io/"/>
  <updated>2020-03-08T06:55:13.231Z</updated>
  <id>https://cdlwhm1217096231.github.io/</id>
  
  <author>
    <name>Curry_Coder</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01移动端布局基础之流式布局</title>
    <link href="https://cdlwhm1217096231.github.io/%E7%A7%BB%E5%8A%A8%E7%AB%AF/01%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <id>https://cdlwhm1217096231.github.io/移动端/01移动端布局基础之流式布局/</id>
    <published>2020-03-08T06:24:06.000Z</published>
    <updated>2020-03-08T06:55:13.231Z</updated>
    
    <content type="html"><![CDATA[<h3 id="技术交流QQ群-1027579432，欢迎你的加入！"><a href="#技术交流QQ群-1027579432，欢迎你的加入！" class="headerlink" title="技术交流QQ群:1027579432，欢迎你的加入！"></a>技术交流QQ群:1027579432，欢迎你的加入！</h3><h4 id="1-移动端基础"><a href="#1-移动端基础" class="headerlink" title="1.移动端基础"></a>1.移动端基础</h4><ul><li><strong>浏览器现状</strong><ul><li>PC端常见浏览器：360浏览器、谷歌浏览器、火狐浏览器、QQ浏览器、百度浏览器、搜狗浏览器、IE浏览器等。<br>移动端常见浏览器：UC浏览器、QQ浏览器、欧朋浏览器、百度手机浏览器等。</li></ul></li><li>国内的UC、QQ、百度等手机浏览器都是根据Webkit修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于安卓修改开发的一样。</li><li><strong>总结：兼容移动端主流浏览器，处理Webkit内核浏览器即可</strong>。</li><li><strong>手机屏幕现状</strong><ul><li>移动端设备屏幕尺寸非常多，碎片化严重；</li><li>Android设备有多种分辨率：480*480、480*854、720*1280、1080*1920等；</li><li>作为开发者无需关注这些分辨率，因为常用的尺寸单位是px；</li></ul></li><li><strong>常见移动端屏幕尺寸</strong><br><img src="https://upload-images.jianshu.io/upload_images/13407176-3f1ff3cf24a20445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常见移动端屏幕尺寸.png"></li><li><strong>移动端调试方法</strong><ul><li>Chrome DevTools(谷歌浏览器)的模拟手机调试；</li><li>搭建本地web服务器，手机和服务器在一个局域网内，通过手机访问服务器；</li><li>使用外网服务器，直接IP或域名访问；</li></ul></li></ul><h4 id="2-视口"><a href="#2-视口" class="headerlink" title="2.视口"></a>2.视口</h4><ul><li>视口：<strong>浏览器显示页面内容的屏幕区域，视口可以分为布局视口、视觉视口、理想视口</strong>。</li><li><strong>布局视口layout viewport</strong><br><img src="https://upload-images.jianshu.io/upload_images/13407176-495c836b80b28244.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="布局视口.png"><ul><li>一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期PC端页面在手机上显示的问题；</li><li>IOS、Android基本都将这个视口分辨率设置为980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页；</li></ul></li><li><strong>视觉视口visual viewport</strong><br><img src="https://upload-images.jianshu.io/upload_images/13407176-ad0439ed712c587c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="视觉视口.png"><ul><li>它是用户正在看到的网站的区域。注意：<strong>是网站的区域</strong>；</li><li>我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍然保持原来的宽度；</li></ul></li><li><strong>理想视口ideal viewport</strong><ul><li>为了使网站能在移动端有最理想的浏览和阅读宽度而设定；</li><li>理想视口，对设备来说，是最理论的视口尺寸；</li><li>需要手动添加meta视口标签通知浏览器操作；</li><li>meta视口标签主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，布局视口就要有多宽。</li></ul></li></ul><h4 id="3-meta视口标签"><a href="#3-meta视口标签" class="headerlink" title="3.meta视口标签"></a>3.meta视口标签</h4><ul><li>语法格式： <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attr">name="viewport"</span> <span class="attr">content="width=device-width,</span> <span class="attr">user-scalable=no,</span> <span class="attr">initial-scale=1.0,</span> <span class="attr">maximum-scale=1.0,</span> <span class="attr">minimum-scale=1.0"&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/13407176-e6f98453e29928a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="meta视口标签属性.png"></p><ul><li>标准的viewport设置<ul><li>视口宽度和设备保持一致；</li><li>视口的默认缩放比例1.0；</li><li>不允许用户自行缩放；</li><li>最大允许的缩放比例1.0；</li><li>最小允许的缩放比例1.0；</li></ul></li></ul><h4 id="4-二倍图"><a href="#4-二倍图" class="headerlink" title="4.二倍图"></a>4.二倍图</h4><ul><li><strong>物理像素和物理像素比</strong><ul><li>物理像素指的是屏幕显示的最小颗粒，是物理中真实存在的。这是厂商在出厂时就设置好了。例如苹果手机的750*1334；</li><li>开发时的1px不是一定等于1个物理像素的；</li><li>PC端页面中，1px等于1个物理像素的，但是移动端就不尽相同；</li><li>1px能显示的物理像素点的个数，称为物理像素比或屏幕像素比；</li></ul></li></ul><h4 id="5-多倍图"><a href="#5-多倍图" class="headerlink" title="5.多倍图"></a>5.多倍图</h4><ul><li>PC端和手机端的手机屏幕/普通手机屏幕：1CSS像素=1物理像素</li><li>Retina(视网膜屏幕)是一种显示技术，可以把更多的物理像素点压缩至一块屏幕中，从而达到更高的分辨率，并提高屏幕显示的细腻程度。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-29b015652de3f813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="视网膜屏幕显示技术.png"></li><li>对于一张50px*50px的图片，在手机Retina屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊；</li><li>在标准的viewport设置中，使用倍图来提高图片的质量，解决在高清设备中的模糊问题；</li><li>通常使用二倍图，因为iphone8的影响，但是现在还存在3倍图、4倍图的情况，这个根据实际开发需求；</li><li>背景图片，注意缩放问题；</li></ul><h4 id="6-背景缩放background-size"><a href="#6-背景缩放background-size" class="headerlink" title="6.背景缩放background-size"></a>6.背景缩放background-size</h4><ul><li>background-size属性规定了背景图像的尺寸；</li><li><p>语法格式：</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">background</span>-<span class="built_in">size</span>: 背景图片宽度 背景图片高度;</span><br></pre></td></tr></table></figure></li><li><p>单位：长度或百分比或cover或contain；</p></li><li>cover把背景图像扩展足够大，从而使背景图像完全覆盖背景区域；</li><li>contain把背景图像扩展到最大尺寸，从而使宽度和高度完全适应内容区域；</li><li>多倍图切图cutterman<ul><li>@1*1倍图原图</li><li>@2*2倍图</li><li>@3*3倍图</li></ul></li></ul><h4 id="7-移动端开发选择"><a href="#7-移动端开发选择" class="headerlink" title="7.移动端开发选择"></a>7.移动端开发选择</h4><ul><li>a.单独制作移动端页面(主流)：通常情况下，网址域名前面加m(mobile)可以打开移动端。通过判断设备，如果是移动设备打开，则跳动<strong>移动端页面</strong>。<ul><li>京东商城手机版</li><li>淘宝触屏版</li><li>苏宁易购手机版</li></ul></li><li>b.<strong>响应式</strong>页面兼容移动端(其次)：通过判断屏幕宽度改变样式，以适应不同终端。缺点：制作麻烦，需要花很多精力去调<strong>兼容性</strong>问题。<ul><li>三星手机官网</li></ul></li></ul><h4 id="8-移动端技术解决方案"><a href="#8-移动端技术解决方案" class="headerlink" title="8.移动端技术解决方案"></a>8.移动端技术解决方案</h4><ul><li><strong>移动端浏览器</strong><ul><li>移动端浏览器基本以webkit内核为主，因此就需要考虑webkit兼容性问题；</li><li>可以放心使用H5标签和CSS3样式；</li><li>同时，我们浏览器的私有前缀只需要考虑添加webkit即可；</li></ul></li><li><strong>CSS样式初始化</strong>normalize.css<ul><li>移动端CSS初始化推荐使用normalize.css；</li></ul></li><li><p><strong>CSS盒子模型box-sizing</strong></p><ul><li>传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding；</li><li><p>CSS3盒子模型：盒子的宽度 = CSS中设置的宽度width里面包含了border和padding。即CSS3中的盒子模型，padding和border不会撑大盒子；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS3盒子模型 --&gt;</span></span><br><span class="line">box-sizing: border-box;</span><br><span class="line"><span class="comment">&lt;!-- 传统盒子模型 --&gt;</span></span><br><span class="line">box-sizing: content-box;</span><br></pre></td></tr></table></figure></li><li><p>移动端可以全部使用CSS3盒子模型；</p></li><li>PC端如果完全需要兼容，就使用传统盒子模型；如果不考虑兼容性，就选择CSS3盒子模型；</li></ul></li></ul><h4 id="9-特殊样式"><a href="#9-特殊样式" class="headerlink" title="9.特殊样式"></a>9.特殊样式</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS盒子模型 --&gt;</span></span><br><span class="line">box-sizing: border-box;</span><br><span class="line">-webkit-box-sizing: border-box;</span><br><span class="line"><span class="comment">&lt;!-- 点击高亮我们需要清除 设置transparent完成透明 --&gt;</span></span><br><span class="line">-webkit-tap-highlight-color: transparent;</span><br><span class="line"><span class="comment">&lt;!-- 在移动端浏览器默认的外观在IOS上加上这个属性才能给按钮和输入框自定义样式 --&gt;</span></span><br><span class="line">-webkit-appearance: none;</span><br><span class="line"><span class="comment">&lt;!-- 禁止长按页面时的弹出菜单 --&gt;</span></span><br><span class="line">img,a &#123;-webkit-touch-callout: none;&#125;</span><br></pre></td></tr></table></figure><h4 id="10-移动端常见布局"><a href="#10-移动端常见布局" class="headerlink" title="10.移动端常见布局"></a>10.移动端常见布局</h4><ul><li>移动端布局和PC端有所区别：<ul><li>a.单独制作移动端页面(主流)<ul><li>流式布局(百分比布局)</li><li>flex弹性布局(强烈推荐)</li><li>less+rem+媒体查询布局</li><li>混合布局</li></ul></li><li>b.<strong>响应式</strong>页面兼容移动端(其次)<ul><li>媒体查询</li><li>bootstarp</li></ul></li></ul></li></ul><h4 id="11-移动端布局之流式布局"><a href="#11-移动端布局之流式布局" class="headerlink" title="11.移动端布局之流式布局"></a>11.移动端布局之流式布局</h4><ul><li>流式布局，就是百分比布局，也称为非固定像素布局；</li><li>通过盒子的宽度设置成百分比来根据屏幕的宽度进行伸缩，不受固定像素的限制，内容向两侧填充；</li><li>流式布局方式是移动web开发中使用的比较常见的布局方式；</li><li>max-width 最大宽度(max-height 最大高度)</li><li>min-width 最小宽度 (min-height 最小高度)</li></ul><h4 id="12-资料下载"><a href="#12-资料下载" class="headerlink" title="12.资料下载"></a>12.资料下载</h4><ul><li><a href="https://github.com/cdlwhm1217096231/HTML_CSS_JavaScript/tree/master/CSS3/01%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80" target="_blank" rel="noopener">笔记及代码，欢迎star,follow,fork……</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;技术交流QQ群-1027579432，欢迎你的加入！&quot;&gt;&lt;a href=&quot;#技术交流QQ群-1027579432，欢迎你的加入！&quot; class=&quot;headerlink&quot; title=&quot;技术交流QQ群:1027579432，欢迎你的加入！&quot;&gt;&lt;/a&gt;技术交流QQ群:
      
    
    </summary>
    
      <category term="移动端" scheme="https://cdlwhm1217096231.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="Web前端开发" scheme="https://cdlwhm1217096231.github.io/tags/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer第二版题解(详细版)</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88%E9%A2%98%E8%A7%A3-%E8%AF%A6%E7%BB%86%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/数据结构与算法/剑指offer第二版题解-详细版/</id>
    <published>2019-09-09T08:22:44.000Z</published>
    <updated>2020-03-08T07:00:18.942Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-滑动窗口的最大值（剑指offer原59题）"><a href="#1-滑动窗口的最大值（剑指offer原59题）" class="headerlink" title="1.滑动窗口的最大值（剑指offer原59题）"></a>1.滑动窗口的最大值（剑指offer原59题）</h4><ul><li>解题思路：<strong>其实是一个队列的问题，用一个队列去维护当前窗口中的所有元素；首先将超出窗口中的队头元素先删掉，然后将新的元素插入当前窗口中，插入时要判断新插入的元素与队尾元素的大小，如果队尾元素较小，则先删除队尾元素再插入</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)   <span class="comment">// k是窗口的大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; q.front() &lt;= i - k) q.pop_front();  <span class="comment">// 将已经划出窗口中的元素从队列中删除</span></span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; nums[q.back()] &lt;= nums[i])  nums.pop_back();   <span class="comment">// 如果在队尾插入的元素大于等于当前队尾的元素值，就可以删除队尾的元素！</span></span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) res.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！-与剑指offer60题有点差别！"><a href="#2-n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！-与剑指offer60题有点差别！" class="headerlink" title="2.n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！(与剑指offer60题有点差别！)"></a>2.n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！(与剑指offer60题有点差别！)</h4><ul><li><p>解题思路：每次扔骰子，最小值是1，最大值是6；所以扔n个骰子在地上后的，最小值就是n，最大值就是6*n。dfs()算法的思路：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs方法来解决：注意两点，第一是状态的表示是什么(从输出中来)？第二是按照什么顺序来计算第一步中的状态？</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numberOfDice(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt;= <span class="number">6</span> * n; i++) res.push_back(dfs(n, i));  <span class="comment">// dfs(n, s)表示的就是所要输出的结果；也就是每次求总和是s的情况下，一共投了n次骰子，一共有多少种方案</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> !sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res += dfs(n - <span class="number">1</span>, sum - i);  <span class="comment">// 热狗法：最后一次骰子点数已经确定时，则只需要计算前面投了n-1次骰子，总和是s-i的情况下，一共有多少种方案。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>动态规划算法dp的思路：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dp方法来解决：注意三点，第一是状态的表示是什么(从输出中来)？第二是如何计算第一步中的状态？第三是边界问题</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numberOfDice(<span class="keyword">int</span> n)&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n * <span class="number">6</span> + <span class="number">1</span>));  <span class="comment">// dp的状态表示</span></span><br><span class="line">       f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 当所有的骰子都没有扔出时，总和s=0时，只有一种方案；总和s=1, 2, 3, 4, ....都是不合法的！</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;  <span class="comment">// 先循环扔出去的次数</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i * <span class="number">6</span>; j++)&#123;      <span class="comment">// 再循环总和s是多少</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= min(j, <span class="number">6</span>); k++)&#123;  <span class="comment">// 枚举最后一次的点数是多少</span></span><br><span class="line">                    f[i][j] += f[i- <span class="number">1</span>][j - k];  <span class="comment">// 状态f[i][j]表示前i次总和是j的方案数！</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt;= n * <span class="number">6</span>; i++) res.push_back(f[n][i]);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-扑克牌的顺子-剑指offer原61题"><a href="#3-扑克牌的顺子-剑指offer原61题" class="headerlink" title="3.扑克牌的顺子(剑指offer原61题)"></a>3.扑克牌的顺子(剑指offer原61题)</h4><ul><li>解题思路：模拟人的想法，先将<strong>除去了大小王之外</strong>的牌拿过来，如果有相同元素，则一定不是顺子！如果没有任何两个元素相同，看一下牌中最小值与最大值的差距是否在4以内。如果满足条件，则可以将缺失的部分用大小王来进行填补。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从扑克牌中随机抽5张牌，判断是不是一个顺子。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isContinous</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nums[k]) k++;   <span class="comment">// 去掉行首的0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt; nums.size(); i++)&#123;  <span class="comment">// 去掉重复元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums.back() - nums[k] &lt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-圆圈中最后剩下的数字-剑指offer原62题-——约瑟夫环问题"><a href="#4-圆圈中最后剩下的数字-剑指offer原62题-——约瑟夫环问题" class="headerlink" title="4.圆圈中最后剩下的数字(剑指offer原62题)——约瑟夫环问题"></a>4.圆圈中最后剩下的数字(剑指offer原62题)——约瑟夫环问题</h4><ul><li>解题思路：f(n,m)表示总共n个数字，每次报到数字m时，就将此数字从环中删除,最后剩下的数字。f(n-1,m)表示从剩下的n-1个数字中，每次报到数字m时，就将此数字从环中删除，最后剩下的数字。观察f(n,m)与f(n-1,m)之间的关系，可知f(n,m) = (f(n-1,m) + m) % n,其中边界条件是f(n==1, m) = 0;  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (lastRemaining(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-股票的最大利润（剑指offer原63题）"><a href="#5-股票的最大利润（剑指offer原63题）" class="headerlink" title="5.股票的最大利润（剑指offer原63题）"></a>5.股票的最大利润（剑指offer原63题）</h4><ul><li>解题思路：找出前i天的最小值，利用一个变量minValue来存储。第i天卖出的价格是nums[i]，最大利润res是等于第i天卖出价格与前i天中价格最低时买入的价格之差，此时获得的利润是最大的。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDiff</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;   <span class="comment">// 最大利润</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, minValue = nums[<span class="number">0</span>]; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            res = max(res, nums[i] - minValue);  <span class="comment">// minValue表示前i天的最小值，nums[i]表示第i天卖出的价格！</span></span><br><span class="line">            minValue = min(minValue, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-求1-2-3-…-n，不能使用乘除法和各种循环、判断语句-剑指offer原64题"><a href="#6-求1-2-3-…-n，不能使用乘除法和各种循环、判断语句-剑指offer原64题" class="headerlink" title="6.求1+2+3+…+n，不能使用乘除法和各种循环、判断语句(剑指offer原64题)"></a>6.求1+2+3+…+n，不能使用乘除法和各种循环、判断语句(剑指offer原64题)</h4><ul><li>解题思路：使用递归的思路来写，但是将当中的if语句，改成&amp;&amp;运算符。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        n &gt; <span class="number">0</span> &amp;&amp; (res += getSum(n - <span class="number">1</span>));   <span class="comment">// 实际是对if(n &gt; 0) res += getSum(n - 1);语句的改写</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-不用加减乘除做加法-剑指offer原65题"><a href="#7-不用加减乘除做加法-剑指offer原65题" class="headerlink" title="7.不用加减乘除做加法(剑指offer原65题)"></a>7.不用加减乘除做加法(剑指offer原65题)</h4><ul><li>解题思路：模拟计算机中的加法A + B，结果是CD。其中C是十位，D是个位。A和B对应位上的取值有四种(0 0、0 1、1 0、1 1)，C上的结果是(0 0 0 1),D上的结果是(0 1 1 0)。可以将C上的结果看出(A对应位上的取值 &amp; B对应位上的取值)；将D上的结果看出(A对应位上的取值 ^ B对应位上的取值)。因此，可以将多位数相加A + B可以看出是A + B= A^B(无进位) + (A &amp; B &lt;&lt; 1)(A &amp; B表示的就是进位)。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num2)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 ^ num2;</span><br><span class="line">            <span class="keyword">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-构建乘积数组-剑指offer原66题-不能用除法、只能开一个数组"><a href="#8-构建乘积数组-剑指offer原66题-不能用除法、只能开一个数组" class="headerlink" title="8.构建乘积数组(剑指offer原66题)[不能用除法、只能开一个数组]"></a>8.构建乘积数组(剑指offer原66题)[不能用除法、只能开一个数组]</h4><ul><li>解题思路：B[i] = A[0] * A[1] * … * A[i-1] * A[i+1] * … * A[n-1]。可以先算i的左半边 A[0] * A[1] * … * A[i-1]，然后算i的右半边A[i+1] * … * A[n-1]，最后两部分相乘。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先算A[0]到A[i-1]的乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            B[i] = p;</span><br><span class="line">            p *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再算A[i+1]到A[n-1]的乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>, p = <span class="number">1</span>; ~i; i--)&#123;</span><br><span class="line">            B[i] *= p;</span><br><span class="line">            p *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-把字符串转换成整数-剑指offer原67题"><a href="#9-把字符串转换成整数-剑指offer原67题" class="headerlink" title="9.把字符串转换成整数(剑指offer原67题)"></a>9.把字符串转换成整数(剑指offer原67题)</h4><ul><li>解题思路：处理好各种边界问题！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; str.size() &amp;&amp; str[k] == <span class="string">' '</span>) k++;  <span class="comment">// 忽略所有的行首空格！</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> is_minus = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 忽略完行首的空格后，可能有-/+的符号</span></span><br><span class="line">        <span class="keyword">if</span>(str[k] == <span class="string">'+'</span>) k++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[k] == <span class="string">'-'</span>) k++, is_minus = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k &lt; str.size() &amp;&amp; str[k] &gt;= <span class="string">'0'</span> &amp;&amp; str[k] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">            number = number * <span class="number">10</span> + str[k] - <span class="string">'0'</span>;   <span class="comment">// 字符串表示的数字转换成真正的数字</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is_minus) number *= <span class="number">-1</span>;  <span class="comment">// 处理负数的情况</span></span><br><span class="line">        <span class="keyword">if</span>(number &gt; INT_MAX) number = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(number &lt; INT_MIN) number = INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-树中两个结点的最低公共祖先-剑指offer原68题"><a href="#10-树中两个结点的最低公共祖先-剑指offer原68题" class="headerlink" title="10.树中两个结点的最低公共祖先(剑指offer原68题)"></a>10.树中两个结点的最低公共祖先(剑指offer原68题)</h4><ul><li>解题思路：给出的两个结点的位置可能有两种情况，一种是两个结点出现在一个结点的左右两个子树上；另一种是一个给定的结点出现最低公共祖先节点上，另一个给定的结点出现在左子树或右子树上！<br>具体的方法是：先遍历左子树，检查是否有给定的两个结点p、q；再遍历右子树，检查是否有给定的两个结点p、q。如果左右子树中同时出现了p、q，则当前结点就是需要返回的就是最低公共祖先结点；如果只在左子树或右子树中出现p、q，则返回值就是p、q的最低公共祖先。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 空树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> left = lowestCommonAncestor(root-&gt;left, p, q);   <span class="comment">// 检查一下左边是否有p和q</span></span><br><span class="line">        <span class="keyword">auto</span> right = lowestCommonAncestor(root-&gt;right, p, q);  <span class="comment">// 检查一下右边是否有p和q</span></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-数字在排序数组中出现的次数-剑指offer原53题—题目一）"><a href="#11-数字在排序数组中出现的次数-剑指offer原53题—题目一）" class="headerlink" title="11.数字在排序数组中出现的次数(剑指offer原53题—题目一）"></a>11.数字在排序数组中出现的次数(剑指offer原53题—题目一）</h4><ul><li>解题思路：<strong>二分法解决！</strong>就是此数字第一次出现的位置与此数字最后一次出现的位置，两者之间的数的个数就是该数字出现的次数！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; k) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[l] != k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = l;</span><br><span class="line">        l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= k) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="12-0到n-1中缺失的数字-剑指offer原53题—-题目二"><a href="#12-0到n-1中缺失的数字-剑指offer原53题—-题目二" class="headerlink" title="12.0到n-1中缺失的数字(剑指offer原53题—-题目二)"></a>12.0到n-1中缺失的数字(剑指offer原53题—-题目二)</h4><ul><li>题目要求的是：长度为n的数组,将其中的一个数删掉，只剩下n-1个数了。将剩下的n-1个数作为程序的输入，找出被删除的那个数！</li><li>解题思路：先计算0到n-1中的n个数的和，再减去当前序列中的每个数，也就可以得到答案了。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;  <span class="comment">// nums是输入的n-1个数</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = (n - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums) res -= x;</span><br><span class="line">        <span class="keyword">return</span> res;   <span class="comment">// res就是0到n-1中缺失的那个数字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="13-数组中数值和下标相等的元素-剑指offer原53题—-题目三"><a href="#13-数组中数值和下标相等的元素-剑指offer原53题—-题目三" class="headerlink" title="13.数组中数值和下标相等的元素(剑指offer原53题—-题目三)"></a>13.数组中数值和下标相等的元素(剑指offer原53题—-题目三)</h4><ul><li>解题思路：因为给定的数组nums具有单调递增的性质，可以使用二分查找，时间复杂度是O(logn)。考察数组nums[i]-i是否具有单调性。即（nums[i]-i &gt;= nums[i-1] - (i-1)是否成立？）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] - mid &gt;= <span class="number">0</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[r] - r == <span class="number">0</span>) <span class="keyword">return</span> r;  <span class="comment">// 相等元素的下标</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="14-二叉搜索树的第K个大的结点-剑指offer原54题"><a href="#14-二叉搜索树的第K个大的结点-剑指offer原54题" class="headerlink" title="14.二叉搜索树的第K个大的结点(剑指offer原54题)"></a>14.二叉搜索树的第K个大的结点(剑指offer原54题)</h4><ul><li>解题思路：先对二叉搜索树进行中序遍历，每遍历到一个结点后，就对K进行减一操作。直到k减小到0后，就已经找到了第K个大的结点。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        dfs(root, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;left, k);  <span class="comment">// 中序遍历</span></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(!k) ans = root;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span>) dfs(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="15-二叉树的深度-剑指offer原55题"><a href="#15-二叉树的深度-剑指offer原55题" class="headerlink" title="15.二叉树的深度(剑指offer原55题)"></a>15.二叉树的深度(剑指offer原55题)</h4><ul><li>解题思路：深度就是找出从根结点到叶子节点的路径最长长度！具体就是找出根节点的左右子树两者中更长者的深度+1，即二叉树的深度。左右子树的深度用递归的方法来求解，当递归到叶子节点时，递归停止！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 递归终止条件！</span></span><br><span class="line">        <span class="keyword">return</span> max(treeDepth(root-&gt;left), treeDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="16-平衡二叉树-剑指offer原55题—题目二"><a href="#16-平衡二叉树-剑指offer原55题—题目二" class="headerlink" title="16.平衡二叉树(剑指offer原55题—题目二)"></a>16.平衡二叉树(剑指offer原55题—题目二)</h4><ul><li>解题思路：利用上一题的思路，求出左右子树的深度之差是否是大于1的，如果所有点的深度差都不大于1的话，则是平衡二叉树；如果任意一个结点的左右子树深度之差大于1，则一定是非平衡二叉树!  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root-&gt;left), right = dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>;  <span class="comment">// 当前结点的深度 == 当前结点左右子树的深度的更大者 + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="17-数组中只出现一次的两个数字-剑指offer原56题"><a href="#17-数组中只出现一次的两个数字-剑指offer原56题" class="headerlink" title="17.数组中只出现一次的两个数字(剑指offer原56题)"></a>17.数组中只出现一次的两个数字(剑指offer原56题)</h4><ul><li>原题是：一个数组中除了两个数字之外，其他数字都出现了2次。利用程序找出这两个只出现一次的数字！</li><li>解题思路：<ul><li><strong>先考虑一种简单的情况</strong>，数组中除了一个数字只出现一次外，其余数字都出现了2次，找出这个只出现一次的数字。<strong>利用异或运算的特点，所有出现两次的数字异或时都被消成0，再将异或结果与只出现一次的数字进行异或，结果就是我们要找的数字</strong>。</li><li>本题中只出现一次的数字有两个，如何找出这两个只出现一次的数呢?<strong>*利用上面一样的操作，对所有的数字执行异或操作，得到的结果是两个只出现一次的数字的异或，由于两个数字都只出现一次。因此，最终的异或结果肯定不等于0</strong>。因为两个只出现一次的数字的异或的结果不等于0，所以异或结果的二进制表示中肯定有一位是1。假设异或结果中的第3位是1，则两个只出现一次的数字二进制表示的第3位一定是不相同的。<strong>此时，将原始数组中所有数字划分成两个集合，划分的依据就是看数组中每个数字的第3位是0还是1。因此，两个只出现一次的数字一定不在同一个集合中！所有出现两次的数字一定在同一个集合中！此时，两个集合中的数字就转化成最开始讨论的一种简单情况的例子</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumsAppearance(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) sum ^= x;   <span class="comment">// 先求所有数字的异或和,也就是sum = x ^ y  x,y分别表示数组中只出现一次的数字</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(sum &gt;&gt; k &amp; <span class="number">1</span>)) k++;  <span class="comment">// 然后从sum中找出其二进制表示中任意一位不为0的位，k存储的就是x ^ y结果中第k位是1的那一位</span></span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;&gt; k &amp; <span class="number">1</span>)   <span class="comment">// 将x的二进制表示中第k位是1的划分到第一个集合first中！</span></span><br><span class="line">                first ^= x;  <span class="comment">// 第一个集合异或的结果first  第二个结果异或的结果first ^ sum</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;first, sum ^ first&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="18-数组中唯一只出现一次的数字-剑指offer原56题—题目2"><a href="#18-数组中唯一只出现一次的数字-剑指offer原56题—题目2" class="headerlink" title="18.数组中唯一只出现一次的数字(剑指offer原56题—题目2)"></a>18.数组中唯一只出现一次的数字(剑指offer原56题—题目2)</h4><ul><li>原题目：一个数组中除了一个数字只出现一次外，其他数字都出现了三次，找出那个只出现一次的数字。</li><li>解题思路：<strong>有限状态机原理，初始的状态是(ones=0,twos=0);输入的数字的二进制表示中某一位是1时，状态转移成(1,0),接着数字的二进制表示中某一位仍然是1时，状态转移成(0,1),接着数字的二进制表示中某一位继续是1时，状态转移成(0,0)。也就是每三个状态构成一个循环；当输入的数字的二进制表示中某一位是0时，从初始的状态是(ones=0,twos=0)转移至自身(0,0)；当所有的输入数字中某一位出现次数是%3余1时，状态就转移到(1,0)；当所有的输入数字中某一位出现次数是%3余0时，状态就转移到(0,0)状态</strong>。ones就代表了上面两种情况的结果。数组中唯一只出现一次的数字。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumberAppearingOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            ones = (ones ^ x) &amp; ~twos;</span><br><span class="line">            twos = (twos ^ x) &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="19-和为s的数字-剑指offer原57题—-题目一"><a href="#19-和为s的数字-剑指offer原57题—-题目一" class="headerlink" title="19.和为s的数字(剑指offer原57题—-题目一)"></a>19.和为s的数字(剑指offer原57题—-题目一)</h4><ul><li><p>解题思路1：暴力解法，先依次遍历每个数字，遍历到某个数字时，固定这个数字。再依次判断数组中其余的n-1个数字与它的和是否等于target。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力解法O(n**2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumberWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[j]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>解题思路2：对第二重循环进行优化，第二重循环的目的是判断对于j &lt; i这个范围内，是否存在一个数字nums[j]使得target - nums[i] == nums[j]成立。因此，可以使用哈希表来统计数字nums[j]是否出现从而来优化，使得时间复杂度变成O(n)。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumberWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.count(target - nums[i])) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;target - nums[i], nums[i]&#125;;  <span class="comment">// hash.count(target - nums[i])就是判断nums[j]是否在j &lt; i的范围内出现！</span></span><br><span class="line">            hash.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="20-和为s的连续正数序列-剑指offer原57题—-题目二"><a href="#20-和为s的连续正数序列-剑指offer原57题—-题目二" class="headerlink" title="20.和为s的连续正数序列(剑指offer原57题—-题目二)"></a>20.和为s的连续正数序列(剑指offer原57题—-题目二)</h4><ul><li>原题：<strong>输入一个正数s,输出所有和为s的连续正数序列</strong>，序列中至少含有两个数。</li><li>解题思路：暴力方法是给出区间的起点i,再给出区间的终点j。利用求和公式计算出区间[i,j]中数字的和是否为s，时间复杂度是O(n<strong>2)。改进的方法是：假设区间[i,j]中数字的和是s，当区间左端点i向右移动到i1时，</strong>区间的右端点j也会向右移动到j1，如果右端点j向左移动到j2，则区间[i1,j2]中的数字之和一定是小于s的**。总结起来就是使用双指针算法，时间复杂度变成O(n)。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力方法：O(n**2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> sum)&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, s = <span class="number">1</span>; i &lt;= sum; i++)  <span class="comment">// s是当前序列的和</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span>(s &lt; sum) s += ++j;</span><br><span class="line">           <span class="keyword">if</span>(s == sum &amp;&amp; j - i + <span class="number">1</span> &gt; <span class="number">1</span>)&#123;  <span class="comment">// [i,j]中包含的元素个数是: j - i + 1</span></span><br><span class="line">               <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; line;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++) line.push_back(k);  <span class="comment">// line是一个一维数组，数组中存放的是区间[i,j]中和为s的数字</span></span><br><span class="line">               res.push_back(line);</span><br><span class="line">           &#125;</span><br><span class="line">           s -= i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="21-翻转单词顺序-剑指offer原58题—-题目一"><a href="#21-翻转单词顺序-剑指offer原58题—-题目一" class="headerlink" title="21.翻转单词顺序(剑指offer原58题—-题目一)"></a>21.翻转单词顺序(剑指offer原58题—-题目一)</h4><ul><li>原题：输入一个句子，翻转句子中单词的顺序，但每个单词内的字母顺序不变。</li><li>解题思路：先用双指针i和j，将整个句子的每个单词以字母为单位进行翻转；然后对句子的每个单词进行翻转。  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">string</span> reverseWords(<span class="keyword">string</span> s)&#123;</span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());  <span class="comment">// 等价于for(int i = 0, j = s.size() - 1; i &lt; j; i++, j--) swap(s[i], s[j]); 第一步首先对整个句子进行翻转</span></span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;  <span class="comment">// 对第一步中翻转后的每个单词进行翻转，下面是从一段字符串中提取出一个单词的操作！</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="built_in">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] != <span class="string">' '</span>) j++;</span><br><span class="line">            reverse(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + j);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="22-左旋转字符串-剑指offer原58题—-题目二"><a href="#22-左旋转字符串-剑指offer原58题—-题目二" class="headerlink" title="22.左旋转字符串(剑指offer原58题—-题目二)"></a>22.左旋转字符串(剑指offer原58题—-题目二)</h4><ul><li>原题是：将字符串中的前面的前n位移动到字符串的尾部。</li><li>解题思路：和上一题一样的思路，先对整个字符串进行翻转。然后将翻转后的结果分成两个部分：前str.size() - n个字符和倒数n个字符，然后分别对上面的两部分进行翻转即可。  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">string</span> leftRotateString(<span class="keyword">string</span> str, <span class="keyword">int</span> n)&#123;</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>() + str.<span class="built_in">size</span>() - n);</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>() + str.<span class="built_in">size</span>() - n, str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="23-数字序列中某一位的数字-剑指offer原44题"><a href="#23-数字序列中某一位的数字-剑指offer原44题" class="headerlink" title="23.数字序列中某一位的数字(剑指offer原44题)"></a>23.数字序列中某一位的数字(剑指offer原44题)</h4><ul><li>解题思路：<ul><li>1.确定是几位数（n - 10*1 - 90*2 - 900*3 - …）</li><li>2.确定是几位数的第几个数</li><li>3.确定那个数的第几位</li></ul></li><li>详细过程：首先要确定第n位对应的数字在什么范围内，也就是确定第n位对应的数字是几位数。因为一位数有10个，占10位，两位数有90个，占180位，三位数有900个，占2700位。假设输入的是第1000位，则第1000位对应的应该是一个三位数（因为1000-10-180 = 720 &lt; 2700）；然后确定第1000位对应的是哪个三位数上的某一位。因为经过上一步的分析可知，输入的第1000位出现在两位数之后的第720位，因为三位数每个数占3位，所以输入的第1000位对应的应该是第240个三位数中的某一位！由于三位数从100开始，所以第240个三位数是100 + 240 - 1 = 339；最后确定对应是339中的哪一位（因为720 / 3 = 240，所以应该对应339的最后一位9）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>, s = <span class="number">9</span>, base = <span class="number">1</span>;  <span class="comment">// i是几位数  s是几位数的个数  base是几位数的开始第一个数字</span></span><br><span class="line">        <span class="comment">// 确定n对应是几位数</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; i * s)&#123;</span><br><span class="line">            n -= i * s;</span><br><span class="line">            i++;</span><br><span class="line">            s *= <span class="number">10</span>;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定是几位数中的哪个数</span></span><br><span class="line">        <span class="keyword">int</span> number = base + (n + i - <span class="number">1</span>) / i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 确定那个数的第几位</span></span><br><span class="line">        <span class="keyword">int</span> r = n % i ? n % i : i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - r; j++) number /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="24-把数组排成最小的数-剑指offer原45题"><a href="#24-把数组排成最小的数-剑指offer原45题" class="headerlink" title="24.把数组排成最小的数(剑指offer原45题)"></a>24.把数组排成最小的数(剑指offer原45题)</h4><ul><li>解题思路：首先在数组中定义两个数字之间的小于&lt;关系：即a &lt; b等价于ab &lt; ba。然后将原始的输入数组按照定义的小于关系重新排序，一次拼接派好序后的数组中的数字即可。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> as = to_string(a), bs = to_string(b);</span><br><span class="line">        <span class="keyword">return</span> as + bs &lt; bs + as;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">printMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end(), cmp);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) res += to_string(x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="25-把数字翻译成字符串-剑指offer原46题"><a href="#25-把数字翻译成字符串-剑指offer原46题" class="headerlink" title="25.把数字翻译成字符串(剑指offer原46题)"></a>25.把数字翻译成字符串(剑指offer原46题)</h4><ul><li>解题思路：<strong>大部分计数的问题，可以看成是动态规划的问题</strong>。问题的关键是<strong>a.状态表示 b.状态如何计算 c.边界怎么定义</strong>。f(i)表示前i位数字一共有多少种翻译方式，f(i)<br>如何计算？如果将第i位数字单独翻译成一个字母，则f(i)可表示为前i-1位数字一共有多少种翻译方式；如果将第i位和第i-1位数字翻译成两个个字母，则f(i)可表示为前i-2为数字一共有多少种翻译方式。综合上述两种情况,f(i) = f(i-1) + f(i-2)。<strong>注意第二种情况：f(i-2)是将第i和第i-1位数字联合起来翻译成字母，因此必须有约束,范围是[10,25]之间</strong>。最后，考虑边界f(0) = 1。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTranslationCount</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n+<span class="number">1</span>);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>];   <span class="comment">// 第一种情况</span></span><br><span class="line">            <span class="keyword">int</span> t = (s[i<span class="number">-2</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + s[i<span class="number">-1</span>] - <span class="string">'0'</span>;  <span class="comment">// 第二种情况</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">25</span>) f[i] += f[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="26-礼物的最大价值-剑指offer原47题"><a href="#26-礼物的最大价值-剑指offer原47题" class="headerlink" title="26.礼物的最大价值(剑指offer原47题)"></a>26.礼物的最大价值(剑指offer原47题)</h4><ul><li>解题思路：<strong>经典的边界问题，还是要考虑三个问题，状态怎么表示；状态的计算问题；怎么定义边界</strong>。f[i,j]表示从左上角出发，到达当格子获得的最大价值。状态计算[i, j] = max(f[i-1, j],f[i, j-1]) + gifts[i,j]；边界f[i,0] = f[0, j] = 0。所要求的答案是f[n,m]。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                f[i][j] = max(f[i <span class="number">-1</span>][j], f[i][j<span class="number">-1</span>]) + grid[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="27-最长不含重复字符的子字符串-剑指offer原48题"><a href="#27-最长不含重复字符的子字符串-剑指offer原48题" class="headerlink" title="27.最长不含重复字符的子字符串(剑指offer原48题)"></a>27.最长不含重复字符的子字符串(剑指offer原48题)</h4><ul><li>解题思路：双指针i、j算法，当j指针每向后移动一位时，判断i到j中是否有重复字符，如果出现了重复字符，就将i指向的重复字符删除，同时i指针向后移动一次。当j移动到字符串末尾时，j-i+1的距离就是不含重复字符的子字符串。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthLongestSubString</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">            hash[s[j]]++;</span><br><span class="line">            <span class="keyword">while</span>(hash[s[j]] &gt; <span class="number">1</span>) hash[s[i++]]--;</span><br><span class="line">            res = max(res, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="28-丑数-剑指offer原49题-———求第n个丑数的值"><a href="#28-丑数-剑指offer原49题-———求第n个丑数的值" class="headerlink" title="28.丑数(剑指offer原49题)———求第n个丑数的值"></a>28.丑数(剑指offer原49题)———求第n个丑数的值</h4><ul><li>解题思路：丑数：一个数的质因子中只包含2 3 5的数！首先将1加入丑数集合中去，然后分别用三个i,j,k指针指向1.。其中i表示2，j表示3，k表示5；然后用1分别与i、j、k三个指针相乘，取相乘后所有结果中的最小值放在1的下一个位置。同时，将指针向后移动一个位置。<strong>当有多个相等的最小值出现时，需要将多个指针分别向后移动一个位置</strong>。依次循环下去，就可以找到整个丑数组成的集合了。（实际上是3路归并排序，将包含因子2的排好序丑数放入一个数组、包含因子3的排好序丑数放入一个数组、包含因子5的排好序丑数放入一个数组；<strong>前面的三个数组中，是不包含因子1</strong>。然后将三个数组分别除以数字2 数字3 数字5得到的结果仍然是一个丑数序列，将得到的3个丑数序列合并后进行判重处理，就得到了最终结果）  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">int</span> getUglyNumber(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; <span class="string">q(1, 1)</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(--n)&#123;  <span class="regexp">//</span> 循环n-<span class="number">1</span>次    <span class="keyword">while</span>(n--)&#123;&#125;是循环n次</span><br><span class="line">            <span class="keyword">int</span> t = min(<span class="string">q[i]</span> * <span class="number">2</span>, min(<span class="string">q[j]</span> * <span class="number">3</span>, <span class="string">q[k]</span> * <span class="number">5</span>));</span><br><span class="line">            q.push_back(t);</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">q[i]</span> * <span class="number">2</span> == t) i++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">q[j]</span> * <span class="number">3</span> == t) j++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">q[k]</span> * <span class="number">5</span> == t) k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="29-字符串中第一个只出现一次的字符-剑指offer原50题—-题目一"><a href="#29-字符串中第一个只出现一次的字符-剑指offer原50题—-题目一" class="headerlink" title="29.字符串中第一个只出现一次的字符(剑指offer原50题—-题目一)"></a>29.字符串中第一个只出现一次的字符(剑指offer原50题—-题目一)</h4><ul><li>解题思路：先定义一个hash表，统计每个字符出现多少次，然后从前往后遍历hash表，扫描到第一个值是1对应的key，也就是最终的结果  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) hash[c]++;  <span class="comment">// 统计字符串s中每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">char</span> res = <span class="string">'#'</span>;  <span class="comment">// 无解的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">            <span class="keyword">if</span>(hash[c] == <span class="number">1</span>)&#123;</span><br><span class="line">                res = c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="30-字符流中第一个只出现一次的字符-剑指offer原50题—-题目二"><a href="#30-字符流中第一个只出现一次的字符-剑指offer原50题—-题目二" class="headerlink" title="30.字符流中第一个只出现一次的字符(剑指offer原50题—-题目二)"></a>30.字符流中第一个只出现一次的字符(剑指offer原50题—-题目二)</h4><ul><li>解题思路：每次输入字符时，将输入的字符流中出现次数大于1的字符删除。使用队列的数据结构来存储插入的字符！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入字符到一个队列queue中</span></span><br><span class="line">    <span class="comment">// 利用hash表判断当前正在插入的字符是否出现在当前的队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(++hash[ch] &gt; <span class="number">1</span>)&#123;  <span class="comment">// 插入的字符已经出现在队列中</span></span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; hash[q.front()] &gt; <span class="number">1</span>) q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> q.push(ch); <span class="comment">// 插入的字符没有出现在队列中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstAppearingOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="31-数组中的逆序对-剑指offer原51题）"><a href="#31-数组中的逆序对-剑指offer原51题）" class="headerlink" title="31.数组中的逆序对(剑指offer原51题）"></a>31.数组中的逆序对(剑指offer原51题）</h4><ul><li>解题思路：暴力做法的时间复杂度是O(n**2)，考虑能否使用归并排序的方法来优化算法为O(nlogn)。首先分别对统计同时在左右两个子序列中一共有多少个逆序对（递归方法）；然后计算逆序对不在同一个子序列时，对第二个序列中的每一个数a[j]，计算第一个序列中一共有多少个数a[i]比a[j]要大。因此一共有r-i+1个数比a[j]]要大！最后的结果是上面三个部分的和。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = merge(nums, l, mid) + merge(nums, mid + <span class="number">1</span>, r);  <span class="comment">// 第一和第二部分</span></span><br><span class="line">        <span class="comment">// 第三个部分</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j]) temp.push_back(nums[i++]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp.push_back(nums[j++]);</span><br><span class="line">                res += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= mid) temp.push_back(nums[i++]);</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= r) temp.push_back(nums[j++]);</span><br><span class="line">            i = l;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : temp) nums[i++] = x;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">inversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="32-两个链表的第一个公共结点-剑指offer原52题）"><a href="#32-两个链表的第一个公共结点-剑指offer原52题）" class="headerlink" title="32.两个链表的第一个公共结点(剑指offer原52题）"></a>32.两个链表的第一个公共结点(剑指offer原52题）</h4><ul><li>思路：使用两个指针p和q，p指针指向第一个链表的头结点，q指针指向第二个链表的头结点。当p指针遍历到第一个链表的末尾时，接着回到第二链表的头结点位置；当q指针遍历到第二个链表的末尾时，接着回到第一链表的头结点位置。<strong>注意两个指针所走的总距离是相等的</strong>！当进行了多次循环后，两个指针一定会在某个结点处相遇，即公共结点。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">findFirstCommonNode</span><span class="params">(ListNode* headA, ListNode* headB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = headA, q = headB;</span><br><span class="line">        <span class="keyword">while</span>(p != q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p) p = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p = headB;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(q) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> q = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="33-二叉搜索树的后序遍历序列-剑指offer原33题"><a href="#33-二叉搜索树的后序遍历序列-剑指offer原33题" class="headerlink" title="33.二叉搜索树的后序遍历序列(剑指offer原33题)"></a>33.二叉搜索树的后序遍历序列(剑指offer原33题)</h4><ul><li>题目：给定一个数组，判断此数组是否是某二叉搜索树的后序遍历结果！</li><li>解题思路：先找出数组中的最后一个元素作为树根root，然后找到二叉搜索树的左子树的最后一个位置（左子树中的结点值均小于root，右子树的结点值均大于root）。接着找到二叉搜索树的右子树的最后一个位置。判断结点的值是否满足二叉搜索树的定义！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifySequenceOFBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span></span>&#123;</span><br><span class="line">        seq = sequence;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, seq.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> root = seq[r];</span><br><span class="line">        <span class="keyword">int</span> k = l;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; r &amp;&amp; seq[k] &lt; root) k++;  <span class="comment">// 二叉搜索树的左子树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; r; i++)&#123;  <span class="comment">// 判断二叉搜索树的右子树是否合法</span></span><br><span class="line">            <span class="keyword">if</span>(seq[i] &lt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(l, k<span class="number">-1</span>) &amp;&amp; dfs(k+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="34-二叉树中和为某一值的路径-剑指offer原34题"><a href="#34-二叉树中和为某一值的路径-剑指offer原34题" class="headerlink" title="34.二叉树中和为某一值的路径(剑指offer原34题)"></a>34.二叉树中和为某一值的路径(剑指offer原34题)</h4><ul><li>解题思路：直接遍历一遍二叉树，当遍历到叶节点时，判断从根节点到当前节点的路径上的节点值之和是否等于给定值。如果等于的话，就记录当前的路径。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findPath(TreeNode* root, <span class="keyword">int</span> sum)&#123;</span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;  <span class="comment">// 当前节点是空的，就不是叶子节点</span></span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="comment">// 如果当前节点的左右子树都是空的，则当前节点是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !sum) ans.push_back(path);</span><br><span class="line">        <span class="comment">// 递归处理左右子树</span></span><br><span class="line">        dfs(root-&gt;left, sum);</span><br><span class="line">        dfs(root-&gt;right, sum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="35-复杂链表的复制-剑指offer原35题"><a href="#35-复杂链表的复制-剑指offer原35题" class="headerlink" title="35.复杂链表的复制(剑指offer原35题)"></a>35.复杂链表的复制(剑指offer原35题)</h4><ul><li>解题思路：第一步将每个节点复制出来，然后将当前节点的next指针指向复制出来的节点；第二步将原先节点p的random指针指向第3个节点；那么，被复制出来的p节点是p-&gt;next，其random指针即p-&gt;next-&gt;random指向p-&gt;random-&gt;next节点。最后将复制出来的节点全部连接起来！  <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next, *random;</span><br><span class="line">    ListNode(int x): val(x), next(nullptr), random(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* copyRandomList(ListNode* head)&#123;</span><br><span class="line">        <span class="comment">// 第一步复制所有的节点，并将当前节点指向复制出来的节点</span></span><br><span class="line">        <span class="keyword">for</span>(auto p = head; p;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">auto</span> np = new ListNode(p-&gt;</span>val);  <span class="comment">// 复制出来的新节点</span></span><br><span class="line">            <span class="function"><span class="title">auto</span> next = p-&gt;</span><span class="function"><span class="title">next</span>;   // 备份一下p-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>next = np;   <span class="comment">// 复制出来的点接在当前节点的后面</span></span><br><span class="line">            <span class="function"><span class="title">np</span>-&gt;</span>next = next;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二步复制random指针</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(auto p = head; p; p = p-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next)&#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(p-&gt;</span>random)</span><br><span class="line">                <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">random</span> = p-&gt;</span><span class="function"><span class="title">random</span>-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第三步将所有复制出来的节点连接起来</span></span><br><span class="line">        auto dummy = new ListNode(-<span class="number">1</span>);</span><br><span class="line">        auto cur = dummy;   <span class="comment">// 当前新链表的尾节点</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(auto p = head; p; p = p-&gt;</span>next)&#123;</span><br><span class="line">            <span class="function"><span class="title">cur</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">cur</span> = cur-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">return</span> dummy-&gt;</span>next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="36-二叉搜索树与双向链表-剑指offer原36题"><a href="#36-二叉搜索树与双向链表-剑指offer原36题" class="headerlink" title="36.二叉搜索树与双向链表(剑指offer原36题)"></a>36.二叉搜索树与双向链表(剑指offer原36题)</h4><ul><li>解题思路：首先获取根节点；然后分别递归左右子树，左右子树分别返回一个首尾节点(即当前子树中最左边的节点和当前子树中最右边的节点)；接着将三部分拼接起来；最后将左子树的最左侧和右子树的最右侧节点返回就是最后的答案。  <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">using</span> namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* <span class="built_in">left</span>;</span><br><span class="line">    TreeNode* <span class="built_in">right</span>;</span><br><span class="line">    TreeNode(int x): val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* convert(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> nullptr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">auto</span> sides = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> sides.<span class="built_in">first</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;TreeNode*, TreeNode*&gt; dfs(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;<span class="built_in">left</span> &amp;&amp; !root-&gt;<span class="built_in">right</span>) <span class="keyword">return</span> &#123;root, root&#125;;  // 当前节点是叶子节点</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> &amp;&amp; root-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="built_in">auto</span> lsides = dfs(root-&gt;<span class="built_in">left</span>), rsides = dfs(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">            lsides.second-&gt;<span class="built_in">right</span> = root, root-&gt;<span class="built_in">left</span> = lsides.second;</span><br><span class="line">            root-&gt;<span class="built_in">right</span> = rsides.<span class="built_in">first</span>, rsides.<span class="built_in">first</span>-&gt;<span class="built_in">left</span> = root;</span><br><span class="line">            <span class="keyword">return</span> &#123;lsides.<span class="built_in">first</span>, rsides.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>)&#123;</span><br><span class="line">            <span class="built_in">auto</span> lsides = dfs(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">            lsides.second-&gt;<span class="built_in">right</span> = root, root-&gt;<span class="built_in">left</span> = lsides.second;</span><br><span class="line">            <span class="keyword">return</span> &#123;lsides.<span class="built_in">first</span>, root&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="built_in">auto</span> rsides = dfs(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">            root-&gt;<span class="built_in">right</span> = rsides.<span class="built_in">first</span>, rsides.<span class="built_in">first</span>-&gt;<span class="built_in">left</span> = root;</span><br><span class="line">            <span class="keyword">return</span> &#123;root, rsides.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="37-序列化二叉树-剑指offer原37题"><a href="#37-序列化二叉树-剑指offer原37题" class="headerlink" title="37.序列化二叉树(剑指offer原37题)"></a>37.序列化二叉树(剑指offer原37题)</h4><ul><li>题目：确保二叉树可以序列化为字符串；并且可以将此字符串反序列化为原始树结构。</li><li>解题思路：利用二叉树的前序遍历实现从二叉树到字符串的序列化操作；反序列化实现的是从字符串到二叉树的转换，注意将字符串类型的数字转成整数的方法！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        dfs_s(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历实现序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            res += <span class="string">"null "</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += to_string(root-&gt;val) + <span class="string">' '</span>;</span><br><span class="line">        dfs_s(root-&gt;left, res);</span><br><span class="line">        dfs_s(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs_d(data, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_d</span><span class="params">(<span class="built_in">string</span> data, <span class="keyword">int</span>&amp; u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == data.size()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> k = u;</span><br><span class="line">        <span class="keyword">while</span>(data[k] != <span class="string">' '</span>) k++;</span><br><span class="line">        <span class="keyword">if</span>(data[u] == <span class="string">'n'</span>)&#123; <span class="comment">// 'n'是null的开始字符</span></span><br><span class="line">            u = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = u; i &lt; k; i++) val = val * <span class="number">10</span> + data[i] - <span class="string">'0'</span>;  <span class="comment">// 将字符串整数"123"转换成整数123</span></span><br><span class="line">        u = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root-&gt;left = dfs_d(data, u);</span><br><span class="line">        root-&gt;right = dfs_d(data, u);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="38-数字排列—-（与剑指offer38题不同）"><a href="#38-数字排列—-（与剑指offer38题不同）" class="headerlink" title="38.数字排列—-（与剑指offer38题不同）"></a>38.数字排列—-（与剑指offer38题不同）</h4><ul><li>题目：输入一组数字(可能包含重复数字)，输出其所有的全排列</li><li>解题思路：先对输入的数字进行排序，然后开辟与输入一组数字相同长度的数组，接着从输入数字中按顺序取一个数字放在数组的任意一个位置上。<strong>接下来，取第二个数字放在数组中剩下空间的任意一个位置上，如果第二个数字与第一个数字值是相同的，则规定第二个数字只能放在第一个数字的后面的位置</strong>，依次将输入的数字放入数组中，直到数组的各位都已经占满为止。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permutation(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        path.resize(nums.size());   <span class="comment">// 开辟的数组空间大小</span></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">// 用一个二进制位来表示哪些位置是空的</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> u, <span class="keyword">int</span> start, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">        <span class="comment">// u:当前枚举的位置   start: 当前这个数应该从哪个位置开始枚举？（即上一个数的后一个位置开始枚举）</span></span><br><span class="line">        <span class="comment">// state: 存储的是状态，表示哪些数被用过</span></span><br><span class="line">        <span class="keyword">if</span>(u == nums.size())&#123;</span><br><span class="line">            ans.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!u || nums[u] != nums[u<span class="number">-1</span>]) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(state &gt;&gt; i &amp; <span class="number">1</span>))&#123;   <span class="comment">// state &gt;&gt; i &amp; 1：看一下state的二进制表示中第i位是否表示为1</span></span><br><span class="line">                path[i] = nums[u];</span><br><span class="line">                dfs(nums, u + <span class="number">1</span>, i + <span class="number">1</span>, state + (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="39-数组中出现次数超过一半的数字（寻找数组中的众数）-剑指offer原39题"><a href="#39-数组中出现次数超过一半的数字（寻找数组中的众数）-剑指offer原39题" class="headerlink" title="39.数组中出现次数超过一半的数字（寻找数组中的众数）(剑指offer原39题)"></a>39.数组中出现次数超过一半的数字（寻找数组中的众数）(剑指offer原39题)</h4><ul><li>解题思路：初始化一个计数变量count = 0，然后遍历数组中的每个元素，当val等于第一个元素时，count加1。接着遍历第二个元素，如果第二个元素的值与第一个元素的值相同时，则count加1；如果第二个元素的值与第一个元素的值不同时，count减1；最后遍历完整个数组后，最终结果存储在val变量中。<strong>摩尔投票法原理</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">moreThanHalfNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, val = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt) val = x, cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x == val) cnt++;</span><br><span class="line">                <span class="keyword">else</span> cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="40-最小的k个数-剑指offer原40题"><a href="#40-最小的k个数-剑指offer原40题" class="headerlink" title="40.最小的k个数(剑指offer原40题)"></a>40.最小的k个数(剑指offer原40题)</h4><ul><li>解题思路：维护一个大顶堆，当最小的k个数存放在大顶堆中。遍历输入数组中的每个元素，然后将每个元素与大顶堆中的堆顶元素进行比较，如果比堆顶元素小，就更新堆顶元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : input)</span><br><span class="line">        &#123;</span><br><span class="line">            heap.push(x);</span><br><span class="line">            <span class="keyword">if</span>(heap.size() &gt; k) heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(heap.size()) res.push_back(heap.top()), heap.pop();  <span class="comment">// heap存放的是从大到小的顺序</span></span><br><span class="line">        reverse(res.rbegin(), res.rend());  <span class="comment">// 翻转一下变成从小到大</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="41-数据流中的中位数-剑指offer原41题"><a href="#41-数据流中的中位数-剑指offer原41题" class="headerlink" title="41.数据流中的中位数(剑指offer原41题)"></a>41.数据流中的中位数(剑指offer原41题)</h4><ul><li>题目：如果从数据流中读出奇数个数值，则中位数就是所有数值排序后位于中间的数值；如果从数据流中读出偶数个数值，则中位数就是所有数值排序之后中间两个数的平均值。</li><li>解题思路：将当前所有的数维护成两个集合，第一个集合是一个小顶堆，存的是比较大的那一部分数；第二个集合是一个大顶堆，存的是比较小的那一部分数。<strong>可以发现，大顶堆的堆顶元素和小顶堆的堆顶元素实际就是输入数据流中间的两个数</strong>。规定，数据流中读出的是奇数个数值时，大顶堆比小顶堆中的元素多一个。如何维护这个结构？<strong>每次插入一个新的元素到大顶堆中，如果下面大顶堆的堆顶元素比上面小顶堆的堆顶元素的大（即逆序了），则交换；如果下面大顶堆中的元素太多了，就要直接转移当中的一个元素到小顶堆中</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; max_heap;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; min_heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        max_heap.push(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(min_heap.size() &amp;&amp; max_heap.top() &gt; min_heap.top())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> maxv = max_heap.top(), minv = min_heap.top();</span><br><span class="line">            max_heap.pop(), min_heap.pop();</span><br><span class="line">            max_heap.push(minv), min_heap.push(maxv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(max_heap.size() &gt; min_heap.size() + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            min_heap.push(max_heap.top());</span><br><span class="line">            max_heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(max_heap.size() + min_heap.size() &amp; <span class="number">1</span>) <span class="keyword">return</span> max_heap.top();   <span class="comment">// 数据流中是奇数个数值</span></span><br><span class="line">        <span class="keyword">return</span> (max_heap.top() + min_heap.top()) / <span class="number">2.0</span>;    <span class="comment">// 数据流中是偶数个数值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="42-连续子数组的最大和-剑指offer原42题"><a href="#42-连续子数组的最大和-剑指offer原42题" class="headerlink" title="42.连续子数组的最大和(剑指offer原42题)"></a>42.连续子数组的最大和(剑指offer原42题)</h4><ul><li>解题思路：s表示遍历到当前数x前一个位置为结尾的子数组的和最大值，s如何更新？当s &gt; 0时，s = s + x；当s &lt;= 0时，s = x；  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s &lt; <span class="number">0</span>) s = <span class="number">0</span>;</span><br><span class="line">            s += x;</span><br><span class="line">            res = max(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="43-从1到n整数中1出现的次数-剑指offer原43题"><a href="#43-从1到n整数中1出现的次数-剑指offer原43题" class="headerlink" title="43.从1到n整数中1出现的次数(剑指offer原43题)"></a>43.从1到n整数中1出现的次数(剑指offer原43题)</h4><ul><li>解题思路：假设输入13015，则万位上的1个数：10000-13015共3016个；千位上的1个数：1000-1999,11000-11999，一共有2000个；百位上的1个数：情况有很多种！十位上的1个数：情况有很多种！总结出的一般规律：输入的数字是abcedf，第一种情况：假设c位置上的数字是1，则ab位置上的取值范围是00到ab-1；def位置上的取值范围是000到999，则总方案数是ab*1000。第二种情况：最高位恰好取到ab时，分两种情况讨论。1.c位等于0时，就只有0个1；2.c位等于1时，则def的取值范围是0到def，一共有def+1种方案；3.c大于1时，def位置上的取值范围是000到999，则总方案数是1000！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfBetween1AndN</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; number;</span><br><span class="line">        <span class="comment">// 取出n中的每位数字放入number中</span></span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            number.push_back(n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = number.size() -  <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="number">0</span>, right = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = number.size() - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                left = left * <span class="number">10</span> + number[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                right = right * <span class="number">10</span> + number[j];</span><br><span class="line">                t *= <span class="number">10</span>;  <span class="comment">// t表示右边一共有多少位数</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res += left * t;</span><br><span class="line">            <span class="keyword">if</span>(number[i] == <span class="number">1</span>) res += right + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(number[i] &gt; <span class="number">1</span>) res += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="44-反转链表-剑指offer原24题"><a href="#44-反转链表-剑指offer原24题" class="headerlink" title="44.反转链表(剑指offer原24题)"></a>44.反转链表(剑指offer原24题)</h4><ul><li>解题思路：因为反转的是一个单向链表，所以无法直接遍历当前节点的前驱结点，因此利用一个变量pre记录当前节点的前驱结点。然后从头开始遍历给定的单向链表，直到遍历到空结点为止。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;   <span class="comment">// 记录当前结点的前驱结点</span></span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = cur-&gt;next;    <span class="comment">// 用next变量缓存cur-&gt;next，用来使得cur向后移动一位</span></span><br><span class="line">            cur-&gt;next = pre;                   <span class="comment">// 每次遍历时，将当前结点的next指针指向其前驱结点</span></span><br><span class="line">            pre = cur;        <span class="comment">// 将pre指针向后移动一位，此时pre指向cur</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;                 <span class="comment">// pre就是反转后链表的头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="45-合并两个排序的链表-剑指offer原25题"><a href="#45-合并两个排序的链表-剑指offer原25题" class="headerlink" title="45.合并两个排序的链表(剑指offer原25题)"></a>45.合并两个排序的链表(剑指offer原25题)</h4><ul><li>解题思路：<strong>归并排序的方法来实现即可！</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;   <span class="comment">// 因为往合并后的链表中添加元素时，是尾部插入的。因此，需要一个cur指针来记录当前链表的尾结点在哪。</span></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将两个链表中更长者中剩余的部分链接到已合并链表的末尾</span></span><br><span class="line">        <span class="keyword">if</span>(l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="46-树的子结构—-树的匹配-剑指offer原26题"><a href="#46-树的子结构—-树的匹配-剑指offer原26题" class="headerlink" title="46.树的子结构—-树的匹配(剑指offer原26题)"></a>46.树的子结构—-树的匹配(剑指offer原26题)</h4><ul><li>解题思路：类比字符串匹配的方法，从根结点root开始枚举，看一下树根root是否是子树的根节点；不是的话，判断树的左孩子结点是否是子树的树根结点；不是的话，判断树的右孩子结点是否是子树的树根结点。然后利用前序遍历树和子树即可。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasSubTree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot1 || !pRoot2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 前序遍历树pRoot1，然后与pRoot2结点进行对比</span></span><br><span class="line">        <span class="keyword">if</span>(isPart(pRoot1, pRoot2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasSubTree(pRoot1-&gt;left, pRoot2) || hasSubTree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPart</span><span class="params">(TreeNode* p1, TreeNode* p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p1 || p1-&gt;val != p2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isPart(p1-&gt;left, p2-&gt;left) &amp;&amp; isPart(p1-&gt;right, p2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="47-二叉树的镜像-剑指offer原27题"><a href="#47-二叉树的镜像-剑指offer原27题" class="headerlink" title="47.二叉树的镜像(剑指offer原27题)"></a>47.二叉树的镜像(剑指offer原27题)</h4><ul><li>解题思路：所有结点的左右孩子结点都交换了一下，遍历树中的所有结点，每次遍历完后，将每个结点的左右孩子结点交换一下就可以了。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mirror</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        mirror(root-&gt;left);</span><br><span class="line">        mirror(root-&gt;right);</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="48-对称的二叉树-剑指offer原28题"><a href="#48-对称的二叉树-剑指offer原28题" class="headerlink" title="48.对称的二叉树(剑指offer原28题)"></a>48.对称的二叉树(剑指offer原28题)</h4><ul><li>解题思路：除了根节点之外，其他的每个结点它的左边的结点和右边的结点是对应的！并且左边结点的左孩子和右边结点的右孩子是对称的，左边结点的右孩子和右边结点的左孩子是对称的！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> !p &amp;&amp; !q;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="49-顺时针打印矩阵-剑指offer原29题"><a href="#49-顺时针打印矩阵-剑指offer原29题" class="headerlink" title="49.顺时针打印矩阵(剑指offer原29题)"></a>49.顺时针打印矩阵(剑指offer原29题)</h4><ul><li>解题思路：顺时针定义四个方向：右 下 左 上；先按右的方向走，走到不能走为止；然后向下移动一个位置，按下的方向走，走到不能走为止；再向左移动一个位置，按左的方向走，走到不能走为止；最后向上移动一个位置，按上的方向走，走到不能走为止！直到总完n<em>m步就完成了！不能走的定义是：<em>*要么走出了边界，要么你已经走过了这个格子了</em></em>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>));   <span class="comment">// 二维数组记录每个格子是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;   <span class="comment">// 上 右 下 左</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">1</span>;  <span class="comment">// 起始方向是向右移动，故d = 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(matrix[x][y]);</span><br><span class="line">            st[x][y] = <span class="literal">true</span>;   <span class="comment">// 当前点被标记成已经访问</span></span><br><span class="line">            <span class="keyword">int</span> a = x + dx[d], b = y + dy[d];  <span class="comment">// 下一个点的坐标</span></span><br><span class="line">            <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || st[a][b])&#123;  <span class="comment">// 当前点已经出界或者被访问过</span></span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;   <span class="comment">// d向下移动</span></span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="50-包含min函数的栈-剑指offer原30题"><a href="#50-包含min函数的栈-剑指offer原30题" class="headerlink" title="50.包含min函数的栈(剑指offer原30题)"></a>50.包含min函数的栈(剑指offer原30题)</h4><ul><li>题目：设计一个支持push pop top等操作并可以在O(1)的时间复杂度内检索出最小元素的堆栈。</li><li>解题思路：利用一个辅助栈(<strong>单调栈</strong>)来操作。单调栈：即栈中的元素是单调的！维护一个单调栈，单调栈中的元素大小是单独变化的，当插入一个新的元素到主栈中时，将其与单调栈中的栈顶元素进行比较，当插入的元素比单调栈中的栈顶元素大，则不会将新的元素插入到主栈中；<strong>当插入的元素比单调栈中的栈顶元素小或者与单调栈中的栈顶元素相等时，则将新的元素插入到主栈中去</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk, min_stk;   <span class="comment">// stk是主栈  min_stk是单调栈</span></span><br><span class="line"></span><br><span class="line">    MinStack()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        stk.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min_stk.empty() || min_stk.top() &gt;= x) min_stk.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.top() == min_stk.top()) min_stk.pop();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="51-栈的压入与弹出序列-剑指offer原31题"><a href="#51-栈的压入与弹出序列-剑指offer原31题" class="headerlink" title="51.栈的压入与弹出序列(剑指offer原31题)"></a>51.栈的压入与弹出序列(剑指offer原31题)</h4><ul><li>解题思路：模拟一遍整个过程，每次往栈里面加一个元素，加完后判断当前栈顶元素是否是当前弹出序列的元素。如果是，则将栈顶元素弹出。当栈里面已经是空时，弹出序列就是合法的，否则就是不合法的!  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(popV.size() != pushV.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushV.size(); i++)&#123;</span><br><span class="line">            s.push(pushV[i]);</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() == popV[index])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="52-不分行从上往下打印二叉树-层序遍历-剑指offer原32题—-题目一"><a href="#52-不分行从上往下打印二叉树-层序遍历-剑指offer原32题—-题目一" class="headerlink" title="52.不分行从上往下打印二叉树[层序遍历](剑指offer原32题—-题目一)"></a>52.不分行从上往下打印二叉树[层序遍历](剑指offer原32题—-题目一)</h4><ul><li>解题思路：宽度优先搜索BFS，利用队列这个数据结构来实现  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printFromTopToBottom(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(q.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            res.push_back(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="53-分行从上往下打印二叉树-剑指offer原32题—-题目二"><a href="#53-分行从上往下打印二叉树-剑指offer原32题—-题目二" class="headerlink" title="53.分行从上往下打印二叉树(剑指offer原32题—-题目二)"></a>53.分行从上往下打印二叉树(剑指offer原32题—-题目二)</h4><ul><li>解题思路：在队列中增加一个null标记，表示当前层的结点已经全部遍历结束。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; printFromTopToBottom(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;   <span class="comment">// 辅助的数组表示每层中有多少个结点</span></span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();  <span class="comment">// 队首元素</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t)  <span class="comment">// t为空时，表示已经遍历完一层</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(level.empty()) <span class="keyword">break</span>;  <span class="comment">// level数组为空时，表示已经遍历完所有的结点，就直接返回</span></span><br><span class="line">                res.push_back(level);</span><br><span class="line">                level.clear();</span><br><span class="line">                q.push(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            level.push_back(t-&gt;val);  <span class="comment">// t不为空时，将当前的点加入到level中，进行扩展</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="54-之字形打印二叉树-剑指offer原32题—-题目三"><a href="#54-之字形打印二叉树-剑指offer原32题—-题目三" class="headerlink" title="54.之字形打印二叉树(剑指offer原32题—-题目三)"></a>54.之字形打印二叉树(剑指offer原32题—-题目三)</h4><ul><li>解题思路：在上一题的基础上增加一个布尔类型的变量zigzag，当zigzag为true时，表示从右到左打印；zigzag为false时，表示从左到右打印！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; printFromTopToBottom(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;   <span class="comment">// 辅助的数组表示每层中有多少个结点</span></span><br><span class="line">        <span class="keyword">bool</span> zigzag = <span class="literal">false</span>;   <span class="comment">// 表示从左到右打印</span></span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();  <span class="comment">// 队首元素</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t)  <span class="comment">// t为空时，表示已经遍历完一层</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(level.empty()) <span class="keyword">break</span>;  <span class="comment">// level数组为空时，表示已经遍历完所有的结点，就直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(zigzag) reverse(level.begin(), level.end());</span><br><span class="line">                res.push_back(level);</span><br><span class="line">                level.clear();</span><br><span class="line">                q.push(<span class="literal">nullptr</span>);</span><br><span class="line">                zigzag = !zigzag;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            level.push_back(t-&gt;val);  <span class="comment">// t不为空时，将当前的点加入到level中，进行扩展</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="55-机器人的运动范围-剑指offer原13题"><a href="#55-机器人的运动范围-剑指offer原13题" class="headerlink" title="55.机器人的运动范围(剑指offer原13题)"></a>55.机器人的运动范围(剑指offer原13题)</h4><ul><li>解题思路：一般考虑使用宽度优先遍历BFS，不建议使用深度优先遍历DFS。因为深度优先遍历在数据范围比较大时，可能会出现栈溢出！从(0,0)点开始遍历，每次将<strong>符合要求</strong>的格子加入到队列中去。最后一共遍历完多少个合法的格子，就是我们最终的结果。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 算出一个数字的各个位置上的数字之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_single_sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            s += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 算出一个格子中的各个位置上数字之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get_single_sum(p.first) + get_single_sum(p.second);    <span class="comment">// p.first是x坐标   p.second是y坐标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingcount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!rows || !cols) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st(rows, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (cols, <span class="literal">false</span>));   <span class="comment">// 全部初始化成false，记录每个格子是否已经被访问</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);  <span class="comment">// 初始坐标初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;    <span class="comment">// 顺时针来记忆 上 右 下 左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(get_sum(t) &gt; threshold || st[t.first][t.second]) <span class="keyword">continue</span>;</span><br><span class="line">            res++;</span><br><span class="line">            st[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols)&#123;</span><br><span class="line">                    q.push(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="56-剪绳子-剑指offer原14题"><a href="#56-剪绳子-剑指offer原14题" class="headerlink" title="56.剪绳子(剑指offer原14题)"></a>56.剪绳子(剑指offer原14题)</h4><ul><li>题目：给定一个正整数，将此整数划分成若干个更小的正整数的和<br><strong>使得划分出来的若干个正整数的乘积最大</strong></li><li>解题思路：目标：假设输入的正整数是N，拆分成尽可能多的3！。分下面几种情况：1.如果N % 3 == 0，则拆分成若干个3；2.如果N % 3 == 1，则先将N拆分成两个2，剩下的全部拆分成3；3.如果N % 3 == 2，则先将N拆分成一个2，剩下的全部拆分成3；</li><li>证明上面的三种情况：N &gt; 0，N = n1 + n2 + n3 + …+ nk 1.假设ni &gt;= 5，3 * (ni - 3) &gt;= ni(即3*ni-9 &gt;= ni得到2ni &gt;= 9)是否成立？2.ni = 4， 4 = 2 * 2。<strong>由前面的1和2得到拆分出来的数字一定不包含4和大于等于5的数字</strong>；因此可知所有拆分出来的ni不是2就是3。接下来证明拆分出来的数字中，最多只有两个2（因为2*2*2 &lt; 3*3）。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">1</span>) res *= <span class="number">4</span>, n -= <span class="number">4</span>;  <span class="comment">// 拆成出来两个2</span></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">2</span>) res *= <span class="number">2</span>, n -= <span class="number">2</span>;  <span class="comment">// 拆出来一个2</span></span><br><span class="line">        <span class="keyword">while</span>(n) res *= <span class="number">3</span>, n -= <span class="number">3</span>;    <span class="comment">// 拆出来全部都是3</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="57-二进制中1的个数-剑指offer原15题"><a href="#57-二进制中1的个数-剑指offer原15题" class="headerlink" title="57.二进制中1的个数(剑指offer原15题)"></a>57.二进制中1的个数(剑指offer原15题)</h4><ul><li>解题思路：s += n &amp; 1是先统计n中个位上是数字1的个数，n&gt;&gt;1则是统计完n中个位的结果后，移除n的个位上的数字来进行更新。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOf1</span><span class="params">(<span class="keyword">int</span> _n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> n = _n;  <span class="comment">// 将有符号数转换成无符号数，为了下面的循环</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            s += n &amp; <span class="number">1</span>;  <span class="comment">// 每次将n的个位取出来，判断是否是1，是1的话就s++</span></span><br><span class="line">            n &gt;&gt; <span class="number">1</span>;  <span class="comment">// 然后将n的个位移除，即n右移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="58-数值的整数次方-剑指offer原16题"><a href="#58-数值的整数次方-剑指offer原16题" class="headerlink" title="58.数值的整数次方(剑指offer原16题)"></a>58.数值的整数次方(剑指offer原16题)</h4><ul><li>解题思路：注意处理次方是负数的情况即可！  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span>(<span class="params"><span class="keyword">double</span> <span class="keyword">base</span>, <span class="keyword">int</span> exponent</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; abs(exponent); i++)&#123;</span><br><span class="line">            res *= <span class="keyword">base</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>) res = <span class="number">1</span> / res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="59-在O-1-的时间复杂度内删除链表结点（剑指offer原18题—题目一）"><a href="#59-在O-1-的时间复杂度内删除链表结点（剑指offer原18题—题目一）" class="headerlink" title="59.在O(1)的时间复杂度内删除链表结点（剑指offer原18题—题目一）"></a>59.在O(1)的时间复杂度内删除链表结点（剑指offer原18题—题目一）</h4><ul><li>解题思路：此题不能使用常规方法！因为要删除的结点不是链表的最后一个结点，所以下一个结点一定不是空结点。删除的方法是：<strong>用下一个结点的值去覆盖当前结点的值，然后将下一个结点的值删掉</strong>。这种方法就不需要用到前驱结点了。  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(int x): val(x), next(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void deleteNode(ListNode* <span class="keyword">node</span><span class="title">)&#123;</span></span><br><span class="line"><span class="title">        node-</span>&gt;val = <span class="keyword">node</span><span class="title">-&gt;next-</span>&gt;val;</span><br><span class="line">        <span class="keyword">node</span><span class="title">-&gt;next</span> = <span class="keyword">node</span><span class="title">-&gt;next-</span>&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="60-删除链表中重复的结点（剑指offer原18题—题目二）"><a href="#60-删除链表中重复的结点（剑指offer原18题—题目二）" class="headerlink" title="60.删除链表中重复的结点（剑指offer原18题—题目二）"></a>60.删除链表中重复的结点（剑指offer原18题—题目二）</h4><ul><li>解题思路：<strong>建议凡是可能会把头结点删掉的链表问题，一般来说都会增加一个虚拟头结点来简化代码</strong>。使用两个指针，第一个指针p指向上一次保留的结点的最后一个位置，q指向的是下一段的第一个结点，q用来扫描下一段的所有结点。  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* <span class="keyword">next</span>;</span><br><span class="line">    ListNode(int x): val(x), <span class="keyword">next</span>(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)&#123;</span><br><span class="line">        auto dummy = new ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy-&gt;<span class="keyword">next</span> = head;</span><br><span class="line"></span><br><span class="line">        auto p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;<span class="keyword">next</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            auto q = p-&gt;<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">while</span>(q &amp;&amp; p-&gt;<span class="keyword">next</span>-&gt;val == q-&gt;val)&#123;</span><br><span class="line">                q = q-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            if(p-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span> == q) p = p-&gt;<span class="keyword">next</span>;   <span class="regexp">//</span> 下一段的长度是<span class="number">1</span>，没有重复结点，不用删</span><br><span class="line">            else p-&gt;<span class="keyword">next</span> = q;   <span class="regexp">//</span> 下一段的长度超过<span class="number">1</span>，则删除重复结点</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="61-正则表达式的匹配（剑指offer原19题）"><a href="#61-正则表达式的匹配（剑指offer原19题）" class="headerlink" title="61.正则表达式的匹配（剑指offer原19题）"></a>61.正则表达式的匹配（剑指offer原19题）</h4><ul><li>题目：实现一个函数用来匹配包括.和*的正则表达式。字符.表示任意一个字符；字符*表示它前面的字符可以出现任意次（含0次）。</li><li>解题思路：<strong>动态规划问题</strong>。状态表示f[i][j]:s[i,…]和p[j,…]是相匹配的；状态转移：情况1：如果p[j]是正常字符，则f[i][j] = s[i] == p[j] &amp;&amp; f[i + 1][j + 1]；情况2：p[j]是.，f[i][j] = f[i + 1][j + 1]；情况3：p[j + 1] = *，*表示的字符是0次或*表示的字符匹配1次，则f[i][j] = f[i][j + 2] || f[i + 1][j]；边界问题：f[n][m] = true  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f;</span><br><span class="line">    <span class="built_in">string</span> s, p;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">inMatch</span><span class="params">(<span class="built_in">string</span> _s, <span class="built_in">string</span> _p)</span></span>&#123;</span><br><span class="line">        s = _s, p = _p;</span><br><span class="line">        n = s.size(), m = p.size();</span><br><span class="line">        f = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">        <span class="keyword">if</span>(y == m)</span><br><span class="line">            <span class="keyword">return</span> f[x][y] = x == n;</span><br><span class="line">        <span class="keyword">bool</span> first_match = x &lt; n &amp;&amp; (p[y] == <span class="string">'.'</span> || s[x] == p[y]);  <span class="comment">// 情况1和情况2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(y + <span class="number">1</span> &lt; m &amp;&amp; p[y + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;  <span class="comment">// 情况3</span></span><br><span class="line">            f[x][y] = dp(x, y + <span class="number">2</span>) || dp(x + <span class="number">1</span>, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[x][y] = first_match &amp;&amp; dp(x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="62-表示数值的字符串（剑指offer原20题）"><a href="#62-表示数值的字符串（剑指offer原20题）" class="headerlink" title="62.表示数值的字符串（剑指offer原20题）"></a>62.表示数值的字符串（剑指offer原20题）</h4><ul><li>解题思路：分各种情况讨论  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    bool isNumber(string s)&#123;</span><br><span class="line">        int i = <span class="number">0</span>, j = s.size();</span><br><span class="line">        /<span class="regexp">/ 删除字符串s中的前后空格</span></span><br><span class="line"><span class="regexp">        while(i &lt;= j &amp;&amp; s[i] == ' ') i++;</span></span><br><span class="line"><span class="regexp">        while(i &lt;= j &amp;&amp; s[j] == ' ') j--;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        if(i &gt; j) return false;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        s = s.substr(i, j - i + 1);</span></span><br><span class="line"><span class="regexp">        if(s[0] == '+' || s[0] == '-') s = s.substr(1);</span></span><br><span class="line"><span class="regexp">        if(s.empty() || (s[0] == '.' &amp;&amp; s.size() == 1)) return false;  /</span><span class="regexp">/ + - .</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        int dot = 0, e = 0;   /</span><span class="regexp">/ 统计有多少个.和e</span></span><br><span class="line"><span class="regexp">        for(int i = 0; i &lt; s.size(); i++)&#123;</span></span><br><span class="line"><span class="regexp">            if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9');</span></span><br><span class="line"><span class="regexp">            else if(s[i] == '.')&#123;</span></span><br><span class="line"><span class="regexp">                dot++;</span></span><br><span class="line"><span class="regexp">                if(dot &gt; 1 || e) return false;  /</span><span class="regexp">/ 3434.23232.4343, 23232e23232.2323</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            else if(s[i] == 'e' || s[i] == 'E')&#123;</span></span><br><span class="line"><span class="regexp">                e++;</span></span><br><span class="line"><span class="regexp">                if(!i || i + 1 == s.size() || e &gt; 1 || s[i - 1] == '.' &amp;&amp; i == 1) return false; /</span><span class="regexp">/ e1223233, 11232e, 1212e32323e</span></span><br><span class="line"><span class="regexp">                if(s[i + 1] == '+' || s[i + 1] == '-')&#123;</span></span><br><span class="line"><span class="regexp">                    if(i + 2 == s.size()) return false;   /</span><span class="regexp">/ 12341e+</span></span><br><span class="line"><span class="regexp">                    i++;</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            else return false;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        return true;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="63-调整数组顺序使奇数位于偶数前面（剑指offer原21题）"><a href="#63-调整数组顺序使奇数位于偶数前面（剑指offer原21题）" class="headerlink" title="63.调整数组顺序使奇数位于偶数前面（剑指offer原21题）"></a>63.调整数组顺序使奇数位于偶数前面（剑指offer原21题）</h4><ul><li>题目：输入一个数组，实现数组中数字的顺序，使得所有的奇数位于数组的前半部分；所有的偶数位于后半部分。</li><li>解题思路：使用双指针，一个指针从前往后，另一个指针从后往前。保证第一个指针前面全部是奇数，第二个指针前面全部是偶数。  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">class</span> Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">        int <span class="keyword">first</span> = <span class="number">0</span>, <span class="keyword">second</span> = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">first</span> &lt;= <span class="keyword">second</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">first</span> &lt;= <span class="keyword">second</span> &amp;&amp; nums[<span class="keyword">first</span>] % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">first</span>++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">first</span> &lt;= <span class="keyword">second</span> &amp;&amp; nums[<span class="keyword">second</span>] % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">second</span><span class="comment">--;</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">first</span> &lt; <span class="keyword">second</span>) swap(nums[<span class="keyword">first</span>], nums[<span class="keyword">second</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="64-链表中倒数第k个节点（剑指offer原22题）"><a href="#64-链表中倒数第k个节点（剑指offer原22题）" class="headerlink" title="64.链表中倒数第k个节点（剑指offer原22题）"></a>64.链表中倒数第k个节点（剑指offer原22题）</h4><ul><li>解题思路：由于单链表不能从后往前遍历的，只能从前往后遍历。因此首先求出整个链表的长度n，求倒数第k个节点相当于求正序的n-k+1个节点，然后从前往后遍历到n-k+1个节点就可以了。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">findKthToTail</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next) n++;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k; i++) p = p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="65-链表中环的入口节点（剑指offer原23题）"><a href="#65-链表中环的入口节点（剑指offer原23题）" class="headerlink" title="65.链表中环的入口节点（剑指offer原23题）"></a>65.链表中环的入口节点（剑指offer原23题）</h4><ul><li>解题思路：<strong>使用快慢指针算法，用两个指针first和second分别从起点开始走，first每次走一步，second每次走两步。如果过程中second走到null，则说明不存在环；否则当first和second相遇后，让first返回起点，second待在原地不动，然后两个指针每次分别走一步，当相遇时，相遇点就是环的入口</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">entryNodeOfLoop</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i = head, j = head; <span class="comment">// i是慢指针，每次走一步;j是快指针，每次走两步</span></span><br><span class="line">        <span class="keyword">while</span>(i &amp;&amp; j)&#123;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">            j = j-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(j) j = j-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;  <span class="comment">// i和j相遇了</span></span><br><span class="line">                i = head;  <span class="comment">// 慢指针i回到起点</span></span><br><span class="line">                <span class="keyword">while</span>(i != j)&#123; <span class="comment">// 慢指针和快指针同时向后移动一个位置</span></span><br><span class="line">                    i = i-&gt;next;</span><br><span class="line">                    j = j-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> i;   <span class="comment">// 环入口的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 无环存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="66-找出数组中重复的数字（剑指offer原3题—-题目一）"><a href="#66-找出数组中重复的数字（剑指offer原3题—-题目一）" class="headerlink" title="66.找出数组中重复的数字（剑指offer原3题—-题目一）"></a>66.找出数组中重复的数字（剑指offer原3题—-题目一）</h4><ul><li>解题思路：从前往后遍历整个数组中的每个元素，如果元素的取值不在0到n-1范围内，就直接返回-1；如果元素的取值在0到n-1范围内时，检查数组下标是取值为该元素时的数组位置上存储的是哪个数字；如果存储的数字与其在数组中对应的下标相等，则找出了重复的数字，否则将两个位置上的数字进行交换，重复此步骤，直到存储的数字与其在数组中对应的下标相等为止。  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int duplicateInArray(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(auto x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; nums.<span class="built_in">size</span>(); <span class="built_in">i</span>++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">i</span> != nums[<span class="built_in">i</span>] &amp;&amp; nums[nums[<span class="built_in">i</span>]] != nums[<span class="built_in">i</span>]) swap(nums[<span class="built_in">i</span>], nums[nums[<span class="built_in">i</span>]]);</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">i</span>] != <span class="built_in">i</span> &amp;&amp; nums[nums[<span class="built_in">i</span>]] == nums[<span class="built_in">i</span>]) <span class="keyword">return</span> nums[<span class="built_in">i</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="67-不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）"><a href="#67-不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）" class="headerlink" title="67.不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）"></a>67.不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）</h4><ul><li>解题思路：<strong>根据抽屉原理</strong>，至少有2个数字会重复！利用递归的思想，将这个数组一分为二，分别计算左右子数组两边的长度和元素的个数，至少有一边元素的个数会大于子数组的长度。递归上面的过程即可！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duplicateInArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;  <span class="comment">// [l, mid], [mid + 1, r]</span></span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;  <span class="comment">// 统计元素的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) s += x &gt;= l &amp;&amp; x &lt;= mid;</span><br><span class="line">            <span class="keyword">if</span>(s &gt; mid - l + <span class="number">1</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="68-二维数组中的查找（剑指offer原4题）"><a href="#68-二维数组中的查找（剑指offer原4题）" class="headerlink" title="68.二维数组中的查找（剑指offer原4题）"></a>68.二维数组中的查找（剑指offer原4题）</h4><ul><li>解题思路：从二维数组右上角的位置开始查找，如果要查找的目标数字比右上角的数字要大，则目标数字出现在二维数组的右下角位置；如果要查找的目标数字比右上角的数字要小，则目标数字出现在二维数组的左上角位置。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty() || <span class="built_in">array</span>[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">array</span>[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="built_in">array</span>.size() &amp;&amp; j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &gt; target) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="69-替换空格（剑指offer原5题）"><a href="#69-替换空格（剑指offer原5题）" class="headerlink" title="69.替换空格（剑指offer原5题）"></a>69.替换空格（剑指offer原5题）</h4><ul><li>解题思路：开一个新的字符串，遍历原始的字符串，如果遇到空格字符，就将20%存储在新字符串中；否则，直接存储在新字符串中。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpaces</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : str)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="string">' '</span>)</span><br><span class="line">                res += <span class="string">"20%"</span>;</span><br><span class="line">            <span class="keyword">else</span> res += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="70-从尾到头打印链表（剑指offer原6题）"><a href="#70-从尾到头打印链表（剑指offer原6题）" class="headerlink" title="70.从尾到头打印链表（剑指offer原6题）"></a>70.从尾到头打印链表（剑指offer原6题）</h4><ul><li>解题思路：先将整个链表遍历一遍，然后将整个链表翻转一下即可。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListReversingly(ListNode* head)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res.rbegin(), res.rend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="71-重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）"><a href="#71-重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）" class="headerlink" title="71.重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）"></a>71.重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）</h4><ul><li>解题思路：首先，根据前序遍历确定当前区间的根节点是哪个；然后，根据已经确定的根节点，从中序遍历中找到根节点的位置在哪，从而确定二叉树的左右子树中分别包含的数字；最后，在已经确定的左右子树中递归执行前面的两个步骤，即可重建二叉树。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;   <span class="comment">// 开一个hash表，记录每个节点在数组中的位置</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder, inorder;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; _preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; _inorder)</span></span>&#123;</span><br><span class="line">        preorder = _preorder, inorder = _inorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); i++)&#123;</span><br><span class="line">            hash[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, preorder.size() - <span class="number">1</span>, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl &gt; pr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(preorder[pl]);</span><br><span class="line">        <span class="keyword">int</span> k = hash[inorder[root-&gt;val]];</span><br><span class="line">        <span class="keyword">auto</span> left = dfs(pl + <span class="number">1</span>, pl + <span class="number">1</span> + k - il - <span class="number">1</span>, il, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> right = dfs(pl + k - il + <span class="number">1</span>, pr, k + <span class="number">1</span>, ir);</span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="72-二叉树的下一个节点（剑指offer原8题）"><a href="#72-二叉树的下一个节点（剑指offer原8题）" class="headerlink" title="72.二叉树的下一个节点（剑指offer原8题）"></a>72.二叉树的下一个节点（剑指offer原8题）</h4><ul><li>题目：给定二叉树中的一个节点，找出<strong>中序遍历序列</strong>的下一个节点</li><li>解题思路：分情况进行讨论，情况1：如果给定的节点是存在右子树的，则下一个节点是右子树中最左边的节点；情况2：如果给定的节点是不存在右子树的，又分两种情况讨论：a.如果给定的节点存在父节点，并且给定的节点是父节点的左儿子的话，则下一个节点是给定节点的父节点；b.如果给定的节点存在父节点，并且给定的节点是父节点的右儿子的话，此时沿着父节点向上找，直到找到第一个节点是当前父节点的左儿子时停止，返回父节点。  <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* inorderSuccessor(TreeNode* p)&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span>right)&#123;  <span class="comment">// 情况1</span></span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">left</span>) p = p-&gt;</span>left;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况2</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">father</span> &amp;&amp; p == p-&gt;</span><span class="function"><span class="title">father</span>-&gt;</span><span class="function"><span class="title">right</span>) p = p-&gt;</span>father;</span><br><span class="line">        <span class="function"><span class="title">return</span> p-&gt;</span>father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="73-用两个栈实现一个队列（剑指offer原9题）"><a href="#73-用两个栈实现一个队列（剑指offer原9题）" class="headerlink" title="73.用两个栈实现一个队列（剑指offer原9题）"></a>73.用两个栈实现一个队列（剑指offer原9题）</h4><ul><li>解题思路：先将元素依次压入栈1中，然后逐个弹出栈1中的元素，将每个元素依次压入栈2中。此时，<strong>栈2中的栈顶元素就是栈1中的栈底元素</strong>，再依次弹出栈2中的元素时，就实现了队列的先进先出功能（最先进入栈1中的元素，最先从栈2中弹出）。  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stk, cache;</span><br><span class="line"></span><br><span class="line">    MyQueue()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        stk.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">copy</span>(stack&lt;<span class="keyword">int</span>&gt;&amp; a, stack&lt;<span class="keyword">int</span>&gt;&amp; b)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a.<span class="keyword">size</span>())&#123;</span><br><span class="line">            b.<span class="keyword">push</span>(a.top());</span><br><span class="line">            a.<span class="keyword">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">pop</span>()&#123;</span><br><span class="line">        <span class="keyword">copy</span>(stk, cache);</span><br><span class="line">        <span class="keyword">int</span> res = cache.top();</span><br><span class="line">        cache.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">copy</span>(cache, stk);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> peak()&#123;</span><br><span class="line">        <span class="keyword">copy</span>(stk, cache);</span><br><span class="line">        <span class="keyword">int</span> res = cache.top();</span><br><span class="line">        <span class="keyword">copy</span>(cache, stk);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty()&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="74-斐波那契数列数列（剑指offer原10题）"><a href="#74-斐波那契数列数列（剑指offer原10题）" class="headerlink" title="74.斐波那契数列数列（剑指offer原10题）"></a>74.斐波那契数列数列（剑指offer原10题）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = a + b;</span><br><span class="line">            a = b, b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="75-旋转数组的最小数字（剑指offer原11题）"><a href="#75-旋转数组的最小数字（剑指offer原11题）" class="headerlink" title="75.旋转数组的最小数字（剑指offer原11题）"></a>75.旋转数组的最小数字（剑指offer原11题）</h4><ul><li>解题思路：利用<strong>画图法</strong>来解决。输入数组是0 1 2 2 2 2 3 4 5,则旋转后的数组是2 2 3 4 5 0 1 2 2。将旋转数组分成两部分2 2 3 4 5和0 1 2 2，两部分是单调的增加。首先将后半部分相同值删除，然后观察剩下的结果可知，所有的元素都比前半部分的第一个元素小。前半部分中后面的值都大于或等于第一个元素。<strong>下面就可以使用二分法，找出后半部分中第一个比前半部分第一个元素小的那个数字，就是我们要找的最小数字</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span> &amp;&amp; nums[n] == nums[<span class="number">0</span>]) n--;  <span class="comment">// 去掉后半部分相等的数值</span></span><br><span class="line">        <span class="keyword">if</span>(nums[n] &gt;= nums[<span class="number">0</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="76-矩阵中的路径（剑指offer原12题）"><a href="#76-矩阵中的路径（剑指offer原12题）" class="headerlink" title="76.矩阵中的路径（剑指offer原12题）"></a>76.矩阵中的路径（剑指offer原12题）</h4><ul><li>解题思路：先枚举所有起点，然后枚举方向。直到走到不能走为止，这样就得到所有的路径。  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPath(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;char&gt;&gt;&amp; <span class="keyword">matrix</span>, <span class="keyword">string</span> str)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">matrix</span>.<span class="keyword">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(<span class="keyword">matrix</span>, str, <span class="number">0</span>, i, j))  <span class="comment">// 枚举所有起点i, j，从字符串str第0个字符串开始枚举</span></span><br><span class="line">                    <span class="keyword">return</span> true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool dfs(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;char&gt;&gt;&amp; <span class="keyword">matrix</span>, <span class="keyword">string</span>&amp; str, <span class="keyword">int</span> u, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="comment">// 当前字符串str中的第几个字符u，x和y是当前路径的坐标</span></span><br><span class="line">        <span class="keyword">if</span>(u == str.<span class="keyword">size</span>()) <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">matrix</span>[x][y] != str[u]) <span class="keyword">return</span> false;</span><br><span class="line">        <span class="comment">// 枚举四个方向</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        char t = <span class="keyword">matrix</span>[x][y];  <span class="comment">// 已经访问过的字符，不能重新访问</span></span><br><span class="line">        <span class="keyword">matrix</span>[x][y] = <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = x + dx[i], b = y + dx[i];</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="keyword">matrix</span>.<span class="keyword">size</span>() &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; <span class="keyword">matrix</span>[a].<span class="keyword">size</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(<span class="keyword">matrix</span>, str, u + <span class="number">1</span>, a, b)) <span class="keyword">return</span> true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">matrix</span>[x][y] = t;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-滑动窗口的最大值（剑指offer原59题）&quot;&gt;&lt;a href=&quot;#1-滑动窗口的最大值（剑指offer原59题）&quot; class=&quot;headerlink&quot; title=&quot;1.滑动窗口的最大值（剑指offer原59题）&quot;&gt;&lt;/a&gt;1.滑动窗口的最大值（剑指offe
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://cdlwhm1217096231.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="https://cdlwhm1217096231.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>C++中的基本变量类型介绍</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的基本变量类型介绍/</id>
    <published>2019-08-09T08:11:06.000Z</published>
    <updated>2019-08-09T08:19:07.447Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-cpp变量类型"><a href="#1-cpp变量类型" class="headerlink" title="1.cpp变量类型"></a>1.cpp变量类型</h3><ul><li>变量实际上是存储空间的名称，cpp中每个变量都有指定的类型，类型决定变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可以作用在变量上。</li><li>变量名可以是字母 数字 下划线组成，必须以字母或下划线开头。区分大小写</li><li>几种基本的变量类型：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni0xNjBmODg4YzdlMDJiNGZjLnBuZw" alt="基本的变量类型.png"><h3 id="2-cpp中的变量定义"><a href="#2-cpp中的变量定义" class="headerlink" title="2.cpp中的变量定义"></a>2.cpp中的变量定义</h3></li><li><p>变量定义就是<strong>告诉编译器在何处创建变量的存储，以及如何创建变量的存储</strong>。变量的定义指定一个数据类型，并包含该类型的一个或多个变量的列表，例如：</p>  <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：<span class="keyword">type</span> variable_list;</span><br></pre></td></tr></table></figure></li><li><p>type必须是基本数据类型或用户自定义的数据类型(如 类)，variable_list可以由一个或多个标识符名称组成，<strong>多个标识符之间用逗号分隔</strong>，例如：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, k;  <span class="comment">// 声明并定义了变量i, j, k,指示编译器创建类型为int的名为i,j,k的变量</span></span><br><span class="line"><span class="keyword">char</span> c, d, e;</span><br><span class="line"><span class="keyword">float</span> f, ss;</span><br><span class="line"><span class="keyword">double</span> d;</span><br></pre></td></tr></table></figure></li><li><p>变量可以在声明的时候被初始化，初始化器由一个等号后跟一个常量表达式组成,例如：</p>  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式:  type variable_name = <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> d = <span class="number">3</span>, f = <span class="number">6</span>;  <span class="comment">// d 和 f 的声明</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">3</span>, f = <span class="number">5</span>;  <span class="comment">// 定义并初始化 d 和 f</span></span><br><span class="line"><span class="keyword">byte</span> z = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">char</span> x = <span class="string">'x'</span>;</span><br></pre></td></tr></table></figure></li><li><p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的</p><h3 id="3-cpp中的变量声明"><a href="#3-cpp中的变量声明" class="headerlink" title="3.cpp中的变量声明"></a>3.cpp中的变量声明</h3></li><li>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。<strong>变量声明只在编译时有它的意义</strong>，在程序连接时编译器需要实际的变量声明。</li><li><p>当使用多个文件且<strong>只在其中一个文件中定义变量时</strong>（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 变量的定义</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="comment">// 实际初始化</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量的声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 变量的定义</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="comment">// 实际初始化</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="keyword">int</span> i = func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-cpp中的左值和右值"><a href="#4-cpp中的左值和右值" class="headerlink" title="4.cpp中的左值和右值"></a>4.cpp中的左值和右值</h3><ul><li>cpp中的两种类型的表达式：<ul><li>左值：<strong>指向内存位置的表达式被称为左值（lvalue）表达式</strong>。左值可以出现在赋值号的左边或右边。</li><li>右值：<strong>存储在内存中某些地址的数值</strong>。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li></ul></li><li>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int g = <span class="number">20</span>;</span><br><span class="line"><span class="number">10</span> = <span class="number">20</span>;  报错！</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-变量的类型转换"><a href="#5-变量的类型转换" class="headerlink" title="5.变量的类型转换"></a>5.变量的类型转换</h3><ul><li><p>变量的类型间是可以互相转换的，转换又分为自动转换和强制转换。</p><ul><li><p>自动转换规则</p><ul><li>若参与运算量的类型不同，则先转换成同一类型，然后进行运算。</li><li>转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int型转成long型后再进行运算。<ul><li>a、若两种类型的字节数不同，转换成字节数高的类型</li><li>b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型</li></ul></li><li>所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。</li><li>char型和short型参与运算时，必须先转换成int型。</li><li>在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> aa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> bb = <span class="number">2.1</span>;</span><br><span class="line">aa = bb;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"aa = "</span> &lt;&lt; aa &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为 2，丢失小数部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为a + b = 3.1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>强制转换规则</p><ul><li>强制类型转换是通过类型转换运算来实现的。其一般形式为：<strong>（类型说明符）表达式</strong>其功能是把表达式的运算结果强制转换成类型说明符所表示的类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt; a + (<span class="keyword">int</span>)b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为a + b = 3</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="6-变量定义与声明的区别"><a href="#6-变量定义与声明的区别" class="headerlink" title="6.变量定义与声明的区别"></a>6.变量定义与声明的区别</h3><ul><li>定义包含了声明，但是声明不包含定义,<strong>变量声明是不会为变量开辟内存空间的</strong>,只有当声明也是定义时，声明才可以有初始化，初始化必须有存储空间来进行初始化。如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;     <span class="comment">//定义并声明了变量 a</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;  <span class="comment">//只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-cpp变量类型&quot;&gt;&lt;a href=&quot;#1-cpp变量类型&quot; class=&quot;headerlink&quot; title=&quot;1.cpp变量类型&quot;&gt;&lt;/a&gt;1.cpp变量类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;变量实际上是存储空间的名称，cpp中每个变量都有指定的类型，类型决定变量
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的基本数据类型介绍</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的基本数据类型介绍/</id>
    <published>2019-08-09T08:08:54.000Z</published>
    <updated>2019-08-09T08:09:33.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-cpp中的基本内置数据类型（7种）"><a href="#1-cpp中的基本内置数据类型（7种）" class="headerlink" title="1.cpp中的基本内置数据类型（7种）"></a>1.cpp中的基本内置数据类型（7种）</h3><ul><li>bool  char  int float double void(无类型) wchar_t(宽字符型)：typedef wchar_t short int;</li><li>一个基本类型可以被一个或多个类型修饰符来修饰。<ul><li>signed</li><li>unsigned</li><li>short</li><li>long</li></ul></li><li>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值(<strong>变量的大小会根据编译器和所使用的电脑而有所不同</strong>)<br><img src="https://upload-images.jianshu.io/upload_images/13407176-b102c5b08a016185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本数据类型.png"><h3 id="2-typedef声明"><a href="#2-typedef声明" class="headerlink" title="2.typedef声明"></a>2.typedef声明</h3></li><li><p>使用typedef为已有的类型取一个新的名字，语法如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：typedef<span class="built_in"> type </span>name;</span><br><span class="line">例如：typedef int feet;  feet是int的另一个名称</span><br><span class="line">     feet distance;  创建一个整型变量distance</span><br></pre></td></tr></table></figure></li><li><p>typedef 可以声明各种类型名，但不能用来定义变量。用 typedef 可以声明数组类型、字符串类型，使用比较方便。</p></li><li>用typedef只是对已经存在的类型增加一个类型名，而没有创造新的类型。</li><li>当在不同源文件中用到同一类型数据（尤其是像数组、指针、结构体、共用体等类型数据）时，常用 typedef 声明一些数据类型，把它们单独放在一个头文件中，然后在需要用到它们的文件中用 ＃include 命令把它们包含进来，以提高编程效率。</li><li>使用 typedef 有利于程序的通用与移植。有时程序会依赖于硬件特性，用 typedef 便于移植。</li><li><p>typedef 与 #define 的区别</p><ul><li><p>2.1 执行时间不同</p><ul><li>关键字 typedef 在编译阶段有效，由于是在编译阶段，因此 typedef 有类型检查的功能。</li><li>#define 则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    UINT value = <span class="string">"abc"</span>;  <span class="comment">// 类型检测，将会报错</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) x*x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>, b = <span class="number">2</span>, c;</span><br><span class="line">    c = f(a) / f(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>2.2 功能上的差异</p><ul><li>typedef 用来定义类型的别名，定义与平台无关的数据类型，与 struct 的结合使用等。</li><li>#define 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</li></ul></li><li><p>2.3 作用域不同</p><ul><li>#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而 typedef 有自己的作用域。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏的作用域</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> HW <span class="meta-string">"helloworld"</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = HW;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// typedef的作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// UNIT uvalue = 5;  报错！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">        UINT uvalueA;</span><br><span class="line">        A(): uvalueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">        <span class="comment">// UINT uvalueB;  报错</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 在B类中使用UINT会出错，因为UINT只在类A的作用域中。</span></span><br><span class="line">    <span class="comment">// 此外，在类中用typedef定义的类型别名还具有相应的访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AA</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">        UINT valueA;</span><br><span class="line">        AA(): valueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// AA::UINT i = 1;报错，在typedef前加上public权限则可以</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>2.4 对指针的操作——二者修饰指针类型时，作用不同</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* pint;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINT int*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> pint p1 = &amp;i1;  <span class="comment">// 等价于int * const p;指针常量:指针p是一个常量,p不可更改，p指向的内容可以更改</span></span><br><span class="line"><span class="keyword">const</span> PINT p2 = &amp;i2;  <span class="comment">// 等价于const int *p/int const *p，p可以更改，p指向的内容不可更改，常量指针</span></span><br><span class="line"></span><br><span class="line">pint s1, s2;  <span class="comment">// s1 和 s2都是int类型指针</span></span><br><span class="line">PINT s3, s4;  <span class="comment">// 相当于 int * s3, s4;只有一个是指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// p1 = &amp;i2; 指针常量p1不能被修改</span></span><br><span class="line">    *p1 = <span class="number">5</span>;   <span class="comment">// 但是p1指向的内容可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// *p2 = 5; 常量指针p2能被修改</span></span><br><span class="line">    p2 = &amp;i1;   <span class="comment">// 但是p2指向的内容不可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-枚举类型"><a href="#3-枚举类型" class="headerlink" title="3.枚举类型"></a>3.枚举类型</h3><ul><li>枚举类型是cpp中的一种派生数据类型，是由用户定义的若干枚举常量的集合</li><li>如果一个变量只有几种可能的值，可以定义为枚举类型。“枚举”就是将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</li><li><p>创建枚举，需要用到关键字enum，枚举类型的一般形式为:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名&#123;</span></span><br><span class="line">    标识符[=整型常量];</span><br><span class="line">    标识符[=整型常量];</span><br><span class="line">    ....</span><br><span class="line">    标识符[=整型常量];</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure></li><li><p>如果枚举没有初始化，即省略掉’=整型常数’时,则从第一个标识开始，如下面的例子，变量c的类型是color,最后被赋值为blue。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>&#123;</span></span><br><span class="line">    red, green, blue</span><br><span class="line">&#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure></li><li><p>默认情况下，第一个名称的值是0，第二个名称的值是1，第三个名称的值是2，依次类推。可以在定义枚举类型时，对枚举元素赋值。此时，赋值的枚举值为所赋的值，而其他没有赋值的枚举值在为前一个枚举值加1，例如下面：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>&#123;</span></span><br><span class="line">    red, greed = <span class="number">5</span>, blue</span><br><span class="line">&#125;;</span><br><span class="line">blue = <span class="number">6</span>,默认情况下，每个名称都会比前一个名称大，但red的值仍然是<span class="number">0</span>.</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-相关代码"><a href="#4-相关代码" class="headerlink" title="4.相关代码"></a>4.相关代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"limits"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x)  x*x  <span class="comment">// 宏定义</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 typedef执行时间不同</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// UINT value = "abc";  类型检测，将出错</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; value &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 作用域不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> HW <span class="meta-string">"helloworld"</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = HW;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// typedef的作用域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// UNIT uvalue = 5;  报错！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">    UINT uvalueA;</span><br><span class="line">    A(): uvalueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="comment">// UINT uvalueB;  报错</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在B类中使用UINT会出错，因为UINT只在类A的作用域中。</span></span><br><span class="line"><span class="comment">// 此外，在类中用typedef定义的类型别名还具有相应的访问权限</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">    UINT valueA;</span><br><span class="line">    AA(): valueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// AA::UINT i = 1;报错，在typedef前加上public权限则可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 对指针的操作---二者修饰指针类型时，作用不同</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* pint;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINT int*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> pint p1 = &amp;i1;  <span class="comment">// 等价于int * const p;指针常量:指针p是一个常量,p不可更改，p指向的内容可以更改</span></span><br><span class="line"><span class="keyword">const</span> PINT p2 = &amp;i2;  <span class="comment">// 等价于const int *p/int const *p，p可以更改，p指向的内容不可更改，常量指针</span></span><br><span class="line"></span><br><span class="line">pint s1, s2;  <span class="comment">// s1 和 s2都是int类型指针</span></span><br><span class="line">PINT s3, s4;  <span class="comment">// 相当于 int * s3, s4;只有一个是指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// p1 = &amp;i2; 指针常量p1不能被修改</span></span><br><span class="line">    *p1 = <span class="number">5</span>;   <span class="comment">// 但是p1指向的内容可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// *p2 = 5; 常量指针p2能被修改</span></span><br><span class="line">    p2 = &amp;i1;   <span class="comment">// 但是p2指向的内容不可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> color&#123;</span><br><span class="line">    red, green, blue=<span class="number">5</span>, yellow</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bool: "</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"char: "</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed char: "</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"short int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned short int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed short int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">short</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed long  int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned long  int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"float: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"double: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long double: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"wchar_t: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> feet;   <span class="comment">// typedef声明,但typedef int feet = 100;错误！</span></span><br><span class="line">    feet distance;</span><br><span class="line">    <span class="comment">// 1 宏定义执行时间不同</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>, b = <span class="number">6</span>, c;</span><br><span class="line">    c = f(a) / f(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TestPointer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"red = "</span> &lt;&lt; red &lt;&lt; <span class="string">" yellow = "</span> &lt;&lt; yellow &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 枚举类型举例</span></span><br><span class="line">    <span class="keyword">enum</span> days&#123;</span><br><span class="line">        one, two, three</span><br><span class="line">    &#125;day;</span><br><span class="line">    day = one;</span><br><span class="line">    <span class="keyword">switch</span>(day)&#123;</span><br><span class="line">        <span class="keyword">case</span> one:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"one"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> two:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"two"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"默认输出"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-cpp中的基本内置数据类型（7种）&quot;&gt;&lt;a href=&quot;#1-cpp中的基本内置数据类型（7种）&quot; class=&quot;headerlink&quot; title=&quot;1.cpp中的基本内置数据类型（7种）&quot;&gt;&lt;/a&gt;1.cpp中的基本内置数据类型（7种）&lt;/h3&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的参数传递方式：传值、传地址、传引用总结</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BC%A0%E5%80%BC%E3%80%81%E4%BC%A0%E5%9C%B0%E5%9D%80%E3%80%81%E4%BC%A0%E5%BC%95%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的参数传递方式：传值、传地址、传引用总结/</id>
    <published>2019-08-09T08:07:01.000Z</published>
    <updated>2019-08-09T08:08:17.786Z</updated>
    
    <content type="html"><![CDATA[<ul><li>指针：指针是一个变量，只不过这个变量中存储的是一个地址，指向内存中的一个单元。</li><li>引用：引用和原变量是同一个东西，只不过是原变量的一个别名。  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">10</span><span class="comment">;  定义一个整型变量a</span></span><br><span class="line">int *p = &amp;a<span class="comment">;  定义一个指向整型变量的指针变量p，该指针指向a的存储单元，即p的值是a存储单元的地址</span></span><br><span class="line">int &amp;<span class="keyword">b </span>= a<span class="comment">;   定义一个整型变量a的引用，a和b是同一个东西，在内存中占用同一个存储单元</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="一、引用的特性："><a href="#一、引用的特性：" class="headerlink" title="一、引用的特性："></a>一、引用的特性：</h3><ul><li>引用在定义时必须初始化</li><li>一个变量可以有多个引用</li><li>引用一旦绑定某个实体，就不能再是其他变量的引用。</li></ul><h3 id="二、引用和指针的区别与联系："><a href="#二、引用和指针的区别与联系：" class="headerlink" title="二、引用和指针的区别与联系："></a>二、引用和指针的区别与联系：</h3><ul><li>1.相同点：<ul><li>底层的实现方式相同，都是按照指针的方式实现的</li></ul></li><li>2.不同点：<ul><li>引用定义的时候必须初始化，指针可以不用初始化；</li><li>引用一旦初始化为指向一个对象，就不能再指向其他对象，而指针可以在任何时候指向任何一个同类型的对象；</li><li>没有空引用，但是有空指针；</li><li>在sizeof中的含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节的个数(在32为平台下，指针求sizeof永远是4)；</li><li>引用++改变的是变量的内容，指针++改变的是指针的指向；</li><li>有多级指针，没有多级引用；</li><li>引用使用起来比指针安全；</li><li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；<h3 id="三、传值、传地址、传引用的区别，哪个更高效？"><a href="#三、传值、传地址、传引用的区别，哪个更高效？" class="headerlink" title="三、传值、传地址、传引用的区别，哪个更高效？"></a>三、传值、传地址、传引用的区别，哪个更高效？</h3></li></ul></li><li>1.传值<ul><li>这种传递方式中，实参和形参是两个不同的地址空间，参数传递的实质是将原函数中变量的值，复制到被调用函数形参所在的存储空间中，这个形参的地址空间在函数执行完毕后，会被回收掉。整个被调用函数对形参的操作，只影响形参对应的地址空间，不影响原函数中变量的值，因为这两个不是同一个存储空间。<br><strong>即使形参的值在函数中发生了变化，实参的值也完全不会受到影响，仍为调用前的值。</strong></li></ul></li><li>2.传地址<ul><li>这种传递方式中，实参是变量的地址，形参是指针类型的变量，在函数中对指针变量的操作，就是对实参（变量地址）所对应的变量的操作，函数调用结束后，原函数中的变量的值将会发生改变。<br><strong>被调用函数中对形参指针所指向的地址中内容的任何改变都会影响到实参。</strong></li></ul></li><li>3.传引用<ul><li>这种传递方式中，形参是引用类型变量，其实就是实参的一个别名，在被调用函数中，对引用变量的所有操作等价于对实参的操作。这样，整个函数执行完毕后，原先的实参的值将会发生改变。<br><strong>被调函数对形参做的任何操作都影响了主调函数中的实参变量。</strong></li></ul></li><li>4.哪种更高效？<ul><li>在内置类型当中三种传递方式的效率上都差不多；</li><li>在自定义类型当中，传引用方式效率的更高效一些，因为它没有对形参进行一次拷贝<h3 id="四、常引用"><a href="#四、常引用" class="headerlink" title="四、常引用"></a>四、常引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;  等价于 <span class="keyword">int</span> *<span class="keyword">const</span> b = a;即引用是一个指针常量（又称常指针，即一个常量，其类型是指针）</span><br><span class="line">常引用：<span class="keyword">const</span> <span class="keyword">int</span> &amp;a=b;等价于<span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> a=b;不仅仅是a这个地址不可修改，而且其指向的内存空间也不可修改。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="五、引用的使用场景"><a href="#五、引用的使用场景" class="headerlink" title="五、引用的使用场景"></a>五、引用的使用场景</h3><ul><li><p>1.给变量起别名</p>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a<span class="comment">;</span></span><br><span class="line">int &amp;<span class="keyword">b </span>= a<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>2.将引用作为函数的参数</p><ul><li>使用引用类型就不必在swap中声明形参是指针变量，指针变量要另外开辟内存单元，其内容是地址。而引用变量不是一个独立的变量，不单独占内存单元。而且在调用swap函数时，只需要传值即可，将引用作为函数的形参更加简单、直观、方便。  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">swap(int </span>&amp;a, int &amp;<span class="keyword">b)</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   int temp<span class="comment">;</span></span><br><span class="line">    temp = a<span class="comment">;</span></span><br><span class="line">    a = <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">b </span>= temp<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>3.返回值</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> _iLeft, <span class="keyword">int</span> _iRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _iLeft + _iRight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引用返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp; _iLeft, <span class="keyword">int</span>&amp; _iRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> iResult = _iLeft + _iRight;</span><br><span class="line"><span class="keyword">return</span> iResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="六、代码实例"><a href="#六、代码实例" class="headerlink" title="六、代码实例"></a>六、代码实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_value</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_pointer</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_reference</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++的函数参数传递方式，可以是传值方式，也可以是传引用方式。</span></span><br><span class="line"><span class="comment">传值的本质是：形参是实参的一份复制。</span></span><br><span class="line"><span class="comment">传引用的本质是：形参和实参是同一个东西。</span></span><br><span class="line"><span class="comment">传值和传引用，对大多数常见类型都是适用的。指针、数组，它们都是数据类型的一种，没啥特殊的</span></span><br><span class="line"><span class="comment">因此,指针作为函数参数传递时，也区分为传值和传引用两种方式。</span></span><br><span class="line"><span class="comment">void fun_1(int a); int类型，传值(复制产生新的变量)</span></span><br><span class="line"><span class="comment">void fun_2(int &amp;a); int类型，传引用(形参和实参是同一个东西)</span></span><br><span class="line"><span class="comment">void fun_3(int *pi); 指针类型，传值(复制产生新的变量)</span></span><br><span class="line"><span class="comment">void fun_4(int *&amp;pi); 指针类型，传引用(形参和实参是同一个东西)</span></span><br><span class="line"><span class="comment">如果希望通过将参数传递到函数中，从而来改变变量的值（比如变量是T a，T表示类型)，</span></span><br><span class="line"><span class="comment">则可以有这2种方式选择：</span></span><br><span class="line"><span class="comment">    1.传a的引用： void my_fun(T &amp;a);</span></span><br><span class="line"><span class="comment">    2.传a的地址： void my_fun(T *a);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 值传递</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">形参意思是被调用函数的参数/变量，实参意思是主调函数中放到括号中的参数/变量。</span></span><br><span class="line"><span class="comment">传值方式下，形参是实参的拷贝：重新建立了变量，变量取值和实参一样。</span></span><br><span class="line"><span class="comment">即实参a和b的值为20和10,形参x和y的值都是20和10；而a与x的地址、b与y的地址并不相同</span></span><br><span class="line"><span class="comment">表明形参x和y是新建的变量，也即实参a, b是从形参复制了一份</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap_by_value(a, b); <span class="comment">// 值传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*-------------------------分界线1------------------*/</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap_by_pointer(&amp;a, &amp;b); <span class="comment">// 值传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*-------------------------分界线2------------------*/</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap_by_reference(a, b); <span class="comment">// 引用传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_value</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 传指针(地址),实质还是传值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_pointer</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 传引用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传引用，传递的是实参本身，而不是实参的一个拷贝，形参的修改就是实参的修改,即值相同，地址也相同</span></span><br><span class="line"><span class="comment">相比于传值，传引用的好处是省去了复制，节约了空间和时间。</span></span><br><span class="line"><span class="comment">假如不希望修改变量的值，那么请选择传值而不是传引用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_reference</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 总结</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">“引用”类型变量的声明方式：变量类型 &amp;变量名;   int &amp;b;</span></span><br><span class="line"><span class="comment">“指针”类型的声明方式：基类型 *变量名;  int *pi;</span></span><br><span class="line"><span class="comment">“指针的引用类型”应当这样声明：基类型 *&amp;变量名   int *&amp;pi;</span></span><br><span class="line"><span class="comment">指针类型，也是有传值、传引用两种函数传参方式的：</span></span><br><span class="line"><span class="comment">    1.指针的传值方式</span></span><br><span class="line"><span class="comment">        void my_fun(int *a, int n);</span></span><br><span class="line"><span class="comment">    2.指针的传引用方式</span></span><br><span class="line"><span class="comment">        void my_fun(int *&amp;pi, int n);</span></span><br><span class="line"><span class="comment">// 普通类型，以int a为例</span></span><br><span class="line"><span class="comment">void myfun(int a)    //传值，产生复制</span></span><br><span class="line"><span class="comment">void myfun(int &amp;a)   //传引用，不产生复制</span></span><br><span class="line"><span class="comment">void myfun(int *a)   //传地址，产生复制，本质上是一种传值，这个值是地址</span></span><br><span class="line"><span class="comment">// 指针类型，以int *a为例</span></span><br><span class="line"><span class="comment">void myfun(int *a)   //传值，产生复制</span></span><br><span class="line"><span class="comment">void myfun(int *&amp;a)  //传引用，不产生复制</span></span><br><span class="line"><span class="comment">void myfun(int **a)   //传地址，产生复制，本质上是一种传值，这个值是指针的地址</span></span><br><span class="line"><span class="comment">// 数组类型，以int a[10]为例</span></span><br><span class="line"><span class="comment">void myfun(int a[], int n) //传值，产生复制</span></span><br><span class="line"><span class="comment">void myfun(int* a, int n) //传值，产生复制，传递的数组首地址</span></span><br><span class="line"><span class="comment">void myfun(int (&amp;arr)[10]) //传引用，不产生复制。需要硬编码数组长度</span></span><br><span class="line"><span class="comment">template&lt;size_t size&gt; void myfun(int (&amp;arr)[size]) //传引用，不产生复制。不需要硬编码数组长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="七、参考博客"><a href="#七、参考博客" class="headerlink" title="七、参考博客"></a>七、参考博客</h3><p><a href="http://www.cnblogs.com/zjutzz" target="_blank" rel="noopener">1.Chris的技术博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;指针：指针是一个变量，只不过这个变量中存储的是一个地址，指向内存中的一个单元。&lt;/li&gt;
&lt;li&gt;引用：引用和原变量是同一个东西，只不过是原变量的一个别名。  &lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>常引用、常量指针、指针常量、指向常量的常指针、空指针与野指针解释</title>
    <link href="https://cdlwhm1217096231.github.io/C/%E5%B8%B8%E5%BC%95%E7%94%A8%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E3%80%81%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E3%80%81%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E5%B8%B8%E6%8C%87%E9%92%88%E3%80%81%E7%A9%BA%E6%8C%87%E9%92%88%E4%B8%8E%E9%87%8E%E6%8C%87%E9%92%88%E8%A7%A3%E9%87%8A/"/>
    <id>https://cdlwhm1217096231.github.io/C/常引用、常量指针、指针常量、指向常量的常指针、空指针与野指针解释/</id>
    <published>2019-08-09T08:05:33.000Z</published>
    <updated>2019-08-09T08:06:20.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、一-基础知识"><a href="#1、一-基础知识" class="headerlink" title="1、一.基础知识"></a>1、一.基础知识</h3><ul><li>引用并非对象</li><li>引用必须初始化</li><li>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</li><li><p>类型要严格匹配</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">10</span>;             <span class="comment">//错误：引用类型的初始值必须是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;              <span class="comment">//错误：此处引用类型的初始值必须是int型对象</span></span><br></pre></td></tr></table></figure></li><li><p>指针本身就是对象</p></li><li>指针的类型要和它指向的对象严格匹配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"><span class="keyword">double</span> *pd = &amp;dval;      <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">double</span> *pd2 = pd;        <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi = pd;            <span class="comment">//错误：指针pi的类型和pd的类型不匹配</span></span><br><span class="line">pi = &amp;dval;              <span class="comment">//错误：试图把double型对象的地址赋给int型指针</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="二-常量引用"><a href="#二-常量引用" class="headerlink" title="二.常量引用"></a>二.常量引用</h3><ul><li>初始化常量引用时允许用任意表达式作为初始值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;       <span class="comment">//正确：允许将const int &amp; 绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;      <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>;        <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;    <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;</span><br><span class="line">r1 = <span class="number">0</span>;                  <span class="comment">//正确</span></span><br><span class="line">r2 = <span class="number">0</span>;                  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="三-常量指针"><a href="#三-常量指针" class="headerlink" title="三.常量指针"></a>三.常量指针</h3><ul><li>定义： 又叫常指针，可以理解为常量的指针，也即这个是指针，但指向的是个常量，这个常量是指针的值（地址），而不是地址指向的值。</li><li>关键点：<ul><li>1.常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改；</li><li>2.常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值；指针指向的地址可以改变，但指针指向的地址所对应的内容不可以改变</li><li>3.指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；</li></ul></li><li>代码形式：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;  <span class="keyword">const</span> <span class="keyword">int</span>* p;</span><br></pre></td></tr></table></figure></li></ul><h3 id="四-指针常量"><a href="#四-指针常量" class="headerlink" title="四.指针常量"></a>四.指针常量</h3><ul><li>定义：本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。</li><li>关键点：<ul><li>1.指针常量的值是指针，这个值是常量，不能被修改；指向的地址不可以改变，但指向的地址所对应的内容可以改变</li><li>2.指针本身是常量，指针指向的地址不可以变化,但是指针指向的地址所对应的内容可以变化；</li></ul></li><li>代码形式:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure></li></ul><h3 id="五-指向常量的常指针"><a href="#五-指向常量的常指针" class="headerlink" title="五.指向常量的常指针"></a>五.指向常量的常指针</h3><ul><li>定义：指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。</li><li>关键点：<ul><li>1.一个指针常量，指向的是一个指针对象；</li><li>2.它指向的指针对象且是一个常量，即它指向的对象不能变化；</li></ul></li><li>代码形式：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure></li></ul><h3 id="六-那如何区分这几类呢"><a href="#六-那如何区分这几类呢" class="headerlink" title="六.那如何区分这几类呢?"></a>六.那如何区分这几类呢?</h3><ul><li><p>带两个const的肯定是指向常量的常指针，很容易理解，主要是如何区分常量指针和指针常量.</p><ul><li><p>一种方式是看 * 和 const 的排列顺序，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;    <span class="comment">//const * 即常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;    <span class="comment">//const * 即常量指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;    <span class="comment">//* const 即指针常量</span></span><br></pre></td></tr></table></figure></li><li><p>还一种方式是看const离谁近，即从右往左看，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;    <span class="comment">//const修饰的是*p，即*p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改；</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;    <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;    <span class="comment">//const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------常量指针-------</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line">a = <span class="number">300</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line"><span class="comment">//*p1 = 56;  //Error,*p1是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">p1 = &amp;b;     <span class="comment">//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针常量-------//</span></span><br><span class="line"><span class="keyword">int</span>*  <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">a = <span class="number">500</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line">*p2 = <span class="number">400</span>;   <span class="comment">//OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</span></span><br><span class="line"><span class="comment">//p2 = &amp;b;     //Error,因为p2是const 指针，因此不能改变p2指向的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指向常量的常量指针-------//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">//*p3 = 1;    //Error</span></span><br><span class="line"><span class="comment">//p3 = &amp;b;    //Error</span></span><br><span class="line">a = <span class="number">5000</span>;    <span class="comment">//OK,仍然可以通过原来的声明修改值</span></span><br></pre></td></tr></table></figure></li><li><p>在实际应用中，常量指针要比指针常量用的多，比如常量指针经常用在函数传参中，以避免函数内部修改内容。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>* src); <span class="comment">//常量指针，src的值不可改变；</span></span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> b[] = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">size_t</span> a1 = <span class="built_in">strlen</span>(a);</span><br><span class="line"><span class="keyword">size_t</span> b1 = <span class="built_in">strlen</span>(b);</span><br><span class="line">虽然a、b是可以修改的，但是可以保证在<span class="built_in">strlen</span>函数内部不会修改a、b的内容。</span><br></pre></td></tr></table></figure></li></ul><h3 id="七-空指针与野指针"><a href="#七-空指针与野指针" class="headerlink" title="七.空指针与野指针"></a>七.空指针与野指针</h3><ul><li>空指针就是保存地址为空的指针，使用指针时必须先判断是否空指针，很多问题都是这一步导致的。</li><li>野指针是在delete掉指针之后，没有置0，导致指针随意指向了一个内存地址，如果继续使用，会造成不可预知的内存错误。另外指针的误用很容易造成BUG或者内存泄漏。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------空指针-------//</span></span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//printf("%d",*p4); //运行Error，使用指针时必须先判断是否空指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------野指针（悬浮、迷途指针）-------//</span></span><br><span class="line"><span class="keyword">int</span> *p5 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">delete</span> p5;</span><br><span class="line">p5 = <span class="literal">NULL</span>; <span class="comment">//一定要有这一步</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*p5);  <span class="comment">//隐藏bug，delete掉指针后一定要置0，不然指针指向位置不可控，运行中可导致系统挂掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针的内存泄漏-------//</span></span><br><span class="line"><span class="keyword">int</span> *p6 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">6</span>);</span><br><span class="line">p6 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">7</span>); <span class="comment">//p6原本指向的那块内存尚未释放，结果p6又指向了别处，原来new的内存无法访问，也无法delete了，造成memory leak</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="八-参考资料"><a href="#八-参考资料" class="headerlink" title="八.参考资料"></a>八.参考资料</h3><ul><li><a href="http://www.runoob.com/w3cnote/c-constant-pointer.html" target="_blank" rel="noopener">1.菜鸟教程</a></li><li><a href="http://www.cnblogs.com/lizhenghn/p/3630405.html" target="_blank" rel="noopener">2.C++中指针常量和常量指针的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、一-基础知识&quot;&gt;&lt;a href=&quot;#1、一-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1、一.基础知识&quot;&gt;&lt;/a&gt;1、一.基础知识&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;引用并非对象&lt;/li&gt;
&lt;li&gt;引用必须初始化&lt;/li&gt;
&lt;li&gt;引用只能绑定在
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++实现斐波那契数列</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-实现斐波那契数列/</id>
    <published>2019-08-09T08:00:45.000Z</published>
    <updated>2019-08-09T08:01:40.590Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方法和循环方法的对比</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归方法代码实现比较简洁，但是性能不如循环方法，还会出现栈溢出的问题，优先采用递归的方法！</span></span><br><span class="line"><span class="comment">搜索路径的题目：一般使用回溯法，回溯法很适合使用递归方法的代码来实现！当要求不能使用递归实现的时候，考虑使用栈模拟递归的过程</span></span><br><span class="line"><span class="comment">求某个问题的最优解时，并且该问题可以拆分为多个子问题时：可以尝试使用动态规划的方法！在使用自上而下的递归思路去分析动态规划问题时，会发现子问题之间存在重叠</span></span><br><span class="line"><span class="comment">的更小的子问题。为了避免不必要的重复计算，使用自下而上的循环代码来实现，即把子问题的最优解先计算出来并用数组保存下来，然后基于子问题的解计算大问题的解。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特殊情况：在分解子问题的时候存在某个特殊的选择，采用这个特殊的选择将一定那个得到最优解，则此题目可能适用于贪心算法！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FibByRecursive</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> FibByRecursive(n<span class="number">-1</span>) + FibByRecursive(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first=<span class="number">0</span>, second=<span class="number">1</span>, third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            second = first;</span><br><span class="line">            third = second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的文件读写操作(4)</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-4/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的文件读写操作-4/</id>
    <published>2019-08-09T08:00:03.000Z</published>
    <updated>2019-08-09T08:00:23.616Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sstream"</span>    <span class="comment">// 使用istringstream所需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">string头文件定义了三个类型来支持内存IO:</span></span><br><span class="line"><span class="comment">    istringstream向string读取数据</span></span><br><span class="line"><span class="comment">    ostringstrream向string写入数据</span></span><br><span class="line"><span class="comment">    stringstream既可以从string读数据也可以向string写数据，就像string是一个IO流一样</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// istringstream的用法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"hello world! I am Lee."</span>;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(is &gt;&gt; s)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的文件读写操作(3)</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-3/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的文件读写操作-3/</id>
    <published>2019-08-09T07:58:51.000Z</published>
    <updated>2019-08-09T07:59:40.615Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 如果源文件中的每行数据数量不一样，demo2中的方法就不行了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Num_3, Num_2;</span><br><span class="line">    <span class="keyword">int</span> v, w, weight;</span><br><span class="line">    ifstream infile;  <span class="comment">// 读操作,输入流</span></span><br><span class="line">    ofstream outfile; <span class="comment">// 写操作，输出流</span></span><br><span class="line">    infile.open(<span class="string">"E:\\C++\\cpp_Code\\data1.txt"</span>, ios::in);</span><br><span class="line">    <span class="keyword">if</span> (!infile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件操作失败...\n"</span>;</span><br><span class="line">    infile &gt;&gt; Num_3 &gt;&gt; Num_2;  <span class="comment">// 先读取第一行</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>!=Num_3)&#123;  <span class="comment">// 读取第3个数据</span></span><br><span class="line">        infile &gt;&gt; v &gt;&gt; w &gt;&gt; weight;</span><br><span class="line">        cost[v][w] = weight;</span><br><span class="line">        cost[w][v] = weight;</span><br><span class="line">        Num_3--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>!=Num_2)&#123;  <span class="comment">// 读取第2个数据</span></span><br><span class="line">        infile &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        cost[v][w] = <span class="number">100</span>;</span><br><span class="line">        cost[w][v] = <span class="number">100</span>;</span><br><span class="line">        Num_2--;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    outfile.open(<span class="string">"E:\\C++\\cpp_Code\\result1.txt"</span>, ios::out);</span><br><span class="line">    <span class="keyword">if</span>(!outfile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败\n"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">10</span>;j++)&#123;</span><br><span class="line">            outfile &lt;&lt; i &lt;&lt; <span class="string">"\t"</span> &lt;&lt; j &lt;&lt; <span class="string">"\t"</span> &lt;&lt; cost[i][j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的文件读写操作(2)</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-2/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的文件读写操作-2/</id>
    <published>2019-08-09T07:57:52.000Z</published>
    <updated>2019-08-09T07:58:30.591Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo1中是向文件中写入string类型，下面是向文件中写入int类型</span></span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v, w, weight;</span><br><span class="line">    ifstream infile;  <span class="comment">// 读操作</span></span><br><span class="line">    ofstream outfile;  <span class="comment">// 写操作</span></span><br><span class="line">    infile.open(<span class="string">"E:\\C++\\cpp_Code\\data.txt"</span>, ios::in);</span><br><span class="line">    <span class="keyword">if</span> (! infile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(!infile.eof())&#123;</span><br><span class="line">        infile &gt;&gt; v &gt;&gt; w &gt;&gt; weight;</span><br><span class="line">        cost[v][w] = weight;</span><br><span class="line">        cost[w][v] = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line"></span><br><span class="line">    outfile.open(<span class="string">"E:\\C++\\cpp_Code\\result.txt"</span>, ios::app);</span><br><span class="line">    <span class="keyword">if</span>(!outfile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j!=<span class="number">10</span>;++j)&#123;</span><br><span class="line">            outfile &lt;&lt; i &lt;&lt; <span class="string">"\t"</span> &lt;&lt; j &lt;&lt; <span class="string">"\t"</span> &lt;&lt; cost[i][j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的文件读写操作(1)</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-1/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的文件读写操作-1/</id>
    <published>2019-08-09T07:55:56.000Z</published>
    <updated>2019-08-09T07:56:47.424Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">ofstream  文件写操作，内存写入存储设备</span></span><br><span class="line"><span class="comment">ifstream  文件读操作，存储设备读取到内存中</span></span><br><span class="line"><span class="comment">fstream   读写操作，对打开的文件可进行读写操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件打开模式：</span></span><br><span class="line"><span class="comment">    ios::in   只读</span></span><br><span class="line"><span class="comment">    ios::out  只写</span></span><br><span class="line"><span class="comment">    ios::app  从文件末尾开始写，防止丢失文本中原有的内容，追加模式</span></span><br><span class="line"><span class="comment">    ios::binary 二进制模式</span></span><br><span class="line"><span class="comment">    ios::nocreate 打开一个文件时，如果文件不存在，不创建</span></span><br><span class="line"><span class="comment">    ios::noreplace 打开一个文件时，如果文件不存在，创建该文件</span></span><br><span class="line"><span class="comment">    ios::trunc   打开一个文件时，然后清空内容</span></span><br><span class="line"><span class="comment">    ios::ate     打开一个文件时，将位置移动到文件末尾</span></span><br><span class="line"><span class="comment">文件指针位置的C++中的用法：</span></span><br><span class="line"><span class="comment">    ios::beg   文件开头</span></span><br><span class="line"><span class="comment">    ios::end   文件末尾</span></span><br><span class="line"><span class="comment">    ios::cur   文件当前位置</span></span><br><span class="line"><span class="comment">    举个例子：</span></span><br><span class="line"><span class="comment">        file.seekg(0, ios::beg)  让文件指针定位到文件开头</span></span><br><span class="line"><span class="comment">        file.seekg(0, ios::end)  让文件指针定位到文件末尾</span></span><br><span class="line"><span class="comment">        file.seekg(10, ios::cur) 让文件指针从当前位置向文件末尾方向移动10个字节</span></span><br><span class="line"><span class="comment">        file.seekg(-10, ios::cur) 让文件指针从当前位置向文件开始方向移动10个字节</span></span><br><span class="line"><span class="comment">        file.seekg(10,ios::beg)   让文件指针定位到离文件开头10个字节的位置</span></span><br><span class="line"><span class="comment">常用的错误判断方法:</span></span><br><span class="line"><span class="comment">    good()   如果文件打开成功</span></span><br><span class="line"><span class="comment">    bad()    打开文件时发生错误</span></span><br><span class="line"><span class="comment">    eof()    到达文件尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取hello.txt文件中的字符串，写入out.txt中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"E:\\C++\\cpp_Code\\hello.txt"</span>)</span></span>;  <span class="comment">// 读操作</span></span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"E:\\C++\\cpp_Code\\out.txt"</span>)</span></span>;   <span class="comment">// 写操作</span></span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(! infile.is_open())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(getline(infile, temp))&#123;  </span><br><span class="line">        outfile &lt;&lt; temp;</span><br><span class="line">        outfile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">getline()函数的作用：从输入字节流中读入字符，存到string变量中</span></span><br><span class="line"><span class="comment">直到遇到下面的情况停止：</span></span><br><span class="line"><span class="comment">    读入了文件结束标志</span></span><br><span class="line"><span class="comment">    读到一个新行</span></span><br><span class="line"><span class="comment">    达到字符串的最大穿长度</span></span><br><span class="line"><span class="comment">    如果getline没有读入字符，将返回false，用于判断文件是否结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>复习07统计学习方法(支持向量机SVM)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A007%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习07统计学习方法-支持向量机SVM-图片版/</id>
    <published>2019-08-08T09:19:10.000Z</published>
    <updated>2019-08-08T09:19:38.978Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-e4c4763e681374ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-c1ff663b44869d2d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-de40ae539a1594b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-06a7b0733b4a897f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-9e0578690b11ea48.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-e4c4763e681374ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习06统计学习方法(Logistic回归与最大熵模型)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A006%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-Logistic%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习06统计学习方法-Logistic回归与最大熵模型-图片版/</id>
    <published>2019-08-08T09:18:28.000Z</published>
    <updated>2019-08-08T09:18:51.537Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-23330af289b7990d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-c546a04832004463.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-43f59ed14e078287.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-f62301a284aa666e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-23330af289b7990d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习05统计学习方法(决策树算法Decision Tree)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A005%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95Decision-Tree-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习05统计学习方法-决策树算法Decision-Tree-图片版/</id>
    <published>2019-08-08T09:17:29.000Z</published>
    <updated>2019-08-08T09:18:03.467Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-949bf3d21a6cd513.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-89551868a0657f58.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-db3b56affe58f09f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-fb1b2f4fd7c44637.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-15c3694d44fe89d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-949bf3d21a6cd513.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习04统计学习方法(朴素贝叶斯算法Naive Bayes)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A004%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95Naive-Bayes-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习04统计学习方法-朴素贝叶斯算法Naive-Bayes-图片版/</id>
    <published>2019-08-08T09:16:37.000Z</published>
    <updated>2019-08-08T09:17:08.698Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-6db2674e97151f85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-9ca54696ca36e9db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-6db2674e97151f85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习03统计学习方法(K近邻算法KNN)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A003%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95KNN-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习03统计学习方法-K近邻算法KNN-图片版/</id>
    <published>2019-08-08T09:15:49.000Z</published>
    <updated>2019-08-08T09:16:18.163Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-a32e76e75c8fe185.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KNN"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-a32e76e75c8fe185.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常见的距离函数总结</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/常见的距离函数总结/</id>
    <published>2019-08-08T09:14:30.000Z</published>
    <updated>2019-08-08T09:37:55.424Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-距离函数总结"><a href="#1-距离函数总结" class="headerlink" title="1.距离函数总结"></a>1.距离函数总结</h4><ul><li><strong>闵可夫斯基距离</strong>：<script type="math/tex; mode=display">\text { distance( }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left(\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{p}\right)^{1 / p}</script></li><li>当p=2时，闵可夫斯基距离就是<strong>欧式距离</strong>：<script type="math/tex; mode=display">\operatorname{distance}\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{2}=\sqrt{\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{2}}</script></li><li>当p=1时，闵可夫斯基距离就是<strong>曼哈顿距离</strong>：<script type="math/tex; mode=display">\text { distance }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{1}=\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|</script></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-距离函数总结&quot;&gt;&lt;a href=&quot;#1-距离函数总结&quot; class=&quot;headerlink&quot; title=&quot;1.距离函数总结&quot;&gt;&lt;/a&gt;1.距离函数总结&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;闵可夫斯基距离&lt;/strong&gt;：&lt;script type=&quot;m
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习01统计学习方法(机器学习中的重要概念)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A001%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习01统计学习方法-机器学习中的重要概念-图片版/</id>
    <published>2019-08-08T09:12:35.000Z</published>
    <updated>2019-08-08T09:13:51.004Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-f39bf23781f1aac2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-fa87d164d7048479?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-f39bf23781f1aac2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; al
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法岗面试常见问题大集合</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E5%B2%97%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%A7%E9%9B%86%E5%90%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/算法岗面试常见问题大集合/</id>
    <published>2019-07-30T14:51:47.000Z</published>
    <updated>2019-08-01T07:08:31.550Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-参考博客"><a href="#1-参考博客" class="headerlink" title="1.参考博客"></a>1.参考博客</h4><ul><li><a href="https://www.nowcoder.com/ta/review-ml?query=&amp;asc=true&amp;order=&amp;page=1" target="_blank" rel="noopener">算法岗面试常见问题大集合</a></li><li><a href="http://www.huaxiaozhuan.com/" target="_blank" rel="noopener">算法工程师手册</a></li></ul><h4 id="2-模型过拟合的解决方法"><a href="#2-模型过拟合的解决方法" class="headerlink" title="2.模型过拟合的解决方法"></a>2.模型过拟合的解决方法</h4><ul><li>L1/L2正则化（原理奥卡姆剃刀）:L2正则化也叫作权重衰减，目标函数中增加所有权重w参数的平方之和，迫使所有w可能趋向0但不为0；L1正则化在损失函数中加入所有权重参数w的绝对值之和，迫使更多的w为0，使特征变得稀疏。</li><li>Batch Normalization（对神经网络中下一层的输入进行归一化处理，使得输入量的均值为0，方差为1，即通过特征归一化，加速模型的训练）</li><li>shortcut-connect(使用残差网络Residual network)</li><li>数据增强(增加样本的数量)</li><li>early stopping</li><li>Dropout：在训练过程中，让神经元以超参数p的概率被激活(也就是说1-p的概率被设置为0)，类似于bagging算法</li></ul><h4 id="3-如何解决样本类别的不均衡问题？"><a href="#3-如何解决样本类别的不均衡问题？" class="headerlink" title="3.如何解决样本类别的不均衡问题？"></a>3.如何解决样本类别的不均衡问题？</h4><ul><li>a.过采样/上采样：增加类别少的样本数量实现样本数量的均衡。具体是通过复制类别上的样本构成多条数据。此方法的缺点是当样本的特征很少时，容易出现过拟合。需要对过采样方法进行改进，改进的方法是：在类别少的样本中加入噪声、干扰数据或通过一定的规则产生新合成的样本，如smote算法。</li><li>b.欠采样/下采样：减少类别多的样本数量，一般的方法是随机地去掉一些类别多的样本。</li><li>c.调整正负样本的惩罚权重：对类别少的样本赋予高的权重，对类别多的样本赋予低的权重。</li><li>d.通过集成学习的方法：每次生成训练集时，使用所有类别少的样本，同时从类别多的样本中随机抽取数据与类别少的样本合并起来，构成一个新的训练集。</li><li>e.使用特征选择：一般样本不均衡也会导致特征不均衡。但如果类别少的样本量具有一定的规模时，则意味着其特征的分布较为均匀，可以选择出具有显著特征配合参与解决样本不均衡的问题。</li></ul><h4 id="4-在神经网络训练过程中，为什么会出现梯度消失的问题？如何防止？"><a href="#4-在神经网络训练过程中，为什么会出现梯度消失的问题？如何防止？" class="headerlink" title="4.在神经网络训练过程中，为什么会出现梯度消失的问题？如何防止？"></a>4.在神经网络训练过程中，<strong>为什么会出现梯度消失的问题？如何防止</strong>？</h4><ul><li>原因：使用了不合适的激活函数，例如sigmoid函数。此时，当神经网络的层数很深时，利用链式求导法则计算梯度时，损失函数的梯度连乘，导致乘积会变得越来越小接近于0，从而神经网络无法学习到新的信息。</li><li>解决方法：<ul><li>预训练加微调</li><li>梯度剪切</li><li>权重正则化</li><li>使用不同的激活函数</li><li>使用Batch Normalization</li><li>使用残差网络ResNet</li><li>使用LSTM网络</li></ul></li></ul><h4 id="5-介绍一下TensorFlow中的计算图"><a href="#5-介绍一下TensorFlow中的计算图" class="headerlink" title="5.介绍一下TensorFlow中的计算图"></a>5.介绍一下TensorFlow中的计算图</h4><ul><li>TensorFlow是一个通过计算图的形式来表述计算的编程系统，计算图也叫作数据流图。可以把计算图看做是一种有向图，TensorFlow中的每个节点都是计算图上的一个张量Tensor，而节点之间的边描述了计算之间的依赖关系和数学运算。</li></ul><h4 id="6-K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。"><a href="#6-K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。" class="headerlink" title="6.K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。"></a>6.K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。</h4><ul><li>欧式距离最常见的是两个或多个点之间的距离表示法，又称为欧几里得距离。也就是通常所说的L2范数，公式如下。欧式距离的缺点是它将样本的不同属性之间的差别等同看待，这一点有时候不能满足实际要求。<script type="math/tex; mode=display">d(x, y) :=\sqrt{\left(x_{1}-y_{1}\right)^{2}+\left(x_{2}-y_{2}\right)^{2}+\cdots+\left(x_{n}-y_{n}\right)^{2}}=\sqrt{\sum_{i=1}^{n}\left(x_{i}-y_{i}\right)^{2}}</script></li><li>曼哈顿距离，也就是欧式空间中的在直角坐标系上两个点所形成的线段对轴产生的投影的距离总和。也就是我们所说的L1距离。例如，坐标(x1,y1)的点P1与坐标(x2, y2)的点P2的曼哈顿距离计算公式为：<script type="math/tex; mode=display">\left|x_{1}-x_{2}\right|+\left|y_{1}-y_{2}\right|</script></li></ul><h4 id="7-参数模型与非参数模型"><a href="#7-参数模型与非参数模型" class="headerlink" title="7.参数模型与非参数模型"></a>7.参数模型与非参数模型</h4><ul><li>参数模型：根据预先设计的规则，例如方差损失最小，进行学习，参数模型例子：回归（线性回归、逻辑回归）模型；最好可以看一下或者直接进行一下相关的推导；根据规则，拥有少部分数据就可以；</li><li>非参数模型：不需要事先假设规则，直接挖掘潜在数据中的规则；非参数模型例子：KNN，决策树，挖掘数据潜在的特征，所以比较灵活；</li></ul><h4 id="8-生成模型与判别模型"><a href="#8-生成模型与判别模型" class="headerlink" title="8.生成模型与判别模型"></a>8.生成模型与判别模型</h4><ul><li>生成模型：根据数据学习联合概率分布P(x,y)，从而计算出条件概率分布P(y|x)作为预测的模型。常用于含有隐变量的模型，例如HMM，朴素贝叶斯算法、高斯混合模型GMM、文档主题生成模型LDA、限制玻尔兹曼机等</li><li>判别模型：根据数据直接学习条件概率分布P(x|y)或者决策函数Y=f(X)作为预测模型。例如：逻辑回归、RF、SVM、神经网络、感知机、KNN、CRF等</li><li>两者的对比：<ul><li>使用生成式方法得到的模型，可以还原出模型的联合概率分布，而判别模型不可以；</li><li>生成式方法得到的模型收敛速度更快。当样本数增加时，生成式方法得到的模型能更快的收敛到真实模型；</li><li>存在隐变量时，只能使用生成模型；</li><li>使用判别式方法学习得到的模型，直接面对预测，学习的准确率通常更高，可以简化学习问题。</li></ul></li></ul><h4 id="9-LR和SVM的联系和区别？"><a href="#9-LR和SVM的联系和区别？" class="headerlink" title="9.LR和SVM的联系和区别？"></a>9.LR和SVM的联系和区别？</h4><ul><li>联系：<ul><li>LR和SVM都可以处理分类问题，且一般都用于处理线性二分类问题</li><li>两个方法都可以增加不同的正则化项，如L1、L2正则化项</li></ul></li><li>区别：<ul><li>LR是参数模型，SVM是非参数模型</li><li>从损失函数来看，LR使用的是交叉熵损失函数，SVM使用的hinge损失函数，这两个损失函数的目的都是增加对分类影响较大的样本点的权重，减小与分类关系比较小的数据点的权重。</li><li>SVM的处理方法只考虑支持向量，也就是只考虑和分类最相关的少数样本点来学习分类器。而逻辑回归通过非线性映射，大大减小了离分离超平面远的样本点权重，相对提升了与分类最相关的样本点的权重。</li><li>LR模型相对来说简单好理解，一般用于大规模的线性分类。SVM的理解和优化比较复杂，在处理复制非线性分类时，使用核技巧来计算优势明显。</li><li>LR能做的SVM也能做，但可能准确率是上有问题，但SVM能做的LR做不了。</li></ul></li></ul><h4 id="10-神经网络中参数量parameters和FLOPs计算"><a href="#10-神经网络中参数量parameters和FLOPs计算" class="headerlink" title="10.神经网络中参数量parameters和FLOPs计算"></a>10.神经网络中参数量parameters和FLOPs计算</h4><ul><li>CNN中的parameters分为两种：W和b，<strong>对于某一个卷积层，它的parameters的个数为</strong>:<script type="math/tex; mode=display">\left(K_{h} * K_{w} * C_{i n}\right) * C_{o u t}+C_{o u t}</script>其中，$K<em>{h}$是卷积核的高度，$K</em>{w}$是卷积核的宽度,$C<em>{in}$是输入的通道数，$C</em>{out}$是输出的通道数</li><li><strong>对于某个全连接层</strong>，如果输入的数据有$N<em>{in}$个节点，输出的数据有$N</em>{out}$个节点，它的参数个数为：<script type="math/tex; mode=display">N_{i n} * N_{o u t}+N_{o u t}</script></li><li>FLOPs：<strong>全称是floating point operations per second，指的是每秒浮点运算次数，即用来衡量硬件的计算性能</strong></li><li><strong>对于某个卷积层</strong>,它的FLOPs数量是：<script type="math/tex; mode=display">\left[\left(K_{h} * K_{w} * C_{i n}\right) * C_{o u t}+C_{o u t}\right] *(H * W)=n u m_{-} \text { params } *(H * W)</script>其中，$num_{params}$表示该层参数的数量，H是输出图片的高，W是输出图片的宽</li><li><strong>例题1：假设你的输入是一个300×300的彩色（RGB）图像，而你没有使用卷积神经网络。 如果第一个隐藏层有100个神经元，每个神经元与输入层进行全连接，那么这个隐藏层有多少个参数（包括偏置参数）</strong>？</li><li>A1：因为输入的节点数量是300*300*3,输出的节点数量是100。然后加上偏置项b，因为隐藏层有100个节点，每个节点都有一个偏置，所以b=100。利用上面计算全连接网络的公式，故3*300*300*100+100</li><li><strong>例题2：假设你的输入是300×300彩色（RGB）图像，并且你使用卷积层和100个过滤器，每个过滤器都是5×5的大小，请问这个隐藏层有多少个参数（包括偏置参数）</strong>？</li><li>A2：首先，参数和输入的图片大小是没有关系的，无论你给的图像像素有多大，参数值都是不变的，在这个题中，参数值只与过滤器有关。单个过滤器的大小是5*5,由于输入的是RGB图像，所以输入通道数目是3。因此一个过滤器的组成是5*5*3,每一过滤器只有一个偏置项b,因此一个过滤器所拥有的参数是5*5*3+1=76，一共用了100个过滤器，所以隐藏层含有76*100=7600个参数。其实，也就是上面的公式计算CNN的参数量。</li></ul><h4 id="11-SVM中常见的几种核函数"><a href="#11-SVM中常见的几种核函数" class="headerlink" title="11.SVM中常见的几种核函数"></a>11.SVM中常见的几种核函数</h4><ul><li>线性核函数：内积公式<script type="math/tex; mode=display">\kappa\left(x_{1}, x_{2}\right)=\left\langle x_{1}, x_{2}\right\rangle</script></li><li>多项式核函数<script type="math/tex; mode=display">K(x, z)=(x \cdot z+1)^{p}</script></li><li>高斯核函数<script type="math/tex; mode=display">K(x, z)=\exp \left(-\frac{\|x-z\|^{2}}{2 \sigma^{2}}\right)</script></li><li>字符串核函数：详见李航统计学习方法</li></ul><h4 id="12-逻辑回归与线性回归的联系与区别"><a href="#12-逻辑回归与线性回归的联系与区别" class="headerlink" title="12.逻辑回归与线性回归的联系与区别"></a>12.逻辑回归与线性回归的联系与区别</h4><ul><li>联系：逻辑回归和线性回归首先都是广义的线性回归；逻辑回归的模型本质上是一个对数线性回归模型，逻辑回归都是以线性回归为理论支持的。但线性回归模型无法做到sigmoid的非线性形式，sigmoid可以轻松处理0/1分类问题。</li><li>区别：<ul><li>线性模型的优化目标函数是最小二乘，而逻辑回归则是似然函数</li><li>线性回归在整个实数域范围内进行预测，敏感度一致；而分类范围，需要在[0,1]。逻辑回归就是一种减小预测范围，将预测值限定为[0,1]间的一种回归模型，因而对于这类问题来说，逻辑回归的鲁棒性比线性回归的要好。</li></ul></li></ul><h4 id="13-XGBoost为什么要用泰勒公式展开，优势在哪"><a href="#13-XGBoost为什么要用泰勒公式展开，优势在哪" class="headerlink" title="13.XGBoost为什么要用泰勒公式展开，优势在哪?"></a>13.XGBoost为什么要用泰勒公式展开，优势在哪?</h4><ul><li>XGBoost使用了一阶和二阶偏导, 二阶导数有利于梯度下降的更快更准。使用泰勒展开取得二阶倒数形式, 可以在不选定损失函数具体形式的情况下用于算法优化分析.本质上也就把损失函数的选取和模型算法优化和参数选择分开了，这种去耦合增加了XGBoost的适用性。</li></ul><h4 id="14-XGBoost如何寻找最优特征？是有放回还是无放回？"><a href="#14-XGBoost如何寻找最优特征？是有放回还是无放回？" class="headerlink" title="14.XGBoost如何寻找最优特征？是有放回还是无放回？"></a>14.XGBoost如何寻找最优特征？是有放回还是无放回？</h4><ul><li>XGBoost在训练过程中给各个特征的增益评分，最大增益的特征会被选出来作为分裂的依据，从而记忆了每个特征对在模型训练时的重要性。XGBoost属于boosting的集成学习方法，样本是无放回的，因此每轮计算样本不重复。XGBoost支持子采样，即每轮计算不使用全部样本，以减少过拟合。</li></ul><h4 id="15-决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？"><a href="#15-决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？" class="headerlink" title="15.决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？"></a>15.决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？</h4><ul><li>bagging与boosting的区别：<ul><li>bagging方法有放回的采样相同数量样本训练学习器，然后再一起投票。学习器之间不存在强的依赖关系，学习器可以并行训练生成。集成方式一般为投票法。随机森林属于Bagging的代表，放回抽样，每个学习器随机选择部分特征去优化。</li><li>Boosting方法使用全部样本，依次训练每个学习器，迭代集成。学习器之间不存在强依赖关系，学习器可并行训练生成，集成方式为加权和；Adaboost属于Boosting，采用指数损失函数代替原本分类任务中的0-1损失函数；GBDT属于Boosting的优秀代表，对函数残差近似值进行梯度下降，用CRAT树作为基本的学习器，集成模型为回归模型。XGBoost属于Boosting的集大成者，对函数残差近似值进行梯度下降，迭代时利用二阶梯度信息，集成模型可用于分类也可以用于回归。</li></ul></li><li>决策树的学习过程：从根开始建立树，也就是如何选择特征进行分裂。ID3算法使用信息增益、C4.5使用信息增益比、CART树采用基尼系数计算最优分类点，XGBoost使用二阶泰勒展开系数计算最优分裂点。</li></ul><h4 id="16-GBDT与XGBoost的对比，XGBoost的优点"><a href="#16-GBDT与XGBoost的对比，XGBoost的优点" class="headerlink" title="16.GBDT与XGBoost的对比，XGBoost的优点"></a>16.GBDT与XGBoost的对比，XGBoost的优点</h4><ul><li>损失函数用泰勒展开二项逼近，而不是像GBDT中用的就是一阶导数</li><li>对树的结构进行了正则化约束，防止模型过于复杂，降低了过拟合的可能性</li><li>节点的分裂方式不同，GBDT使用的是基尼系数，XGBoost使用的是经过优化推导后的算法(穷举法选择最佳的分裂节点、通过加权分位数方法近似选择最佳的分裂节点、针对稀疏特征的分裂点选择法)</li></ul><h4 id="17-L1和L2范数的区别"><a href="#17-L1和L2范数的区别" class="headerlink" title="17.L1和L2范数的区别"></a>17.L1和L2范数的区别</h4><ul><li>L1 norm:向量中各个元素绝对值之和，也称为稀疏规则算子，L1范数可以使权重稀疏，方便特征提取；L1正则化先验服从拉普拉斯分布</li><li>L2 norm:向量中各个元素平方和的1/2次方，又称为Frobenius范数，L2范数可以防止过拟合，提升模型的泛化能力；L2正则化先验服从高斯分布</li></ul><h4 id="18-阐述Adaboost算法的流程，并写出权重更新的公式"><a href="#18-阐述Adaboost算法的流程，并写出权重更新的公式" class="headerlink" title="18.阐述Adaboost算法的流程，并写出权重更新的公式"></a>18.阐述Adaboost算法的流程，并写出权重更新的公式</h4><ul><li><a href="https://www.jianshu.com/p/aae31290189e" target="_blank" rel="noopener">详细原理</a></li></ul><h4 id="19-LSTM的结构推导，为什么比普通的RNN好？"><a href="#19-LSTM的结构推导，为什么比普通的RNN好？" class="headerlink" title="19.LSTM的结构推导，为什么比普通的RNN好？"></a>19.LSTM的结构推导，为什么比普通的RNN好？</h4><ul><li><a href="https://www.jianshu.com/p/7c429d049b09" target="_blank" rel="noopener">详细原理</a></li></ul><h4 id="20-为什么朴素贝叶斯算法如此朴素？"><a href="#20-为什么朴素贝叶斯算法如此朴素？" class="headerlink" title="20.为什么朴素贝叶斯算法如此朴素？"></a>20.为什么朴素贝叶斯算法如此朴素？</h4><ul><li>因为它假设所有的特征在数据集中的作用都是同样重要的，而且相互独立的。这个假设在现实中基本上是不存在的，但特征相关性很小的实际情况还很多，岁月这个模型还可以工作的很好。</li></ul><h4 id="21-EM算法原理说明"><a href="#21-EM算法原理说明" class="headerlink" title="21.EM算法原理说明"></a>21.EM算法原理说明</h4><ul><li>有时候样本的产生和隐含变量有关(隐变量是不能观察的)，而求模型的参数时一般都采用极大似然估计，由于含有隐变量，所以对似然函数的参数求导数是求不出来的，这时候用EM算法来求模型的参数，典型的用法是用在GMM和HMM中。步骤如下：<ul><li>E步：选择一组参数，求出在此参数下隐变量的条件概率值<script type="math/tex; mode=display">  Q_{i}\left(z^{(i)}\right) :=p\left(z^{(i)} | x^{(i)} ; \theta\right)</script></li><li>M步：结合E步求出的隐变量的条件概率值，求出似然函数的下界函数(即某个期望函数)最大值。<script type="math/tex; mode=display">  \theta :=\arg \max _{\theta} \sum_{i} \sum_{z^{(i)}} Q_{i}\left(z^{(i)}\right) \log \frac{p\left(x^{(i)}, z^{(i)} ; \theta\right)}{Q_{i}\left(z^{(i)}\right)}</script></li><li>重复进行上面的两步，直至收敛为止。</li></ul></li><li>M步中下界函数的推导过程：<script type="math/tex; mode=display">\begin{aligned} \sum_{i} \log p\left(x^{(i)} ; \theta\right) &=\sum_{i} \log \sum_{z^{(i)}} p\left(x^{(i)}, z^{(i)} ; \theta\right) \\ &=\sum_{i} \log \sum_{z^{(i)}} Q_{i}\left(z^{(i)}\right) \frac{p\left(x^{(i)}, z^{(i)} ; \theta\right)}{Q_{i}\left(z^{(i)}\right)} \\ & \geq \sum_{i} \sum_{z^{(i)}} Q_{i}\left(z^{(i)}\right) \log \frac{p\left(x^{(i)}, z^{(i)} ; \theta\right)}{Q_{i}\left(z^{(i)}\right)} \end{aligned}</script></li></ul><h4 id="22-GMM算法原理说明"><a href="#22-GMM算法原理说明" class="headerlink" title="22.GMM算法原理说明"></a>22.GMM算法原理说明</h4><ul><li>EM算法的常用例子是高斯混合模型GMM，每个样本都有可能由K个高斯模型产生，只不过每个高斯模型的产生概率不同，因此每个样本都有对应的高斯分布(K个模型中的一个)，此时的隐变量就是每个样本对应的某个高斯分布。<ul><li>GMM算法的E步(计算每个样本对应每个高斯模型的概率)<script type="math/tex; mode=display">  w_{j}^{(i)} :=p\left(z^{(i)}=j | x^{(i)} ; \phi, \mu, \Sigma\right)</script>具体的计算公式为：<script type="math/tex; mode=display">  p\left(z^{(i)}=j | x^{(i)} ; \phi, \mu, \Sigma\right)=\frac{p\left(x^{(i)} | z^{(i)}=j ; \mu, \Sigma\right) p\left(z^{(i)}=j ; \phi\right)}{\sum_{l=1}^{k} p\left(x^{(i)} | z^{(i)}=l ; \mu, \Sigma\right) p\left(z^{(i)}=l ; \phi\right)}</script></li><li>M步计算公式(计算每个高斯模型的权重，均值，方差3个参数)：<script type="math/tex; mode=display">  \begin{aligned} \phi_{j} & :=\frac{1}{m} \sum_{i=1}^{m} w_{j}^{(i)} \\ \mu_{j} & :=\frac{\sum_{i=1}^{m} w_{j}^{(i)} x^{(i)}}{\sum_{i=1}^{m} w_{j}^{(i)}} \\ \Sigma_{j} & :=\frac{\sum_{i=1}^{m} w_{j}^{(i)}\left(x^{(i)}-\mu_{j}\right)\left(x^{(i)}-\mu_{j}\right)^{T}}{\sum_{i=1}^{m} w_{j}^{(i)}} \end{aligned}</script></li></ul></li></ul><h4 id="23-KNN算法中K是如何选择的"><a href="#23-KNN算法中K是如何选择的" class="headerlink" title="23.KNN算法中K是如何选择的?"></a>23.KNN算法中K是如何选择的?</h4><ul><li>如果选择较小的K值，就相当于用较小的邻域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大。换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；</li><li>如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。</li><li>K=N，此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的累，模型过于简单，忽略了训练实例中大量有用信息。</li><li>实际中，使用交叉验证的方法选择最优的K的取值。</li></ul><h4 id="24-机器学习中，为什么经常需要对数据进行归一化？"><a href="#24-机器学习中，为什么经常需要对数据进行归一化？" class="headerlink" title="24.机器学习中，为什么经常需要对数据进行归一化？"></a>24.机器学习中，为什么经常需要对数据进行归一化？</h4><ul><li>归一化能提高梯度下降算法求解的速度</li><li>归一化有可能提高精度</li></ul><h4 id="25-神经网络中的批量归一化Batch-Normalization-BN-原理"><a href="#25-神经网络中的批量归一化Batch-Normalization-BN-原理" class="headerlink" title="25.神经网络中的批量归一化Batch Normalization(BN)原理"></a>25.神经网络中的批量归一化Batch Normalization(BN)原理</h4><ul><li><a href="https://blog.csdn.net/cdlwhm1217096231/article/details/95391398" target="_blank" rel="noopener">详细原理</a></li></ul><h4 id="26-哪些机器学习算法不需要进行归一化操作？"><a href="#26-哪些机器学习算法不需要进行归一化操作？" class="headerlink" title="26.哪些机器学习算法不需要进行归一化操作？"></a>26.哪些机器学习算法不需要进行归一化操作？</h4><ul><li>概率模型不需要做归一化操作，因为它们不关心变量的值，而关心的是变量分布和变量之间的条件概率，如决策树。但是，像Adaboost、SVM、LR、KNN、Kmeans等最优化问题就需要归一化。</li></ul><h4 id="27-为什么树形结构不需要归一化？"><a href="#27-为什么树形结构不需要归一化？" class="headerlink" title="27.为什么树形结构不需要归一化？"></a>27.为什么树形结构不需要归一化？</h4><ul><li>数值缩放，不影响分裂点位置。因为第一步都是按照特征值进行排序的，排序的顺序不变，那么所属的分支以及分裂点就不会变。对于线性模型，比如说LR，假设有两个特征，一个是(0,1)的，一个是(0,10000)的，这样运用梯度下降时候，损失等高线是一个椭圆的形状，这样想迭代到最优点，就需要很多次迭代，但是如果进行了归一化，那么等高线就是圆形的，那么SGD就会往原点迭代，需要的迭代次数较少。另外，注意树模型是不能进行梯度下降的，因为树模型是阶跃的，阶跃点是不可导的，并且求导没意义，所以树模型（回归树）寻找最优点是通过寻找最优分裂点完成的。</li></ul><h4 id="28-一个完整机器学习项目的流程"><a href="#28-一个完整机器学习项目的流程" class="headerlink" title="28.一个完整机器学习项目的流程"></a>28.一个完整机器学习项目的流程</h4><ul><li>抽象成数学问题、获取数据、特征预处理与特征选择、训练模型与调优、模型诊断、模型融合、上线运行</li></ul><h4 id="29-条件随机场CRF模型相对于HMM模型-隐马尔科夫模型-和MEMM模型-最大熵隐马尔科夫模型-的优势。"><a href="#29-条件随机场CRF模型相对于HMM模型-隐马尔科夫模型-和MEMM模型-最大熵隐马尔科夫模型-的优势。" class="headerlink" title="29.条件随机场CRF模型相对于HMM模型(隐马尔科夫模型)和MEMM模型(最大熵隐马尔科夫模型)的优势。"></a>29.条件随机场CRF模型相对于HMM模型(隐马尔科夫模型)和MEMM模型(最大熵隐马尔科夫模型)的优势。</h4><ul><li>HMM模型中一个最大的缺点即其输出独立性假设，由于输出独立性假设的缺点导致HMM模型不能考虑上下文的特征，限制了特征的选择。</li><li>MEMM模型则解决了HMM模型的最大的缺点，可以任意选择特征，但是由于其每一个节点都要进行归一化，所以只能找到局部最优值。同时，也带来了标记偏见的问题即凡是在训练语料库中未出现的情况都被忽略掉了。CRF模型很好的解决了这个问题，它并不在每一节点进行归一化，而是所有特征进行全局归一化，因此可以求出全局的最优值。</li></ul><h4 id="30-什么是熵？"><a href="#30-什么是熵？" class="headerlink" title="30.什么是熵？"></a>30.什么是熵？</h4><ul><li>熵的定义：离散随机事件的出现概率。一个系统越是有序，信息熵就越低。信息熵可以被认为是系统有序化程度的一个度量。</li></ul><h4 id="31-BP反向传播算法推导及python实现"><a href="#31-BP反向传播算法推导及python实现" class="headerlink" title="31.BP反向传播算法推导及python实现"></a>31.BP反向传播算法推导及python实现</h4><p><img src="https://upload-images.jianshu.io/upload_images/13407176-4e2c5d2d7e253c9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-bc9a950264c79a8c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-d451c71b72960fc2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p><ul><li>python代码实现：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">import numpy <span class="keyword">as</span> np</span><br><span class="line">import matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">class MLP():</span><br><span class="line">    def __init__(<span class="keyword">self</span>, name=<span class="symbol">'nn</span>', layer_structure=[], task_model=<span class="literal">None</span>, batch_size=<span class="number">1</span>, load_model=<span class="literal">None</span>):</span><br><span class="line">        <span class="string">""</span><span class="string">"layer_number : 神经网络的层数</span></span><br><span class="line"><span class="string">           layer_structure = [输入的特征个数，第1层神经元个数，第2层神经元个数，...，最后一层神经元个数输出层特征个数]，</span></span><br><span class="line"><span class="string">           如网络层数设为layer_number=3, layer_structure=[20,10,5,1]：输入特征是20个，第一层有10个神经元，第二层5个，第三层1个.</span></span><br><span class="line"><span class="string">           output_model = 'regression'/'logistic'</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.layer_number = len(layer_structure) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.layer_structure = layer_structure</span><br><span class="line">        <span class="keyword">self</span>.task_model = task_model</span><br><span class="line">        <span class="keyword">self</span>.W = []</span><br><span class="line">        <span class="keyword">self</span>.B = []</span><br><span class="line">        <span class="keyword">self</span>.batch_size = batch_size</span><br><span class="line">        <span class="keyword">self</span>.total_loss = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.task_model == <span class="symbol">'logistic</span>' or <span class="keyword">self</span>.task_model == <span class="symbol">'multi</span>':</span><br><span class="line">            <span class="keyword">self</span>.total_accuracy = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> load_model == <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">"Initializing the network from scratch ..."</span>)</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">                <span class="keyword">self</span>.W.append(np.random.randn(<span class="keyword">self</span>.layer_structure[index], <span class="keyword">self</span>.layer_structure[index+<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">self</span>.B.append(np.random.randn(<span class="number">1</span>, <span class="keyword">self</span>.layer_structure[index+<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Initializing the network from trained model ..."</span>)</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">                <span class="keyword">self</span>.W.append(np.loadtxt(load_model + <span class="keyword">self</span>.name + <span class="string">"_layer_"</span> + <span class="built_in">str</span>(index) + <span class="string">"_W.txt"</span>).reshape(<span class="keyword">self</span>.layer_structure[index], <span class="keyword">self</span>.layer_structure[index+<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">self</span>.B.append(np.loadtxt(load_model + <span class="keyword">self</span>.name + <span class="string">"_layer_"</span> + <span class="built_in">str</span>(index) + <span class="string">"_B.txt"</span>).reshape(<span class="number">1</span>, <span class="keyword">self</span>.layer_structure[index+<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    def normal_parameters(<span class="keyword">self</span>, means, sigmas):</span><br><span class="line">        <span class="keyword">self</span>.means = means</span><br><span class="line">        <span class="keyword">self</span>.sigams = sigmas</span><br><span class="line"></span><br><span class="line">    def sigmoid(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line">    def sigmoid_gradient(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.sigmoid(x)*(<span class="number">1</span>-<span class="keyword">self</span>.sigmoid(x))</span><br><span class="line"></span><br><span class="line">    def softmax(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="keyword">return</span> np.exp(x)/np.sum(np.exp(x), axis = <span class="number">1</span>, keepdims = True)</span><br><span class="line"></span><br><span class="line">    def forward(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            intput : x = [batch_size, features]</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">self</span>.before_activation = []</span><br><span class="line">        <span class="keyword">self</span>.activations = [x]</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">            <span class="keyword">if</span> index &lt; <span class="keyword">self</span>.layer_number - <span class="number">1</span>:</span><br><span class="line">                Z = np.dot(<span class="keyword">self</span>.activations[index], <span class="keyword">self</span>.W[index]) + <span class="keyword">self</span>.B[index]</span><br><span class="line">                <span class="keyword">self</span>.before_activation.append(Z)</span><br><span class="line">                <span class="keyword">self</span>.activations.append(<span class="keyword">self</span>.sigmoid(Z))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.task_model == <span class="symbol">'logistic</span>':</span><br><span class="line">                    Z = np.dot(<span class="keyword">self</span>.activations[index], <span class="keyword">self</span>.W[index]) + <span class="keyword">self</span>.B[index]</span><br><span class="line">                    <span class="keyword">self</span>.before_activation.append(Z)</span><br><span class="line">                    <span class="keyword">self</span>.activations.append(<span class="keyword">self</span>.sigmoid(Z))</span><br><span class="line">                elif <span class="keyword">self</span>.task_model == <span class="symbol">'regression</span>':</span><br><span class="line">                    Z = np.dot(<span class="keyword">self</span>.activations[index], <span class="keyword">self</span>.W[index]) + <span class="keyword">self</span>.B[index]</span><br><span class="line">                    <span class="keyword">self</span>.before_activation.append(Z)</span><br><span class="line">                    <span class="keyword">self</span>.activations.append(Z)</span><br><span class="line">                elif <span class="keyword">self</span>.task_model == <span class="symbol">'multi</span>':</span><br><span class="line">                    Z = np.dot(<span class="keyword">self</span>.activations[index], <span class="keyword">self</span>.W[index]) + <span class="keyword">self</span>.B[index]</span><br><span class="line">                    <span class="keyword">self</span>.before_activation.append(Z)</span><br><span class="line">                    <span class="keyword">self</span>.activations.append(<span class="keyword">self</span>.softmax(Z))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.activations[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    def __call__(<span class="keyword">self</span>, x):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.forward(x)</span><br><span class="line"></span><br><span class="line">    def lossfunction(<span class="keyword">self</span>, inputs, target):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.task_model == <span class="symbol">'regression</span>':</span><br><span class="line">            <span class="keyword">return</span>(np.mean(np.sum((inputs - target)**<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line">        elif <span class="keyword">self</span>.task_model == <span class="symbol">'logistic</span>':</span><br><span class="line">            <span class="keyword">return</span> np.mean(np.sum(-target*np.log(inputs+<span class="number">1e-14</span>) - (<span class="number">1</span>-target)*np.log(<span class="number">1</span>-inputs+<span class="number">1e-14</span>), <span class="number">1</span>))</span><br><span class="line">        elif <span class="keyword">self</span>.task_model == <span class="symbol">'multi</span>':</span><br><span class="line">            <span class="keyword">return</span> np.mean(np.sum(-target*np.log(inputs+<span class="number">1e-14</span>), <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    def back_forward(<span class="keyword">self</span>, targets=<span class="literal">None</span>, loss=<span class="literal">None</span>, regularization=False):</span><br><span class="line">        <span class="keyword">self</span>.dWs = []</span><br><span class="line">        <span class="keyword">self</span>.dBs = []</span><br><span class="line">        <span class="keyword">self</span>.dAs = []</span><br><span class="line">        W_reverse = <span class="keyword">self</span>.W[::-<span class="number">1</span>]</span><br><span class="line">        activations_reverse = <span class="keyword">self</span>.activations[::-<span class="number">1</span>]</span><br><span class="line">        before_activation_reverse = <span class="keyword">self</span>.before_activation[::-<span class="number">1</span>]</span><br><span class="line">        # 从最后一层开始往回传播</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>):</span><br><span class="line">                <span class="keyword">if</span> loss == <span class="symbol">'MSE</span>' or loss == <span class="symbol">'CE</span>' or loss == <span class="symbol">'BE</span>':</span><br><span class="line">                    dZ = activations_reverse[k] - targets</span><br><span class="line">                    dW = <span class="number">1</span>/<span class="keyword">self</span>.batch_size*np.dot(activations_reverse[k+<span class="number">1</span>].T, dZ)</span><br><span class="line">                    dB = <span class="number">1</span>/<span class="keyword">self</span>.batch_size*np.sum(dZ, axis = <span class="number">0</span>, keepdims = True)</span><br><span class="line">                    dA_before = np.dot(dZ, W_reverse[k].T)</span><br><span class="line">                    <span class="keyword">self</span>.dWs.append(dW)</span><br><span class="line">                    <span class="keyword">self</span>.dBs.append(dB)</span><br><span class="line">                    <span class="keyword">self</span>.dAs.append(dA_before)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dZ = <span class="keyword">self</span>.dAs[k-<span class="number">1</span>]*<span class="keyword">self</span>.sigmoid_gradient(before_activation_reverse[k])</span><br><span class="line">                dW = <span class="number">1</span>/<span class="keyword">self</span>.batch_size*np.dot(activations_reverse[k+<span class="number">1</span>].T,dZ)</span><br><span class="line">                dB = <span class="number">1</span>/<span class="keyword">self</span>.batch_size*np.sum(dZ, axis = <span class="number">0</span>, keepdims = True)</span><br><span class="line">                dA_before = np.dot(dZ, W_reverse[k].T)</span><br><span class="line">                <span class="keyword">self</span>.dWs.append(dW)</span><br><span class="line">                <span class="keyword">self</span>.dBs.append(dB)</span><br><span class="line">                <span class="keyword">self</span>.dAs.append(dA_before)</span><br><span class="line">        <span class="keyword">self</span>.dWs = <span class="keyword">self</span>.dWs[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">self</span>.dBs = <span class="keyword">self</span>.dBs[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    def steps(<span class="keyword">self</span>, lr=<span class="number">0.001</span>, lr_decay=False):</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(<span class="keyword">self</span>.dWs)):</span><br><span class="line">            <span class="keyword">self</span>.W[index] -= lr*<span class="keyword">self</span>.dWs[index]</span><br><span class="line">            <span class="keyword">self</span>.B[index] -= lr*<span class="keyword">self</span>.dBs[index]</span><br><span class="line"></span><br><span class="line">    def train(<span class="keyword">self</span>, train_datas=<span class="literal">None</span>, train_targets=<span class="literal">None</span>, train_epoch=<span class="number">1</span>, lr=<span class="number">0.001</span>, lr_decay=False, loss=<span class="symbol">'MSE</span>', regularization=False, display=False):</span><br><span class="line">        train_counts = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(train_epoch):</span><br><span class="line">            <span class="keyword">if</span> epoch == int(train_epoch * <span class="number">0.7</span>) and lr_decay == True:</span><br><span class="line">                lr *= <span class="number">0.1</span></span><br><span class="line">            train_steps = train_datas.shape[<span class="number">0</span>] <span class="comment">// self.batch_size</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(train_steps):</span><br><span class="line">                input_data = train_datas[<span class="keyword">self</span>.batch_size*i : <span class="keyword">self</span>.batch_size*(i+<span class="number">1</span>), :].reshape(<span class="keyword">self</span>.batch_size, train_datas.shape[<span class="number">1</span>])</span><br><span class="line">                targets = train_targets[<span class="keyword">self</span>.batch_size*i : <span class="keyword">self</span>.batch_size*(i+<span class="number">1</span>), :].reshape(<span class="keyword">self</span>.batch_size, train_targets.shape[<span class="number">1</span>])</span><br><span class="line">                prediction = <span class="keyword">self</span>.forward(input_data)</span><br><span class="line">                forward_loss = <span class="keyword">self</span>.lossfunction(prediction, targets)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.task_model==<span class="symbol">'logistic</span>':</span><br><span class="line">                    accuracy = np.sum((prediction&gt;<span class="number">0.6</span>) == targets) / targets.shape[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">self</span>.total_accuracy.append(accuracy)</span><br><span class="line">                elif <span class="keyword">self</span>.task_model==<span class="symbol">'multi</span>':</span><br><span class="line">                    accuracy = np.sum(np.argmax(prediction,<span class="number">1</span>) == np.argmax(targets,<span class="number">1</span>)) / targets.shape[<span class="number">0</span>]</span><br><span class="line">                    <span class="keyword">self</span>.total_accuracy.append(accuracy)</span><br><span class="line">                <span class="keyword">self</span>.total_loss.append(forward_loss)</span><br><span class="line">                <span class="keyword">if</span> display:</span><br><span class="line">                    <span class="keyword">if</span> train_counts % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">self</span>.task_model == <span class="symbol">'logistic</span>' or <span class="keyword">self</span>.task_model == <span class="symbol">'multi</span>':</span><br><span class="line">                            print(<span class="string">"After "</span> + <span class="built_in">str</span>(train_counts) + <span class="string">", loss is "</span>, forward_loss,</span><br><span class="line">                            <span class="string">", accuracy is "</span>, accuracy)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            print(<span class="string">"After "</span> + <span class="built_in">str</span>(train_counts) + <span class="string">", loss is "</span>, forward_loss)</span><br><span class="line">                <span class="keyword">self</span>.back_forward(targets=targets, loss=loss, regularization=regularization)</span><br><span class="line">                <span class="keyword">self</span>.steps(lr=lr, lr_decay=lr_decay)</span><br><span class="line">                train_counts += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    def save_model(<span class="keyword">self</span>, path):</span><br><span class="line">        print(<span class="string">"Saving the "</span> + <span class="keyword">self</span>.name + <span class="string">" model ..."</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="keyword">self</span>.layer_number):</span><br><span class="line">            np.savetxt(path  + <span class="keyword">self</span>.name + <span class="string">"_layer_"</span> + <span class="built_in">str</span>(i) + <span class="string">"_W.txt"</span>, <span class="keyword">self</span>.W[i])</span><br><span class="line">            np.savetxt(path  + <span class="keyword">self</span>.name + <span class="string">"_layer_"</span> + <span class="built_in">str</span>(i) + <span class="string">"_B.txt"</span>, <span class="keyword">self</span>.B[i])</span><br><span class="line">        print(<span class="string">"Model saved !!!"</span>)</span><br></pre></td></tr></table></figure></li></ul><h4 id="32-K-Means算法的原理"><a href="#32-K-Means算法的原理" class="headerlink" title="32.K_Means算法的原理"></a>32.K_Means算法的原理</h4><ul><li>聚类算法综述：聚类算法是一种无监督学习算法，它是将相似的对象归到同一个簇中。K均值算法中的K可以理解用户想要聚类成K个不同的簇，K是一个用户可以自行定义的超参数。</li><li>K均值聚类的优缺点：<ul><li>优点：容易实现</li><li>缺点：可能收敛到局部最小值，在大规模的数据上收敛慢</li><li>适用场合：数值型数据</li></ul></li><li>K_Means算法的基本流程：<ul><li>1.随机选择K个点作为起始的聚类中心</li><li>2.遍历每个样本，计算每个样本到K个聚类中心的距离，找出”距离”聚类中心最近的样本，并将此样本聚集到离它最近的那一个簇中。<strong>注：K_Means算法的性能会受到所选距离计算方法的影响</strong>。</li><li>3.所有样本都聚集到K个簇完成后，计算K个簇的均值，并将聚类中心移动到K个簇的均值处作为新的聚类中心。</li><li>4.重复上述步骤2~3，直到最大迭代次数就停止。</li></ul></li><li><strong>K_Means算法的优化(为了克服收敛于局部最小值提出)</strong>：如何知道生成的簇比较好？一种用来衡量K_Means算法聚类效果的指标是SSE误差平方和(预测数据与原始数据之间误差的平方和),SSE越小表示样本点越接近于聚类中心点，聚类效果越好。<strong>因为对误差取了平方，因此更加重视那些远离聚类中心的点(未理解)</strong>。降低SSE值的方法是增加簇的个数，但是簇的个数K在算法一开始运行时就固定了，不能改变。聚类的目标是在保持原有簇数目不变的条件下，提高簇的质量。<strong>常用思想是：对生成的簇进行后处理，将具有最大SSE值的簇划分成两个簇。为了保持簇的总数不变，可以将某两个簇进行合并</strong>。可以有下面两种方法合并：<ul><li>1.合并最近的聚类中心：计算所有聚类中心之间的距离，合并距离最近的两个聚类中心点。</li><li>2.合并两个使得SSE增加最小的聚类中心：合并两个簇，然后计算总的SSE。必须在所有可能的两个簇上重复上述处理过程，直到找到合并最佳的两个簇。</li></ul></li></ul><h4 id="33-常见的距离函数总结"><a href="#33-常见的距离函数总结" class="headerlink" title="33.常见的距离函数总结"></a>33.常见的距离函数总结</h4><ul><li>闵可夫斯基距离：给定样本$\overrightarrow{\mathbf{x}}<em>{i}=\left(x</em>{i, 1}, x<em>{i, 2}, \cdots, x</em>{i, n}\right)^{T}$,$\overrightarrow{\mathbf{x}}<em>{j}=\left(x</em>{j, 1}, x<em>{j, 2}, \cdots, x</em>{j, n}\right)^{T}$，则闵可夫斯基距离定义为：<script type="math/tex; mode=display">\text { distance( }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left(\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{p}\right)^{1 / p}</script></li><li>当p=2时，闵可夫斯基距离就是<strong>欧式距离</strong>：<script type="math/tex; mode=display">\operatorname{distance}\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{2}=\sqrt{\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{2}}</script></li><li>当p=1时，闵可夫斯基距离就是<strong>曼哈顿距离</strong>：<script type="math/tex; mode=display">\text { distance }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{1}=\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|</script></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-参考博客&quot;&gt;&lt;a href=&quot;#1-参考博客&quot; class=&quot;headerlink&quot; title=&quot;1.参考博客&quot;&gt;&lt;/a&gt;1.参考博客&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nowcoder.com/ta/review-ml?q
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点总结</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/操作系统/操作系统知识点总结/</id>
    <published>2019-07-30T13:11:15.000Z</published>
    <updated>2019-08-08T09:07:39.906Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h4><ul><li>对于有线程系统：<ul><li>进程是资源分配的独立单位</li><li>线程是资源调度的独立单位</li></ul></li><li>对无无线程系统：<ul><li>进程是资源调度、分配的独立单位</li></ul></li></ul><h4 id="2-进程间的通信方式及优缺点"><a href="#2-进程间的通信方式及优缺点" class="headerlink" title="2.进程间的通信方式及优缺点"></a>2.进程间的通信方式及优缺点</h4><ul><li><strong>管道</strong><ul><li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信。<ul><li>优点：可以实现任意关系的进程间的通信</li><li>缺点：<ul><li>a.长期存于系统中，使用不当容易出错</li><li>b.缓冲区有限</li></ul></li></ul></li><li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul><li>优点：简单方便</li><li>缺点：<ul><li>a.局限于单向通信</li><li>b.只能创建在它的进程以及其有亲缘关系的进程之间</li><li>c.缓冲区有限</li></ul></li></ul></li></ul></li><li><strong>信号量</strong>：一个计数器，可以用来控制多个线程对共享资源的访问<ul><li>优点：可以同步进程</li><li>缺点：信号量有限</li></ul></li><li><strong>信号</strong>: 一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li><li><strong>消息队列</strong>: 是消息的链表，存放在内核中并由消息队列标识符标识<ul><li>优点： 可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li><li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li></ul></li><li><strong>共享内存</strong>：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul><li>优点：无须复制，快捷，信息量大</li><li>缺点：<ul><li>a.通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li><li>b.利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li></ul></li></ul></li><li><strong>套接字</strong>：可用于不同及其间的进程通信<ul><li>优点：<ul><li>a.传输数据为字节级，传输数据可自定义，数据量小效率高</li><li>b.传输数据时间短，性能高</li><li>c.适合于客户端和服务器端之间信息实时交互</li><li>d.可以加密,数据安全性强</li></ul></li><li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li></ul></li></ul><h4 id="3-线程之间的通信方式"><a href="#3-线程之间的通信方式" class="headerlink" title="3.线程之间的通信方式"></a>3.线程之间的通信方式</h4><ul><li><strong>锁机制</strong>：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul><li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>自旋锁（spin lock）：与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li><li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li><strong>信号量机制</strong><ul><li>无名线程信号量</li><li>有名线程信号量</li></ul></li><li><strong>信号机制(Signal)</strong>：类似进程间的信号处理</li><li><strong>屏障</strong>：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li></ul><h4 id="4-进程之间私有和共享的资源"><a href="#4-进程之间私有和共享的资源" class="headerlink" title="4.进程之间私有和共享的资源"></a>4.进程之间私有和共享的资源</h4><ul><li>私有：地址空间、堆、全局变量、栈、寄存器</li><li>共享：代码段，公共数据，进程目录，进程 ID</li></ul><h4 id="5-线程之间私有和共享的资源"><a href="#5-线程之间私有和共享的资源" class="headerlink" title="5.线程之间私有和共享的资源"></a>5.线程之间私有和共享的资源</h4><ul><li>私有：线程栈，寄存器，程序寄存器</li><li>共享：堆，地址空间，全局变量，静态变量</li></ul><h4 id="6-多进程与多线程间的对比、优劣与选择"><a href="#6-多进程与多线程间的对比、优劣与选择" class="headerlink" title="6.多进程与多线程间的对比、优劣与选择"></a>6.多进程与多线程间的对比、优劣与选择</h4><p><img src="https://upload-images.jianshu.io/upload_images/13407176-f1d727410790e1b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="特点对比.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-c113b6d4576c9f27.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优缺点对比.jpg"></p><ul><li>线程与进程选用规则：<ul><li>需要频繁创建销毁的优先用线程</li><li>需要进行大量计算的优先使用线程</li><li>强相关的处理用线程，弱相关的处理用进程</li><li>可能要扩展到多机分布的用进程，多核分布的用线程</li><li>都满足需求的情况下，用你最熟悉、最拿手的方式</li></ul></li></ul><h4 id="7-Linux的内核同步方式"><a href="#7-Linux的内核同步方式" class="headerlink" title="7.Linux的内核同步方式"></a>7.Linux的内核同步方式</h4><ul><li><strong>为什么需要内核同步？</strong>：在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程、多线程编程一样也需要一些同步机制来同步<strong>各执行单元对共享数据的访问</strong>。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</li><li><strong>内核同步方式</strong>:<ul><li>原子操作</li><li>信号量（semaphore）</li><li>读写信号量（rw_semaphore）</li><li>自旋锁（spinlock）</li><li>大内核锁（BKL，Big Kernel Lock）</li><li>读写锁（rwlock）</li><li>大读者锁（brlock-Big Reader Lock）</li><li>读-拷贝修改(RCU，Read-Copy Update)</li><li>顺序锁（seqlock）</li></ul></li></ul><h4 id="8-死锁"><a href="#8-死锁" class="headerlink" title="8.死锁"></a>8.死锁</h4><ul><li>定义：<strong>是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。</strong></li><li><strong>死锁产生的条件</strong>：<ul><li>互斥</li><li>请求和保持</li><li>不可剥夺</li><li>环路等待</li></ul></li><li><strong>预防死锁</strong>：<ul><li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li><li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li><li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li><li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li><li>有序资源分配法</li><li><a href="https://blog.csdn.net/jgm20475/article/details/81265947" target="_blank" rel="noopener">银行家算法</a></li></ul></li></ul><h4 id="9-页面置换算法"><a href="#9-页面置换算法" class="headerlink" title="9.页面置换算法"></a>9.页面置换算法</h4><ul><li><strong>页面置换</strong>：在地址映射过程中，如果在页面中发现所要访问的页面不存在于内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</li><li><p><strong>分类</strong>：</p><ul><li>全局置换：在整个内存空间置换<ul><li>工作集算法</li><li>缺失率置换算法</li></ul></li><li><p>局部置换：在本进程中进行置换</p><ul><li>最佳置换算法(OPT)<ul><li>原理：从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 <a href="https://blog.csdn.net/jack450250844/article/details/84986690" target="_blank" rel="noopener">详见原理</a></li></ul></li><li><p>先进先出置换算法(FIFO)</p><ul><li>原理：该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老的页面。但该算法与进程实际运行的规律不相适应，因为在进程中，有些页面经常被访问，比如，含有全局变量、常用函数、例程等的页面，FIFO算法并不能保证这些页面不被淘汰。<a href="https://blog.csdn.net/jack450250844/article/details/85019950" target="_blank" rel="noopener">详见原理</a></li></ul></li><li><p>最近最久未使用算法(LRU)</p><ul><li>原理：根据页面调入内存后的使用情况做出决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有也面中t值最大的，即最近最久未使用的页面予以淘汰。<a href="https://blog.csdn.net/jack450250844/article/details/85019898" target="_blank" rel="noopener">详见原理</a></li></ul></li><li>时钟置换算法(Clock)<ul><li>原理：淘汰访问位为0的页框中的页面，被访问过的页面将其页框的访问位数值置1。<a href="https://blog.csdn.net/Long_H_Zhu/article/details/84184563" target="_blank" rel="noopener">详见原理</a></li></ul></li></ul></li><li>局部置换的三种算法C++代码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> page[] = &#123; <span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FIFO</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OPT</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RLU</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inArray</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    FIFO();</span><br><span class="line">    OPT();</span><br><span class="line">    RLU();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FIFO算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FIFO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">3</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"FIFO:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (page[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inArray(temp, <span class="number">3</span>, page[num])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            error++;</span><br><span class="line">            <span class="keyword">bool</span> hasChanged = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (time[i] == <span class="number">0</span> &amp;&amp; hasChanged == <span class="literal">false</span>) &#123;</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    hasChanged = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (time[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    time[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误率:"</span> &lt;&lt; error &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inArray</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == a[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OPT算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OPT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//OPT已知未来的页数为20</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"OPT:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (page[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = page[num];</span><br><span class="line">        <span class="keyword">if</span> (inArray(temp, <span class="number">3</span>, page[num])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            error++;</span><br><span class="line">            <span class="keyword">bool</span> fuck = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    fuck = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fuck == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> distance[<span class="number">3</span>] = &#123; <span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span> &#125;;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= num; i--) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (temp[j] == page[i] &amp;&amp; (i - num) &lt; distance[j]) &#123;</span><br><span class="line">                            distance[j] = i - num;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (max &lt; distance[i]) &#123;</span><br><span class="line">                        max = distance[i];</span><br><span class="line">                        k = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                temp[k] = page[num];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误率:"</span> &lt;&lt; error &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RLU算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RLU</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"RLU:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (page[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = page[num];</span><br><span class="line">        <span class="keyword">if</span> (inArray(temp, <span class="number">3</span>, page[num])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//bool Changed = false;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == page[num]) &#123;</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//Changed = true;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] != page[num]&amp;&amp;time[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">                    time[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            error++;</span><br><span class="line">            <span class="comment">//bool hasChange = false;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(time[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    time[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误率:"</span> &lt;&lt; error &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="10-进程状态转换图"><a href="#10-进程状态转换图" class="headerlink" title="10.进程状态转换图"></a>10.进程状态转换图</h4><p><img src="https://upload-images.jianshu.io/upload_images/13407176-2d3db5b8d56f27a8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程的五种基本状态"></p><ul><li>进程的五种基本状态：<ul><li>创建状态：进程正在被创建</li><li>就绪状态：进程被加入到就绪队列中等待CPU调度运行</li><li>执行状态：进程正在被运行</li><li>等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行</li><li>终止状态：进程运行完毕</li></ul></li></ul><h4 id="11-软链接和硬链接的区别"><a href="#11-软链接和硬链接的区别" class="headerlink" title="11.软链接和硬链接的区别"></a>11.软链接和硬链接的区别</h4><ul><li>软链接也叫符号链接，软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</li><li>硬链接：通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</li></ul><h4 id="12-协程"><a href="#12-协程" class="headerlink" title="12.协程"></a>12.协程</h4><ul><li><p>定义：又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。例如：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span> :</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'2'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'3'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span> :</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'x'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'y'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'z'</span></span><br></pre></td></tr></table></figure></li><li><p>上面协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。</p></li></ul><h4 id="13-协程与线程的区别"><a href="#13-协程与线程的区别" class="headerlink" title="13.协程与线程的区别"></a>13.协程与线程的区别</h4><ul><li>协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制。因此，没有线程切换的开销。协程和多线程相比，线程数量越多，协程的性能优势就越明显。</li><li>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突。在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li></ul><h4 id="14-进程同步的几种方式"><a href="#14-进程同步的几种方式" class="headerlink" title="14.进程同步的几种方式"></a>14.进程同步的几种方式</h4><ul><li><strong>信号量</strong>：用于进程间传递信号的一个整数值。</li><li>在信号量上只有三种操作可以进行：初始化、P操作、V操作，这三种操作都是原子操作。<strong>P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程</strong>。</li><li>原理：两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。该信号即为信号量s。为通过信号量s传送信号，进程可执行原语semSignal(s);为通过信号量s接收信号，进程可执行原语semWait(s);如果相应的信号仍然没有发送，则进程被阻塞，直到发送完为止。可把信号量视为一个具有整数值的变量，在它之上定义三个操作：<ul><li>一个信号量可以初始化为非负数；</li><li>semWait操作使信号量s减1.若值为负数，则执行semWait的进程被阻塞。否则进程继续执行；</li><li>semSignal操作使信号量加1，若值大于或等于零，则被semWait操作阻塞的进程被解除阻塞</li></ul></li><li><strong>管程</strong>：由一个或多个过程、一个初始化序列和局部数据组成的软件模块，其主要特点如下：<ul><li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问；</li><li>一个进程通过调用管程的一个过程进入管程；</li><li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用；</li></ul></li><li><strong>消息传递</strong>：是进程间进程消息传递所需要的最小操作集。一个进程以消息的形式给另一个指定的目标进程发送消息；进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。</li></ul><h4 id="15-线程同步的几种方式"><a href="#15-线程同步的几种方式" class="headerlink" title="15.线程同步的几种方式"></a>15.线程同步的几种方式</h4><ul><li><strong>临界区</strong>:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</li><li><strong>互斥量</strong>:采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。</li><li><strong>信号量</strong>:它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</li><li><strong>事件</strong>:通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。<h4 id="16-操作系统中程序的内存结构"><a href="#16-操作系统中程序的内存结构" class="headerlink" title="16.操作系统中程序的内存结构"></a>16.操作系统中程序的内存结构</h4><img src="https://upload-images.jianshu.io/upload_images/13407176-51b3576acab2510c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="操作系统中的内存结构"></li><li><strong>一个程序本质上都是由BSS段、数据段(data段)、text段(代码段)三个组成的</strong>。可以看到一个可执行程序在存储（没有调入内存）时分为代码段、数据区和未初始化数据区三部分。</li><li><strong>BSS段（未初始化数据区）</strong>：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。</li><li><strong>数据段</strong>：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配</li><li><strong>代码段</strong>：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量text段和data段在编译时已经分配了空间，而BSS段并不占用可执行文件的大小，它是由链接器来获取内存的。<ul><li>BSS段（未进行初始化的数据）的内容并不存放在磁盘上的程序文件中，其原因是内核在程序开始运行前将它们设置为0。需要存放在程序文件中的只有正文段和初始化数据段。</li><li>data段（已经初始化的数据）则为数据分配空间，数据保存到目标文件中。数据段包含经过初始化的全局变量以及它们的值。BSS段的大小从可执行文件中得到，然后链接器得到这个大小的内存块，紧跟在数据段的后面。当这个内存进入程序的地址空间后全部清零。<strong>包含数据段和BSS段的整个区段此时通常称为数据区</strong>。</li></ul></li><li><strong>可执行程序在运行时又多出两个区域：栈区和堆区</strong>。<ul><li>栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。</li><li>堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-进程与线程&quot;&gt;&lt;a href=&quot;#1-进程与线程&quot; class=&quot;headerlink&quot; title=&quot;1.进程与线程&quot;&gt;&lt;/a&gt;1.进程与线程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;对于有线程系统：&lt;ul&gt;
&lt;li&gt;进程是资源分配的独立单位&lt;/li&gt;
&lt;li&gt;线程是资源
      
    
    </summary>
    
      <category term="操作系统" scheme="https://cdlwhm1217096231.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://cdlwhm1217096231.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
