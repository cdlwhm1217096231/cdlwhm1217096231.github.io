<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Curry_Coder的空间</title>
  
  <subtitle>好好学习，天天向上！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cdlwhm1217096231.github.io/"/>
  <updated>2019-07-31T10:35:43.182Z</updated>
  <id>https://cdlwhm1217096231.github.io/</id>
  
  <author>
    <name>Curry_Coder</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法岗面试常见问题大集合</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E5%B2%97%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%A7%E9%9B%86%E5%90%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/算法岗面试常见问题大集合/</id>
    <published>2019-07-30T14:51:47.000Z</published>
    <updated>2019-07-31T10:35:43.182Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-参考博客"><a href="#1-参考博客" class="headerlink" title="1.参考博客"></a>1.参考博客</h4><ul><li><a href="https://www.nowcoder.com/ta/review-ml?query=&amp;asc=true&amp;order=&amp;page=1" target="_blank" rel="noopener">算法岗面试常见问题大集合</a></li><li><a href="http://www.huaxiaozhuan.com/" target="_blank" rel="noopener">算法工程师手册</a></li></ul><h4 id="2-模型过拟合的解决方法"><a href="#2-模型过拟合的解决方法" class="headerlink" title="2.模型过拟合的解决方法"></a>2.模型过拟合的解决方法</h4><ul><li>L1/L2正则化（原理奥卡姆剃刀）:L2正则化也叫作权重衰减，目标函数中增加所有权重w参数的平方之和，迫使所有w可能趋向0但不为0；L1正则化在损失函数中加入所有权重参数w的绝对值之和，迫使更多的w为0，使特征变得稀疏。</li><li>Batch Normalization（对神经网络中下一层的输入进行归一化处理，使得输入量的均值为0，方差为1，即通过特征归一化，加速模型的训练）</li><li>shortcut-connect(使用残差网络Residual network)</li><li>数据增强(增加样本的数量)</li><li>early stopping</li><li>Dropout：在训练过程中，让神经元以超参数p的概率被激活(也就是说1-p的概率被设置为0)，类似于bagging算法</li></ul><h4 id="3-如何解决样本类别的不均衡问题？"><a href="#3-如何解决样本类别的不均衡问题？" class="headerlink" title="3.如何解决样本类别的不均衡问题？"></a>3.如何解决样本类别的不均衡问题？</h4><ul><li>a.过采样/上采样：增加类别少的样本数量实现样本数量的均衡。具体是通过复制类别上的样本构成多条数据。此方法的缺点是当样本的特征很少时，容易出现过拟合。需要对过采样方法进行改进，改进的方法是：在类别少的样本中加入噪声、干扰数据或通过一定的规则产生新合成的样本，如smote算法。</li><li>b.欠采样/下采样：减少类别多的样本数量，一般的方法是随机地去掉一些类别多的样本。</li><li>c.调整正负样本的惩罚权重：对类别少的样本赋予高的权重，对类别多的样本赋予低的权重。</li><li>d.通过集成学习的方法：每次生成训练集时，使用所有类别少的样本，同时从类别多的样本中随机抽取数据与类别少的样本合并起来，构成一个新的训练集。</li><li>e.使用特征选择：一般样本不均衡也会导致特征不均衡。但如果类别少的样本量具有一定的规模时，则意味着其特征的分布较为均匀，可以选择出具有显著特征配合参与解决样本不均衡的问题。</li></ul><h4 id="4-在神经网络训练过程中，为什么会出现梯度消失的问题？如何防止？"><a href="#4-在神经网络训练过程中，为什么会出现梯度消失的问题？如何防止？" class="headerlink" title="4.在神经网络训练过程中，为什么会出现梯度消失的问题？如何防止？"></a>4.在神经网络训练过程中，<strong>为什么会出现梯度消失的问题？如何防止</strong>？</h4><ul><li>原因：使用了不合适的激活函数，例如sigmoid函数。此时，当神经网络的层数很深时，利用链式求导法则计算梯度时，损失函数的梯度连乘，导致乘积会变得越来越小接近于0，从而神经网络无法学习到新的信息。</li><li>解决方法：<ul><li>预训练加微调</li><li>梯度剪切</li><li>权重正则化</li><li>使用不同的激活函数</li><li>使用Batch Normalization</li><li>使用残差网络ResNet</li><li>使用LSTM网络</li></ul></li></ul><h4 id="5-介绍一下TensorFlow中的计算图"><a href="#5-介绍一下TensorFlow中的计算图" class="headerlink" title="5.介绍一下TensorFlow中的计算图"></a>5.介绍一下TensorFlow中的计算图</h4><ul><li>TensorFlow是一个通过计算图的形式来表述计算的编程系统，计算图也叫作数据流图。可以把计算图看做是一种有向图，TensorFlow中的每个节点都是计算图上的一个张量Tensor，而节点之间的边描述了计算之间的依赖关系和数学运算。</li></ul><h4 id="6-K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。"><a href="#6-K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。" class="headerlink" title="6.K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。"></a>6.K-Means或KNN中，通常使用欧式距离来表示最近的数据点之间的距离，有时候也使用曼哈度距离，对比两者的区别。</h4><ul><li>欧式距离最常见的是两个或多个点之间的距离表示法，又称为欧几里得距离。也就是通常所说的L2范数，公式如下。欧式距离的缺点是它将样本的不同属性之间的差别等同看待，这一点有时候不能满足实际要求。<script type="math/tex; mode=display">d(x, y) :=\sqrt{\left(x_{1}-y_{1}\right)^{2}+\left(x_{2}-y_{2}\right)^{2}+\cdots+\left(x_{n}-y_{n}\right)^{2}}=\sqrt{\sum_{i=1}^{n}\left(x_{i}-y_{i}\right)^{2}}</script></li><li>曼哈顿距离，也就是欧式空间中的在直角坐标系上两个点所形成的线段对轴产生的投影的距离总和。也就是我们所说的L1距离。例如，坐标(x1,y1)的点P1与坐标(x2, y2)的点P2的曼哈顿距离计算公式为：<script type="math/tex; mode=display">\left|x_{1}-x_{2}\right|+\left|y_{1}-y_{2}\right|</script></li></ul><h4 id="7-参数模型与非参数模型"><a href="#7-参数模型与非参数模型" class="headerlink" title="7.参数模型与非参数模型"></a>7.参数模型与非参数模型</h4><ul><li>参数模型：根据预先设计的规则，例如方差损失最小，进行学习，参数模型例子：回归（线性回归、逻辑回归）模型；最好可以看一下或者直接进行一下相关的推导；根据规则，拥有少部分数据就可以；</li><li>非参数模型：不需要事先假设规则，直接挖掘潜在数据中的规则；非参数模型例子：KNN，决策树，挖掘数据潜在的特征，所以比较灵活；</li></ul><h4 id="8-生成模型与判别模型"><a href="#8-生成模型与判别模型" class="headerlink" title="8.生成模型与判别模型"></a>8.生成模型与判别模型</h4><ul><li>生成模型：根据数据学习联合概率分布P(x,y)，从而计算出条件概率分布P(y|x)作为预测的模型。常用于含有隐变量的模型，例如HMM，朴素贝叶斯算法、高斯混合模型GMM、文档主题生成模型LDA、限制玻尔兹曼机等</li><li>判别模型：根据数据直接学习条件概率分布P(x|y)或者决策函数Y=f(X)作为预测模型。例如：逻辑回归、RF、SVM、神经网络、感知机、KNN、CRF等</li><li>两者的对比：<ul><li>使用生成式方法得到的模型，可以还原出模型的联合概率分布，而判别模型不可以；</li><li>生成式方法得到的模型收敛速度更快。当样本数增加时，生成式方法得到的模型能更快的收敛到真实模型；</li><li>存在隐变量时，只能使用生成模型；</li><li>使用判别式方法学习得到的模型，直接面对预测，学习的准确率通常更高，可以简化学习问题。</li></ul></li></ul><h4 id="9-LR和SVM的联系和区别？"><a href="#9-LR和SVM的联系和区别？" class="headerlink" title="9.LR和SVM的联系和区别？"></a>9.LR和SVM的联系和区别？</h4><ul><li>联系：<ul><li>LR和SVM都可以处理分类问题，且一般都用于处理线性二分类问题</li><li>两个方法都可以增加不同的正则化项，如L1、L2正则化项</li></ul></li><li>区别：<ul><li>LR是参数模型，SVM是非参数模型</li><li>从损失函数来看，LR使用的是交叉熵损失函数，SVM使用的hinge损失函数，这两个损失函数的目的都是增加对分类影响较大的样本点的权重，减小与分类关系比较小的数据点的权重。</li><li>SVM的处理方法只考虑支持向量，也就是只考虑和分类最相关的少数样本点来学习分类器。而逻辑回归通过非线性映射，大大减小了离分离超平面远的样本点权重，相对提升了与分类最相关的样本点的权重。</li><li>LR模型相对来说简单好理解，一般用于大规模的线性分类。SVM的理解和优化比较复杂，在处理复制非线性分类时，使用核技巧来计算优势明显。</li><li>LR能做的SVM也能做，但可能准确率是上有问题，但SVM能做的LR做不了。</li></ul></li></ul><h4 id="10-神经网络中参数量parameters和FLOPs计算"><a href="#10-神经网络中参数量parameters和FLOPs计算" class="headerlink" title="10.神经网络中参数量parameters和FLOPs计算"></a>10.神经网络中参数量parameters和FLOPs计算</h4><ul><li>CNN中的parameters分为两种：W和b，<strong>对于某一个卷积层，它的parameters的个数为</strong>:<script type="math/tex; mode=display">\left(K_{h} * K_{w} * C_{i n}\right) * C_{o u t}+C_{o u t}</script>其中，$K<em>{h}$是卷积核的高度，$K</em>{w}$是卷积核的宽度,$C<em>{in}$是输入的通道数，$C</em>{out}$是输出的通道数</li><li><strong>对于某个全连接层</strong>，如果输入的数据有$N<em>{in}$个节点，输出的数据有$N</em>{out}$个节点，它的参数个数为：<script type="math/tex; mode=display">N_{i n} * N_{o u t}+N_{o u t}</script></li><li>FLOPs：<strong>全称是floating point operations per second，指的是每秒浮点运算次数，即用来衡量硬件的计算性能</strong></li><li><strong>对于某个卷积层</strong>,它的FLOPs数量是：<script type="math/tex; mode=display">\left[\left(K_{h} * K_{w} * C_{i n}\right) * C_{o u t}+C_{o u t}\right] *(H * W)=n u m_{-} \text { params } *(H * W)</script>其中，$num_{params}$表示该层参数的数量，H是输出图片的高，W是输出图片的宽</li><li><strong>例题1：假设你的输入是一个300×300的彩色（RGB）图像，而你没有使用卷积神经网络。 如果第一个隐藏层有100个神经元，每个神经元与输入层进行全连接，那么这个隐藏层有多少个参数（包括偏置参数）</strong>？</li><li>A1：因为输入的节点数量是300*300*3,输出的节点数量是100。然后加上偏置项b，因为隐藏层有100个节点，每个节点都有一个偏置，所以b=100。利用上面计算全连接网络的公式，故3*300*300*100+100</li><li><strong>例题2：假设你的输入是300×300彩色（RGB）图像，并且你使用卷积层和100个过滤器，每个过滤器都是5×5的大小，请问这个隐藏层有多少个参数（包括偏置参数）</strong>？</li><li>A2：首先，参数和输入的图片大小是没有关系的，无论你给的图像像素有多大，参数值都是不变的，在这个题中，参数值只与过滤器有关。单个过滤器的大小是5*5,由于输入的是RGB图像，所以输入通道数目是3。因此一个过滤器的组成是5*5*3,每一过滤器只有一个偏置项b,因此一个过滤器所拥有的参数是5*5*3+1=76，一共用了100个过滤器，所以隐藏层含有76*100=7600个参数。其实，也就是上面的公式计算CNN的参数量。</li></ul><h4 id="11-SVM中常见的几种核函数"><a href="#11-SVM中常见的几种核函数" class="headerlink" title="11.SVM中常见的几种核函数"></a>11.SVM中常见的几种核函数</h4><ul><li>线性核函数：内积公式<script type="math/tex; mode=display">\kappa\left(x_{1}, x_{2}\right)=\left\langle x_{1}, x_{2}\right\rangle</script></li><li>多项式核函数<script type="math/tex; mode=display">K(x, z)=(x \cdot z+1)^{p}</script></li><li>高斯核函数<script type="math/tex; mode=display">K(x, z)=\exp \left(-\frac{\|x-z\|^{2}}{2 \sigma^{2}}\right)</script></li><li>字符串核函数：详见李航统计学习方法</li></ul><h4 id="12-逻辑回归与线性回归的联系与区别"><a href="#12-逻辑回归与线性回归的联系与区别" class="headerlink" title="12.逻辑回归与线性回归的联系与区别"></a>12.逻辑回归与线性回归的联系与区别</h4><ul><li>联系：逻辑回归和线性回归首先都是广义的线性回归；逻辑回归的模型本质上是一个对数线性回归模型，逻辑回归都是以线性回归为理论支持的。但线性回归模型无法做到sigmoid的非线性形式，sigmoid可以轻松处理0/1分类问题。</li><li>区别：<ul><li>线性模型的优化目标函数是最小二乘，而逻辑回归则是似然函数</li><li>线性回归在整个实数域范围内进行预测，敏感度一致；而分类范围，需要在[0,1]。逻辑回归就是一种减小预测范围，将预测值限定为[0,1]间的一种回归模型，因而对于这类问题来说，逻辑回归的鲁棒性比线性回归的要好。</li></ul></li></ul><h4 id="13-XGBoost为什么要用泰勒公式展开，优势在哪"><a href="#13-XGBoost为什么要用泰勒公式展开，优势在哪" class="headerlink" title="13.XGBoost为什么要用泰勒公式展开，优势在哪?"></a>13.XGBoost为什么要用泰勒公式展开，优势在哪?</h4><ul><li>XGBoost使用了一阶和二阶偏导, 二阶导数有利于梯度下降的更快更准。使用泰勒展开取得二阶倒数形式, 可以在不选定损失函数具体形式的情况下用于算法优化分析.本质上也就把损失函数的选取和模型算法优化和参数选择分开了，这种去耦合增加了XGBoost的适用性。</li></ul><h4 id="14-XGBoost如何寻找最优特征？是有放回还是无放回？"><a href="#14-XGBoost如何寻找最优特征？是有放回还是无放回？" class="headerlink" title="14.XGBoost如何寻找最优特征？是有放回还是无放回？"></a>14.XGBoost如何寻找最优特征？是有放回还是无放回？</h4><ul><li>XGBoost在训练过程中给各个特征的增益评分，最大增益的特征会被选出来作为分裂的依据，从而记忆了每个特征对在模型训练时的重要性。XGBoost属于boosting的集成学习方法，样本是无放回的，因此每轮计算样本不重复。XGBoost支持子采样，即每轮计算不使用全部样本，以减少过拟合。</li></ul><h4 id="15-决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？"><a href="#15-决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？" class="headerlink" title="15.决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？"></a>15.决策树、随机森林RF、Boosting、Adaboost、GBDT、XGBoost的区别？</h4><ul><li>bagging与boosting的区别：<ul><li>bagging方法有放回的采样相同数量样本训练学习器，然后再一起投票。学习器之间不存在强的依赖关系，学习器可以并行训练生成。集成方式一般为投票法。随机森林属于Bagging的代表，放回抽样，每个学习器随机选择部分特征去优化。</li><li>Boosting方法使用全部样本，依次训练每个学习器，迭代集成。学习器之间不存在强依赖关系，学习器可并行训练生成，集成方式为加权和；Adaboost属于Boosting，采用指数损失函数代替原本分类任务中的0-1损失函数；GBDT属于Boosting的优秀代表，对函数残差近似值进行梯度下降，用CRAT树作为基本的学习器，集成模型为回归模型。XGBoost属于Boosting的集大成者，对函数残差近似值进行梯度下降，迭代时利用二阶梯度信息，集成模型可用于分类也可以用于回归。</li></ul></li><li>决策树的学习过程：从根开始建立树，也就是如何选择特征进行分裂。ID3算法使用信息增益、C4.5使用信息增益比、CART树采用基尼系数计算最优分类点，XGBoost使用二阶泰勒展开系数计算最优分裂点。</li></ul><h4 id="16-GBDT与XGBoost的对比，XGBoost的优点"><a href="#16-GBDT与XGBoost的对比，XGBoost的优点" class="headerlink" title="16.GBDT与XGBoost的对比，XGBoost的优点"></a>16.GBDT与XGBoost的对比，XGBoost的优点</h4><ul><li>损失函数用泰勒展开二项逼近，而不是像GBDT中用的就是一阶导数</li><li>对树的结构进行了正则化约束，防止模型过于复杂，降低了过拟合的可能性</li><li>节点的分裂方式不同，GBDT使用的是基尼系数，XGBoost使用的是经过优化推导后的算法(穷举法选择最佳的分裂节点、通过加权分位数方法近似选择最佳的分裂节点、针对稀疏特征的分裂点选择法)</li></ul><h4 id="17-L1和L2范数的区别"><a href="#17-L1和L2范数的区别" class="headerlink" title="17.L1和L2范数的区别"></a>17.L1和L2范数的区别</h4><ul><li>L1 norm:向量中各个元素绝对值之和，也称为稀疏规则算子，L1范数可以使权重稀疏，方便特征提取；L1正则化先验服从拉普拉斯分布</li><li>L2 norm:向量中各个元素平方和的1/2次方，又称为Frobenius范数，L2范数可以防止过拟合，提升模型的泛化能力；L2正则化先验服从高斯分布</li></ul><h4 id="18-阐述Adaboost算法的流程，并写出权重更新的公式"><a href="#18-阐述Adaboost算法的流程，并写出权重更新的公式" class="headerlink" title="18.阐述Adaboost算法的流程，并写出权重更新的公式"></a>18.阐述Adaboost算法的流程，并写出权重更新的公式</h4><ul><li><a href="https://www.jianshu.com/p/aae31290189e" target="_blank" rel="noopener">详细原理</a></li></ul><h4 id="19-LSTM的结构推导，为什么比普通的RNN好？"><a href="#19-LSTM的结构推导，为什么比普通的RNN好？" class="headerlink" title="19.LSTM的结构推导，为什么比普通的RNN好？"></a>19.LSTM的结构推导，为什么比普通的RNN好？</h4><ul><li><a href="https://www.jianshu.com/p/7c429d049b09" target="_blank" rel="noopener">详细原理</a></li></ul><h4 id="20-为什么朴素贝叶斯算法如此朴素？"><a href="#20-为什么朴素贝叶斯算法如此朴素？" class="headerlink" title="20.为什么朴素贝叶斯算法如此朴素？"></a>20.为什么朴素贝叶斯算法如此朴素？</h4><ul><li>因为它假设所有的特征在数据集中的作用都是同样重要的，而且相互独立的。这个假设在现实中基本上是不存在的，但特征相关性很小的实际情况还很多，岁月这个模型还可以工作的很好。</li></ul><h4 id="21-EM算法原理说明"><a href="#21-EM算法原理说明" class="headerlink" title="21.EM算法原理说明"></a>21.EM算法原理说明</h4><ul><li>有时候样本的产生和隐含变量有关(隐变量是不能观察的)，而求模型的参数时一般都采用极大似然估计，由于含有隐变量，所以对似然函数的参数求导数是求不出来的，这时候用EM算法来求模型的参数，典型的用法是用在GMM和HMM中。步骤如下：<ul><li>E步：选择一组参数，求出在此参数下隐变量的条件概率值<script type="math/tex; mode=display">  Q_{i}\left(z^{(i)}\right) :=p\left(z^{(i)} | x^{(i)} ; \theta\right)</script></li><li>M步：结合E步求出的隐变量的条件概率值，求出似然函数的下界函数(即某个期望函数)最大值。<script type="math/tex; mode=display">  \theta :=\arg \max _{\theta} \sum_{i} \sum_{z^{(i)}} Q_{i}\left(z^{(i)}\right) \log \frac{p\left(x^{(i)}, z^{(i)} ; \theta\right)}{Q_{i}\left(z^{(i)}\right)}</script></li><li>重复进行上面的两步，直至收敛为止。</li></ul></li><li>M步中下界函数的推导过程：<script type="math/tex; mode=display">\begin{aligned} \sum_{i} \log p\left(x^{(i)} ; \theta\right) &=\sum_{i} \log \sum_{z^{(i)}} p\left(x^{(i)}, z^{(i)} ; \theta\right) \\ &=\sum_{i} \log \sum_{z^{(i)}} Q_{i}\left(z^{(i)}\right) \frac{p\left(x^{(i)}, z^{(i)} ; \theta\right)}{Q_{i}\left(z^{(i)}\right)} \\ & \geq \sum_{i} \sum_{z^{(i)}} Q_{i}\left(z^{(i)}\right) \log \frac{p\left(x^{(i)}, z^{(i)} ; \theta\right)}{Q_{i}\left(z^{(i)}\right)} \end{aligned}</script></li></ul><h4 id="22-GMM算法原理说明"><a href="#22-GMM算法原理说明" class="headerlink" title="22.GMM算法原理说明"></a>22.GMM算法原理说明</h4><ul><li>EM算法的常用例子是高斯混合模型GMM，每个样本都有可能由K个高斯模型产生，只不过每个高斯模型的产生概率不同，因此每个样本都有对应的高斯分布(K个模型中的一个)，此时的隐变量就是每个样本对应的某个高斯分布。<ul><li>GMM算法的E步(计算每个样本对应每个高斯模型的概率)<script type="math/tex; mode=display">  w_{j}^{(i)} :=p\left(z^{(i)}=j | x^{(i)} ; \phi, \mu, \Sigma\right)</script>具体的计算公式为：<script type="math/tex; mode=display">  p\left(z^{(i)}=j | x^{(i)} ; \phi, \mu, \Sigma\right)=\frac{p\left(x^{(i)} | z^{(i)}=j ; \mu, \Sigma\right) p\left(z^{(i)}=j ; \phi\right)}{\sum_{l=1}^{k} p\left(x^{(i)} | z^{(i)}=l ; \mu, \Sigma\right) p\left(z^{(i)}=l ; \phi\right)}</script></li><li>M步计算公式(计算每个高斯模型的权重，均值，方差3个参数)：<script type="math/tex; mode=display">  \begin{aligned} \phi_{j} & :=\frac{1}{m} \sum_{i=1}^{m} w_{j}^{(i)} \\ \mu_{j} & :=\frac{\sum_{i=1}^{m} w_{j}^{(i)} x^{(i)}}{\sum_{i=1}^{m} w_{j}^{(i)}} \\ \Sigma_{j} & :=\frac{\sum_{i=1}^{m} w_{j}^{(i)}\left(x^{(i)}-\mu_{j}\right)\left(x^{(i)}-\mu_{j}\right)^{T}}{\sum_{i=1}^{m} w_{j}^{(i)}} \end{aligned}</script></li></ul></li></ul><h4 id="23-KNN算法中K是如何选择的"><a href="#23-KNN算法中K是如何选择的" class="headerlink" title="23.KNN算法中K是如何选择的?"></a>23.KNN算法中K是如何选择的?</h4><ul><li>如果选择较小的K值，就相当于用较小的邻域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大。换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合；</li><li>如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。</li><li>K=N，此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的累，模型过于简单，忽略了训练实例中大量有用信息。</li><li>实际中，使用交叉验证的方法选择最优的K的取值。</li></ul><h4 id="24-机器学习中，为什么经常需要对数据进行归一化？"><a href="#24-机器学习中，为什么经常需要对数据进行归一化？" class="headerlink" title="24.机器学习中，为什么经常需要对数据进行归一化？"></a>24.机器学习中，为什么经常需要对数据进行归一化？</h4><ul><li>归一化能提高梯度下降算法求解的速度</li><li>归一化有可能提高精度</li></ul><h4 id="25-神经网络中的批量归一化Batch-Normalization-BN-原理"><a href="#25-神经网络中的批量归一化Batch-Normalization-BN-原理" class="headerlink" title="25.神经网络中的批量归一化Batch Normalization(BN)原理"></a>25.神经网络中的批量归一化Batch Normalization(BN)原理</h4><ul><li><a href="https://blog.csdn.net/cdlwhm1217096231/article/details/95391398" target="_blank" rel="noopener">详细原理</a></li></ul><h4 id="26-哪些机器学习算法不需要进行归一化操作？"><a href="#26-哪些机器学习算法不需要进行归一化操作？" class="headerlink" title="26.哪些机器学习算法不需要进行归一化操作？"></a>26.哪些机器学习算法不需要进行归一化操作？</h4><ul><li>概率模型不需要做归一化操作，因为它们不关心变量的值，而关心的是变量分布和变量之间的条件概率，如决策树。但是，像Adaboost、SVM、LR、KNN、Kmeans等最优化问题就需要归一化。</li></ul><h4 id="27-为什么树形结构不需要归一化？"><a href="#27-为什么树形结构不需要归一化？" class="headerlink" title="27.为什么树形结构不需要归一化？"></a>27.为什么树形结构不需要归一化？</h4><ul><li>数值缩放，不影响分裂点位置。因为第一步都是按照特征值进行排序的，排序的顺序不变，那么所属的分支以及分裂点就不会变。对于线性模型，比如说LR，假设有两个特征，一个是(0,1)的，一个是(0,10000)的，这样运用梯度下降时候，损失等高线是一个椭圆的形状，这样想迭代到最优点，就需要很多次迭代，但是如果进行了归一化，那么等高线就是圆形的，那么SGD就会往原点迭代，需要的迭代次数较少。另外，注意树模型是不能进行梯度下降的，因为树模型是阶跃的，阶跃点是不可导的，并且求导没意义，所以树模型（回归树）寻找最优点是通过寻找最优分裂点完成的。</li></ul><h4 id="28-一个完整机器学习项目的流程"><a href="#28-一个完整机器学习项目的流程" class="headerlink" title="28.一个完整机器学习项目的流程"></a>28.一个完整机器学习项目的流程</h4><ul><li>抽象成数学问题、获取数据、特征预处理与特征选择、训练模型与调优、模型诊断、模型融合、上线运行</li></ul><h4 id="29-条件随机场CRF模型相对于HMM模型-隐马尔科夫模型-和MEMM模型-最大熵隐马尔科夫模型-的优势。"><a href="#29-条件随机场CRF模型相对于HMM模型-隐马尔科夫模型-和MEMM模型-最大熵隐马尔科夫模型-的优势。" class="headerlink" title="29.条件随机场CRF模型相对于HMM模型(隐马尔科夫模型)和MEMM模型(最大熵隐马尔科夫模型)的优势。"></a>29.条件随机场CRF模型相对于HMM模型(隐马尔科夫模型)和MEMM模型(最大熵隐马尔科夫模型)的优势。</h4><ul><li>HMM模型中一个最大的缺点即其输出独立性假设，由于输出独立性假设的缺点导致HMM模型不能考虑上下文的特征，限制了特征的选择。</li><li>MEMM模型则解决了HMM模型的最大的缺点，可以任意选择特征，但是由于其每一个节点都要进行归一化，所以只能找到局部最优值。同时，也带来了标记偏见的问题即凡是在训练语料库中未出现的情况都被忽略掉了。CRF模型很好的解决了这个问题，它并不在每一节点进行归一化，而是所有特征进行全局归一化，因此可以求出全局的最优值。</li></ul><h4 id="30-什么是熵？"><a href="#30-什么是熵？" class="headerlink" title="30.什么是熵？"></a>30.什么是熵？</h4><ul><li>熵的定义：离散随机事件的出现概率。一个系统越是有序，信息熵就越低。信息熵可以被认为是系统有序化程度的一个度量。</li></ul><h4 id="31-BP反向传播算法推导及python实现"><a href="#31-BP反向传播算法推导及python实现" class="headerlink" title="31.BP反向传播算法推导及python实现"></a>31.BP反向传播算法推导及python实现</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-参考博客&quot;&gt;&lt;a href=&quot;#1-参考博客&quot; class=&quot;headerlink&quot; title=&quot;1.参考博客&quot;&gt;&lt;/a&gt;1.参考博客&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nowcoder.com/ta/review-ml?q
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点总结</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/操作系统/操作系统知识点总结/</id>
    <published>2019-07-30T13:11:15.000Z</published>
    <updated>2019-07-30T14:47:54.474Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1.进程与线程"></a>1.进程与线程</h4><ul><li>对于有线程系统：<ul><li>进程是资源分配的独立单位</li><li>线程是资源调度的独立单位</li></ul></li><li>对无无线程系统：<ul><li>进程是资源调度、分配的独立单位</li></ul></li></ul><h4 id="2-进程间的通信方式及优缺点"><a href="#2-进程间的通信方式及优缺点" class="headerlink" title="2.进程间的通信方式及优缺点"></a>2.进程间的通信方式及优缺点</h4><ul><li><strong>管道</strong><ul><li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信。<ul><li>优点：可以实现任意关系的进程间的通信</li><li>缺点：<ul><li>a.长期存于系统中，使用不当容易出错</li><li>b.缓冲区有限</li></ul></li></ul></li><li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）<ul><li>优点：简单方便</li><li>缺点：<ul><li>a.局限于单向通信</li><li>b.只能创建在它的进程以及其有亲缘关系的进程之间</li><li>c.缓冲区有限</li></ul></li></ul></li></ul></li><li><strong>信号量</strong>：一个计数器，可以用来控制多个线程对共享资源的访问<ul><li>优点：可以同步进程</li><li>缺点：信号量有限</li></ul></li><li><strong>信号</strong>: 一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li><li><strong>消息队列</strong>: 是消息的链表，存放在内核中并由消息队列标识符标识<ul><li>优点： 可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li><li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li></ul></li><li><strong>共享内存</strong>：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问<ul><li>优点：无须复制，快捷，信息量大</li><li>缺点：<ul><li>a.通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li><li>b.利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li></ul></li></ul></li><li><strong>套接字</strong>：可用于不同及其间的进程通信<ul><li>优点：<ul><li>a.传输数据为字节级，传输数据可自定义，数据量小效率高</li><li>b.传输数据时间短，性能高</li><li>c.适合于客户端和服务器端之间信息实时交互</li><li>d.可以加密,数据安全性强</li></ul></li><li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li></ul></li></ul><h4 id="3-线程之间的通信方式"><a href="#3-线程之间的通信方式" class="headerlink" title="3.线程之间的通信方式"></a>3.线程之间的通信方式</h4><ul><li><strong>锁机制</strong>：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）<ul><li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>自旋锁（spin lock）：与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li><li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li></ul></li><li><strong>信号量机制</strong><ul><li>无名线程信号量</li><li>有名线程信号量</li></ul></li><li><strong>信号机制(Signal)</strong>：类似进程间的信号处理</li><li><strong>屏障</strong>：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li></ul><h4 id="4-进程之间私有和共享的资源"><a href="#4-进程之间私有和共享的资源" class="headerlink" title="4.进程之间私有和共享的资源"></a>4.进程之间私有和共享的资源</h4><ul><li>私有：地址空间、堆、全局变量、栈、寄存器</li><li>共享：代码段，公共数据，进程目录，进程 ID</li></ul><h4 id="5-线程之间私有和共享的资源"><a href="#5-线程之间私有和共享的资源" class="headerlink" title="5.线程之间私有和共享的资源"></a>5.线程之间私有和共享的资源</h4><ul><li>私有：线程栈，寄存器，程序寄存器</li><li>共享：堆，地址空间，全局变量，静态变量</li></ul><h4 id="6-多进程与多线程间的对比、优劣与选择"><a href="#6-多进程与多线程间的对比、优劣与选择" class="headerlink" title="6.多进程与多线程间的对比、优劣与选择"></a>6.多进程与多线程间的对比、优劣与选择</h4><p><img src="https://upload-images.jianshu.io/upload_images/13407176-f1d727410790e1b0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="特点对比.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-c113b6d4576c9f27.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优缺点对比.jpg"></p><ul><li>线程与进程选用规则：<ul><li>需要频繁创建销毁的优先用线程</li><li>需要进行大量计算的优先使用线程</li><li>强相关的处理用线程，弱相关的处理用进程</li><li>可能要扩展到多机分布的用进程，多核分布的用线程</li><li>都满足需求的情况下，用你最熟悉、最拿手的方式</li></ul></li></ul><h4 id="7-Linux的内核同步方式"><a href="#7-Linux的内核同步方式" class="headerlink" title="7.Linux的内核同步方式"></a>7.Linux的内核同步方式</h4><ul><li><strong>为什么需要内核同步？</strong>：在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程、多线程编程一样也需要一些同步机制来同步<strong>各执行单元对共享数据的访问</strong>。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</li><li><strong>内核同步方式</strong>:<ul><li>原子操作</li><li>信号量（semaphore）</li><li>读写信号量（rw_semaphore）</li><li>自旋锁（spinlock）</li><li>大内核锁（BKL，Big Kernel Lock）</li><li>读写锁（rwlock）</li><li>大读者锁（brlock-Big Reader Lock）</li><li>读-拷贝修改(RCU，Read-Copy Update)</li><li>顺序锁（seqlock）</li></ul></li></ul><h4 id="8-死锁"><a href="#8-死锁" class="headerlink" title="8.死锁"></a>8.死锁</h4><ul><li>定义：<strong>是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。</strong></li><li><strong>死锁产生的条件</strong>：<ul><li>互斥</li><li>请求和保持</li><li>不可剥夺</li><li>环路等待</li></ul></li><li><strong>预防死锁</strong>：<ul><li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li><li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li><li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li><li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li><li>有序资源分配法</li><li><a href="https://blog.csdn.net/jgm20475/article/details/81265947" target="_blank" rel="noopener">银行家算法</a></li></ul></li></ul><h4 id="9-页面置换算法"><a href="#9-页面置换算法" class="headerlink" title="9.页面置换算法"></a>9.页面置换算法</h4><ul><li><strong>页面置换</strong>：在地址映射过程中，如果在页面中发现所要访问的页面不存在于内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</li><li><p><strong>分类</strong>：</p><ul><li>全局置换：在整个内存空间置换<ul><li>工作集算法</li><li>缺失率置换算法</li></ul></li><li><p>局部置换：在本进程中进行置换</p><ul><li>最佳置换算法(OPT)<ul><li>原理：从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。 <a href="https://blog.csdn.net/jack450250844/article/details/84986690" target="_blank" rel="noopener">详见原理</a></li></ul></li><li><p>先进先出置换算法(FIFO)</p><ul><li>原理：该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老的页面。但该算法与进程实际运行的规律不相适应，因为在进程中，有些页面经常被访问，比如，含有全局变量、常用函数、例程等的页面，FIFO算法并不能保证这些页面不被淘汰。<a href="https://blog.csdn.net/jack450250844/article/details/85019950" target="_blank" rel="noopener">详见原理</a></li></ul></li><li><p>最近最久未使用算法(LRU)</p><ul><li>原理：根据页面调入内存后的使用情况做出决策的。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页面予以淘汰。该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有也面中t值最大的，即最近最久未使用的页面予以淘汰。<a href="https://blog.csdn.net/jack450250844/article/details/85019898" target="_blank" rel="noopener">详见原理</a></li></ul></li><li>时钟置换算法(Clock)<ul><li>原理：淘汰访问位为0的页框中的页面，被访问过的页面将其页框的访问位数值置1。<a href="https://blog.csdn.net/Long_H_Zhu/article/details/84184563" target="_blank" rel="noopener">详见原理</a></li></ul></li></ul></li><li>局部置换的三种算法C++代码  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> page[] = &#123; <span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FIFO</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OPT</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RLU</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inArray</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    FIFO();</span><br><span class="line">    OPT();</span><br><span class="line">    RLU();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FIFO算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FIFO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">3</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"FIFO:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (page[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inArray(temp, <span class="number">3</span>, page[num])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            error++;</span><br><span class="line">            <span class="keyword">bool</span> hasChanged = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (time[i] == <span class="number">0</span> &amp;&amp; hasChanged == <span class="literal">false</span>) &#123;</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    hasChanged = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (time[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                    time[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误率:"</span> &lt;&lt; error &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inArray</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> n, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == a[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OPT算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OPT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//OPT已知未来的页数为20</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"OPT:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (page[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = page[num];</span><br><span class="line">        <span class="keyword">if</span> (inArray(temp, <span class="number">3</span>, page[num])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            error++;</span><br><span class="line">            <span class="keyword">bool</span> fuck = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    fuck = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fuck == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> distance[<span class="number">3</span>] = &#123; <span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span> &#125;;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= num; i--) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (temp[j] == page[i] &amp;&amp; (i - num) &lt; distance[j]) &#123;</span><br><span class="line">                            distance[j] = i - num;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (max &lt; distance[i]) &#123;</span><br><span class="line">                        max = distance[i];</span><br><span class="line">                        k = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                temp[k] = page[num];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误率:"</span> &lt;&lt; error &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RLU算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RLU</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> time[<span class="number">3</span>] = &#123; <span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"RLU:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (page[num] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = page[num];</span><br><span class="line">        <span class="keyword">if</span> (inArray(temp, <span class="number">3</span>, page[num])) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">//bool Changed = false;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == page[num]) &#123;</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//Changed = true;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] != page[num]&amp;&amp;time[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">                    time[i]--;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            error++;</span><br><span class="line">            <span class="comment">//bool hasChange = false;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(time[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    temp[i] = page[num];</span><br><span class="line">                    time[i] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    time[i]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; page[num] &lt;&lt; <span class="string">','</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; temp[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"错误率:"</span> &lt;&lt; error &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="10-进程状态转换图"><a href="#10-进程状态转换图" class="headerlink" title="10.进程状态转换图"></a>10.进程状态转换图</h4><p><img src="https://upload-images.jianshu.io/upload_images/13407176-2d3db5b8d56f27a8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进程的五种基本状态"></p><ul><li>进程的五种基本状态：<ul><li>创建状态：进程正在被创建</li><li>就绪状态：进程被加入到就绪队列中等待CPU调度运行</li><li>执行状态：进程正在被运行</li><li>等待阻塞状态：进程因为某种原因，比如等待I/O，等待设备，而暂时不能运行</li><li>终止状态：进程运行完毕</li></ul></li></ul><h4 id="11-软链接和硬链接的区别"><a href="#11-软链接和硬链接的区别" class="headerlink" title="11.软链接和硬链接的区别"></a>11.软链接和硬链接的区别</h4><ul><li>软链接也叫符号链接，软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</li><li>硬链接：通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</li></ul><h4 id="12-协程"><a href="#12-协程" class="headerlink" title="12.协程"></a>12.协程</h4><ul><li><p>定义：又称微线程，纤程，英文名Coroutine。协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。例如：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">A</span><span class="params">()</span> :</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'1'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'2'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'3'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">B</span><span class="params">()</span> :</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'x'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'y'</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'z'</span></span><br></pre></td></tr></table></figure></li><li><p>上面协程运行结果可能是12x3yz。在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A。但协程的特点在于是一个线程执行。</p></li></ul><h4 id="13-协程与线程的区别"><a href="#13-协程与线程的区别" class="headerlink" title="13.协程与线程的区别"></a>13.协程与线程的区别</h4><ul><li>协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制。因此，没有线程切换的开销。协程和多线程相比，线程数量越多，协程的性能优势就越明显。</li><li>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突。在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li></ul><h4 id="14-进程同步的几种方式"><a href="#14-进程同步的几种方式" class="headerlink" title="14.进程同步的几种方式"></a>14.进程同步的几种方式</h4><ul><li><strong>信号量</strong>：用于进程间传递信号的一个整数值。</li><li>在信号量上只有三种操作可以进行：初始化、P操作、V操作，这三种操作都是原子操作。<strong>P操作(递减操作)可以用于阻塞一个进程，V操作(增加操作)可以用于解除阻塞一个进程</strong>。</li><li>原理：两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。该信号即为信号量s。为通过信号量s传送信号，进程可执行原语semSignal(s);为通过信号量s接收信号，进程可执行原语semWait(s);如果相应的信号仍然没有发送，则进程被阻塞，直到发送完为止。可把信号量视为一个具有整数值的变量，在它之上定义三个操作：<ul><li>一个信号量可以初始化为非负数；</li><li>semWait操作使信号量s减1.若值为负数，则执行semWait的进程被阻塞。否则进程继续执行；</li><li>semSignal操作使信号量加1，若值大于或等于零，则被semWait操作阻塞的进程被解除阻塞</li></ul></li><li><strong>管程</strong>：由一个或多个过程、一个初始化序列和局部数据组成的软件模块，其主要特点如下：<ul><li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问；</li><li>一个进程通过调用管程的一个过程进入管程；</li><li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被阻塞，以等待管程可用；</li></ul></li><li><strong>消息传递</strong>：是进程间进程消息传递所需要的最小操作集。一个进程以消息的形式给另一个指定的目标进程发送消息；进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。</li></ul><h4 id="15-线程同步的几种方式"><a href="#15-线程同步的几种方式" class="headerlink" title="15.线程同步的几种方式"></a>15.线程同步的几种方式</h4><ul><li><strong>临界区</strong>:通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</li><li><strong>互斥量</strong>:采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。</li><li><strong>信号量</strong>:它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。</li><li><strong>事件</strong>:通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-进程与线程&quot;&gt;&lt;a href=&quot;#1-进程与线程&quot; class=&quot;headerlink&quot; title=&quot;1.进程与线程&quot;&gt;&lt;/a&gt;1.进程与线程&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;对于有线程系统：&lt;ul&gt;
&lt;li&gt;进程是资源分配的独立单位&lt;/li&gt;
&lt;li&gt;线程是资源
      
    
    </summary>
    
      <category term="操作系统" scheme="https://cdlwhm1217096231.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://cdlwhm1217096231.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的文件打包与压缩方法总结</title>
    <link href="https://cdlwhm1217096231.github.io/Linux/Linux%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8E%E5%8E%8B%E7%BC%A9%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/Linux/Linux中的文件打包与压缩方法总结/</id>
    <published>2019-07-29T11:45:34.000Z</published>
    <updated>2019-07-29T11:55:17.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、文件打包和解压缩"><a href="#一、文件打包和解压缩" class="headerlink" title="一、文件打包和解压缩"></a>一、文件打包和解压缩</h3><ul><li>在windows系统上最常见的压缩文件不外乎这三种*.zip,*.rar,*.7z后缀的压缩文件，而在Linux系统上常见常用的除了以上的三种之外，还有*.gz,*.xz,*.bz2,*.tar,*tar.gz,*tar.xz,*.tar.bz2等后缀的压缩文件。</li><li><p>1..zip压缩打包程序</p><ul><li><p>1.1 打包文件夹<br>zip -r -q -o njust.zip /home/cdl</p><ul><li>参数说明:<ul><li>-r：表示递归打包包含子目录的全部内容</li><li>-q：表示为安静模式，即不向屏幕输出信息</li><li>-o：表示输出文件，需要在其后紧跟打包输出文件名</li></ul></li><li>查看压缩文件的信息：  <figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">du -<span class="keyword">h</span> njust.<span class="keyword">zip</span></span><br><span class="line"><span class="keyword">file</span> njust.<span class="keyword">zip</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>1.2 设置压缩等级(9最小,1最大)<br>  zip -r 9 -q -o njust_9.zip /home/cdl -x ~/*.zip<br>  zip -r -1 -q -o njust_1.zip /home/cdl -x ~/*.zip<br>这里添加了一个参数用于设置压缩级别[1-9],1表示最快压缩但体积大，9表示体积最小但耗时最久。最后那个-x是为了排除上一次创建的zip文件，否则又会被打包进这一次的压缩文件中。这里只能使用绝对路径！！！</p><ul><li><p>再使用du命令分别查看默认压缩等级、最低和最高压缩级别及未压缩的文件的大小：</p>   <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">du</span> -h -d <span class="number">0</span> <span class="regexp">*.zip</span> | sort</span><br></pre></td></tr></table></figure></li><li><p>通过man手册可知：</p><ul><li>-h：输入人类可以解释的信息</li><li>-d：所查看文件的深度</li></ul></li></ul></li><li>1.3 创建加密zip包(使用-e参数可以创建加密压缩包)<br>  zip -r -e -o njust_encryption.zip /home/cdl<ul><li>注意：关于zip命令，因为windows系统与Linux在文本文件格式上的兼容问题，比如换行符(为不可见字符)，在windows为回车加换行，Linux上为换行；所以如果不加处理的话，在Linux上编辑的文本文件，在windows系统上打开可能看起来是没有换行的。如果想让在Linux创建的zip压缩文件在Windows系统上解压后没有任何问题，那么还需要对命令进行修改：<br>  zip -r -l -o njust.zip /home/cdl   需要加上-l参数将换行转为回车加换行</li></ul></li></ul></li><li><p>2.使用unzip命令解压缩zip文件</p><ul><li>将njust.zip解压到当前目录下：<br>  unzip njust.zip</li><li>使用安静模式，将文件解压到指定目录，指定目录不存在，会自动创建：<br>  unzip -q njust.zip -d ziptest</li><li>如果不想解压只想查看压缩包的内容，可以使用-l参数：<br>  unzip -l njust.zip<br>  注意：使用unzip解压文件时同样应该注意兼容问题，不过这里此时关心的不再是上面的问题，而是中文编码的问题。通常windows系统上创建的压缩文件，如果有包含中文的文档或以中文作为文件名的文件时，默认会采用GBK或其他编码，而Linux上默认使用utf-8编码，如果不加任何处理，直接解压的话可能会出现中文乱码的问题(有时候它会帮你自动处理)。为了解决这个问题，可以在解压时指定编码类型。</li><li>使用-O(大写的字母O)参数指定编码类型： <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">unzip</span> <span class="selector-tag">-O</span> <span class="selector-tag">GBK</span> 中文压缩文件<span class="selector-class">.zip</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>3..rar文件打包压缩命令</p><ul><li>rar也是windows上常用的一种压缩文件的格式，在Linux上可以使用rar和unrar工具分别创建和解压rar压缩包</li><li>首先使用需要安装rar和unrar工具：<br>  sudo apt-get update<br>  sudo apt-get install rar unrar</li><li>在使用rar、unrar命令时，应该注意命令参数前不加-，否则会报错！<br>  rm *.zip<br>  rar a njust.rar<br>上面的命令使用a参数添加一个目录~到一个归档文件中，如果该文件不存在就会自动创建。</li><li>如果不解压只是查看文件，可以使用参数l：<br>  rar l njust.rar</li><li>全路径解压：<br>  unrar x njust.rar</li><li>去掉全路径解压：<br>  mkdir temp<br>  unrar e njust.rar temp/</li></ul></li><li>4..tar打包工具<ul><li>在Linux上面更常用的是tar工具，tar原本只是一个打包工具，只是同时还实现了对7z，gizp，xz，bzip2等工具的支持</li><li>创建一个tar包：<br>tar -cf njust.tar ~   (此命令会自动去掉表示绝对路径的/，也可以使用-P保留绝对路径符)</li><li>参数说明：</li><li>-c：创建一个tar包文件</li><li>-f：指定创建文件的名，注意文件名必须紧跟在-f参数后，不能写成tar -fc njust.tar!可以写成tar -f njust.tar -c ~</li><li>-v：以可视的方式输出打包的文件</li><li>解压一个文件(-x参数)到指定路径的已存在目录(-C参数)：<br>mkdir tardir<br>tar -xf njust.tar -C tardir</li><li>只查看不解压文件-t参数：<br>tar -tf njust.tar</li><li>对于创建不同压缩格式的文件时，对于tar来说是非常简单，需要的只是换一个参数，这里以使用gzip工具创建.tar.gz文件为例来说明。只需要在创建tar文件的基础上加一个-z参数，使用gzip来压缩文件：tar -czf njust.tar.gz ~</li><li>解压*.tar.gz文件到当前文件夹：<br>tar -xzf njust.tar.gz</li><li>现在要使用其他的压缩工具创建或解压相应文件时，只需要更改一个参数即可：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-34cfcf22721e7015.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tar解压命令.png"></li><li>此外，还有gzip和gunzip(相当于gzip -d)：压缩和解压命令，解压文件为.gz后缀</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、文件打包和解压缩&quot;&gt;&lt;a href=&quot;#一、文件打包和解压缩&quot; class=&quot;headerlink&quot; title=&quot;一、文件打包和解压缩&quot;&gt;&lt;/a&gt;一、文件打包和解压缩&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在windows系统上最常见的压缩文件不外乎这三种*.zip,*
      
    
    </summary>
    
      <category term="Linux" scheme="https://cdlwhm1217096231.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://cdlwhm1217096231.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow中的RNNCell基本单元使用</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow%E4%B8%AD%E7%9A%84RNNCell%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83%E4%BD%BF%E7%94%A8/"/>
    <id>https://cdlwhm1217096231.github.io/深度学习/TensorFlow中的RNNCell基本单元使用/</id>
    <published>2019-07-29T11:43:57.000Z</published>
    <updated>2019-07-29T11:44:51.378Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-charRNN基础介绍"><a href="#0-charRNN基础介绍" class="headerlink" title="0.charRNN基础介绍"></a>0.charRNN基础介绍</h3><ul><li>charRNN 是N vs N的循环神经网络，要求输入序列长度等于输出序列长度。<br>原理：用已经输入的字母去预测下一个字母的概率。一个句子是hello!,例如输入序列是hello,则输出序列是ello!<br>预测时：首先选择一个x1当作起始的字符，然后用训练好的模型得到下一个字符出现的概率。根据这个概率选择一个字符输出，然后将此字符当作下一步的x2输入到模型中。依次递推，得到任意长度的文字。<strong>注意：输入的单个字母是以one-hot形式进行编码的！</strong></li><li>对中文进行建模时，每一步输入模型的是一个汉字，由于汉字的种类太多，导致模型太大，一般采用下面的方法进行优化：<ul><li>1.取最常用的N个汉字，将剩下的汉字变成单独的一类，用一个\<unk\>字符来进行标注</unk\></li><li>2.在输入时，可以加入一个embedding层，将汉字的one-hot编码转为稠密的词嵌入表示。对单个字母不使用embedding是由于单个字母不具备任何的含义，只需要使用one-hot编码即可。单个汉字是具有一定的实际意义的，所以使用embedding层</li></ul></li></ul><h3 id="1-实现RNN的基本单元RNNCell抽象类————有两种直接使用的子类-BasicRNNCell-基本的RNN-和LSTMCell-基本的LSTM"><a href="#1-实现RNN的基本单元RNNCell抽象类————有两种直接使用的子类-BasicRNNCell-基本的RNN-和LSTMCell-基本的LSTM" class="headerlink" title="1.实现RNN的基本单元RNNCell抽象类————有两种直接使用的子类:BasicRNNCell(基本的RNN)和LSTMCell(基本的LSTM)"></a>1.实现RNN的基本单元RNNCell抽象类————有两种直接使用的子类:BasicRNNCell(基本的RNN)和LSTMCell(基本的LSTM)</h3><ul><li>RNNCell有三个属性:<ul><li>1.类方法call:所有的子类都会实现一个<strong>call</strong>函数，可以实现RNN的单步计算，调用形式：(output,next<em>state)=\</em>_call__(input, state)</li><li>2.类属性state<em>size:隐藏层的大小，输入数据是以batch_size的形式进行输入的即input=(batch_size, input_size),调用\</em>_call__函数时隐藏层的形状是(batch_size, state_size),输出层的形状是(batch_size, output_size)</li><li>3.类属性output_size:输出向量的大小</li></ul></li></ul><h3 id="2-定义一个基本的RNN单元"><a href="#2-定义一个基本的RNN单元" class="headerlink" title="2.定义一个基本的RNN单元"></a>2.定义一个基本的RNN单元</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">rnn_cell = tf<span class="selector-class">.nn</span><span class="selector-class">.rnn_cell</span><span class="selector-class">.BasicRNNCell</span>(num_units=<span class="number">128</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"rnn_cell.state_size:"</span>, rnn_cell.state_size)</span></span></span><br></pre></td></tr></table></figure><h3 id="3-定义一个基本的LSTM的基本单元"><a href="#3-定义一个基本的LSTM的基本单元" class="headerlink" title="3.定义一个基本的LSTM的基本单元"></a>3.定义一个基本的LSTM的基本单元</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lstm_cell = tf.nn.rnn_cell.LSTMCell(<span class="attribute">num_units</span>=128)</span><br><span class="line"><span class="builtin-name">print</span>(<span class="string">"lstm_cell.state_size:"</span>, lstm_cell.state_size)</span><br><span class="line"></span><br><span class="line">lstm_cell = tf.nn.rnn_cell.LSTMCell(<span class="attribute">num_units</span>=128) # <span class="attribute">batch_size</span>=32, <span class="attribute">input_size</span>=100</span><br><span class="line">inputs = tf.placeholder(np.float32, shape=(32, 100))</span><br><span class="line">h0 = lstm_cell.zero_state(32, np.float32)  # 通过zero_state得到一个全0的初始状态</span><br><span class="line">output, h1 = lstm_cell.__call__(inputs, h0)</span><br><span class="line"><span class="builtin-name">print</span>(h1.c)</span><br><span class="line"><span class="builtin-name">print</span>(h1.h)</span><br></pre></td></tr></table></figure><h3 id="4-对RNN进行堆叠：MultiRNNCell"><a href="#4-对RNN进行堆叠：MultiRNNCell" class="headerlink" title="4.对RNN进行堆叠：MultiRNNCell"></a>4.对RNN进行堆叠：MultiRNNCell</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次调用这个函数返回一个BasicRNNCell</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_a_cell</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.rnn_cell.BasicRNNCell(num_units=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用MultiRNNCell创建3层RNN</span></span><br><span class="line">cell = tf.nn.rnn_cell.MultiRNNCell([get_a_cell() <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">3</span>)])</span><br><span class="line"><span class="comment"># 得到的RNN也是RNNCell的子类,state_size=(128, 128, 128):三个隐层状态，每个隐层状态的大小是128</span></span><br><span class="line">print(cell.state_size)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 32是batch_size, 100是input_size</span></span><br><span class="line">inputs = tf.placeholder(np.float32, shape=(<span class="number">32</span>, <span class="number">100</span>))</span><br><span class="line">h0 = cell.zero_state(<span class="number">32</span>, np.float32)</span><br><span class="line">output, h1 = cell.__call__(inputs, h0)</span><br><span class="line">print(h1)</span><br></pre></td></tr></table></figure><h3 id="5-使用tf-nn-dunamic-rnn按时间展开：相当于增加了一个时间维度time-steps-通过-h0-x1-x2…-xn-得到-h1-h2-h3-…hn"><a href="#5-使用tf-nn-dunamic-rnn按时间展开：相当于增加了一个时间维度time-steps-通过-h0-x1-x2…-xn-得到-h1-h2-h3-…hn" class="headerlink" title="5.使用tf.nn.dunamic_rnn按时间展开：相当于增加了一个时间维度time_steps,通过{h0,x1,x2…,xn}得到{h1,h2,h3,…hn}"></a>5.使用tf.nn.dunamic_rnn按时间展开：相当于增加了一个时间维度time_steps,通过{h0,x1,x2…,xn}得到{h1,h2,h3,…hn}</h3><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inputs: shape=(batch_size, time_steps, input_size)  <span class="comment"># 输入数据的格式是(batch_size, time_steps, input_size)</span></span><br><span class="line">initial_state:  shape(batch_size,cell.state_size)  <span class="comment"># 初始状态,一般可以取零矩阵</span></span><br><span class="line">outputs, <span class="keyword">state</span> = tf.nn.dynamic_rnn(cell,inputs,initial_state)</span><br><span class="line"><span class="comment"># outputs是time_steps中所有的输出，形状是(batch_size, time_steps, cell.output_size)</span></span><br><span class="line"><span class="comment"># state是最后一步的隐状态，形状是(batch_size,cell.state_size)</span></span><br></pre></td></tr></table></figure><ul><li>注意：输入数据的形状是(time_steps,batch_size, input_size),可以调用tf.nn.dynamic_rnn()函数中设定参数time_major=True。此时，得到的outputs的形状是(time_steps, batch_size, cell.output_size);state的形状不变化</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-charRNN基础介绍&quot;&gt;&lt;a href=&quot;#0-charRNN基础介绍&quot; class=&quot;headerlink&quot; title=&quot;0.charRNN基础介绍&quot;&gt;&lt;/a&gt;0.charRNN基础介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;charRNN 是N vs N的循环神经
      
    
    </summary>
    
      <category term="深度学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorFlow" scheme="https://cdlwhm1217096231.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>Pandas中iloc、loc、ix三者的区别</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/Pandas%E4%B8%ADiloc%E3%80%81loc%E3%80%81ix%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://cdlwhm1217096231.github.io/数据分析/Pandas中iloc、loc、ix三者的区别/</id>
    <published>2019-07-29T11:40:56.000Z</published>
    <updated>2019-07-29T12:54:06.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、综述：iloc、loc、ix可以用来索引数据、抽取数据"><a href="#一、综述：iloc、loc、ix可以用来索引数据、抽取数据" class="headerlink" title="一、综述：iloc、loc、ix可以用来索引数据、抽取数据"></a>一、综述：iloc、loc、ix可以用来索引数据、抽取数据</h3><h3 id="二、iloc、loc、ix三者对比"><a href="#二、iloc、loc、ix三者对比" class="headerlink" title="二、iloc、loc、ix三者对比"></a>二、iloc、loc、ix三者对比</h3><ul><li><ol><li>iloc和loc的区别</li></ol><ul><li>iloc主要使用数字来索引数据，不能使用字符型的标签来索引数据。</li><li>loc只能使用字符型标签来索引数据，不能使用数字来索引数据。特殊情况：当dataframe的行标签或列标签为数字时，loc就可以来索引</li></ul></li><li><ol><li>行标签和列标签都是数字的情况<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(<span class="string">"a: \n"</span>, a)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(a)</span><br><span class="line">print(<span class="string">"df: \n"</span>, df)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"df.loc[0]: \n"</span>, df.loc[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">"df.iloc[0]: \n"</span>, df.iloc[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"df.loc[:,[0,3]]: \n"</span>, df.loc[:, [<span class="number">0</span>, <span class="number">3</span>]])</span><br><span class="line">print(<span class="string">"df.iloc[:, [0,3]]: \n"</span>, df.iloc[:, [<span class="number">0</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure></li></ol><ul><li><ol><li>将行标签[0, 1, 2]改为[‘a’,’b’,’c’]时的情况</li></ol></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df.index = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">print(<span class="string">"df: \n"</span>, df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(df.loc[0])  报错！TypeError: cannot do label indexing on &lt;class 'pandas.core.indexes.base.Index'&gt; with these indexers [0] of &lt;class 'int'&gt;</span></span><br><span class="line">print(<span class="string">"df.iloc[0]: \n"</span>, df.iloc[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"df.loc['a']: \n"</span>, df.loc[<span class="string">'a'</span>])</span><br><span class="line"><span class="comment"># print("df.iloc['a']: \n", df.iloc['a']) 报错！</span></span><br></pre></td></tr></table></figure><ul><li><ol><li>将列标签[0, 1, 2]改为[‘A’, ‘B’, ‘C’]时的情况</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df.columns = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]</span><br><span class="line">print(<span class="string">"df: \n"</span>, df)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"df.loc[:, 'A']: \n"</span>, df.loc[:, <span class="string">'A'</span>])</span><br><span class="line"><span class="comment"># print("df.iloc[:, 'A']: \n", df.iloc[:, 'A'])  报错！</span></span><br></pre></td></tr></table></figure><ul><li><ol><li>ix是一种混合索引，字符型标签和整型索引都可以使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"df.ix[0]: \n"</span>, df.ix[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">"df.ix['a']: \n"</span>, df.ix[<span class="string">'a'</span>])</span><br><span class="line">print(<span class="string">"df.ix[:, 0]: \n"</span>, df.ix[:, <span class="number">0</span>])</span><br><span class="line">print(<span class="string">"df.ix[:, 'A']: \n"</span>, df.ix[:, <span class="string">'A'</span>])</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="三、参考博客"><a href="#三、参考博客" class="headerlink" title="三、参考博客"></a>三、参考博客</h3><p><a href="https://blog.csdn.net/niuniuyuh/article/details/76650904" target="_blank" rel="noopener">CSDN博客链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、综述：iloc、loc、ix可以用来索引数据、抽取数据&quot;&gt;&lt;a href=&quot;#一、综述：iloc、loc、ix可以用来索引数据、抽取数据&quot; class=&quot;headerlink&quot; title=&quot;一、综述：iloc、loc、ix可以用来索引数据、抽取数据&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="数据分析" scheme="https://cdlwhm1217096231.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="https://cdlwhm1217096231.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="Python3" scheme="https://cdlwhm1217096231.github.io/tags/Python3/"/>
    
      <category term="Pandas" scheme="https://cdlwhm1217096231.github.io/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础知识点总结</title>
    <link href="https://cdlwhm1217096231.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/计算机网络/计算机网络基础知识点总结/</id>
    <published>2019-07-29T11:37:29.000Z</published>
    <updated>2019-07-30T14:49:04.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-互联网的组成"><a href="#0-互联网的组成" class="headerlink" title="0.互联网的组成"></a>0.互联网的组成</h3><ul><li>边缘部分：所有连接在互联网上的主机（主机指的是所有与网络直接相连的计算机）组成，用户可以直接使用，用来进行主机之间的通信和资源共享。</li><li>核心部分：大量的网络与连接这些网络所使用的路由器构成，为边缘部分提供服务。</li><li>边缘部分总结<ul><li>边缘部分主要使用核心部分所提供的服务，使得许多主机之间能够互相通信并进行交换或共享信息。计算机之间的通信指的是主机A上的一个进程与主机B上的另一个进程之间进行通信。通信的方式主要有两种：<ul><li>客户-服务器方式：即C /S方式。客户端发送服务的请求，服务器是服务的提供方。</li><li>P2P：对等连接方式。两台通信的主机之间不区分哪个是客户，哪个是服务端，只要两台主机都运行了对等连接软件就可以进行平等、对等的连接通信。</li></ul></li></ul></li><li>核心部分总结<ul><li>核心部分起到特殊作用的是路由器，它是一个专用的计算机，主要作用是<strong>分组交换和存储转发</strong>的功能。<ul><li>电路交换：使用在电话机之间的通信，使用电话交换机解决了多个电话机之间通信需要大量的电线的问题。电路交换的过程是：<strong>建立连接(开始占用通信资源)—-通话(一直占用通信资源)——释放连接(归还通信资源)</strong>。电路交换的特点是：通话期间，通话的两个用户会始终占用通信资源。使用电路交换传输计算机数据时，传输效率往往会很低。因为计算机数据具有突变式的特点，线路上真正用来传输数据的时间往往不到10%,大部分通信线路资源绝大部分时间都被浪费了。<strong>整个报文的比特流连续的从源点直达终点</strong></li><li>分组交换：采用<strong>存储转发的技术</strong>，把一个报文（需要发生出去的整块数据）划分成几组分组后再进行传输。将报文划分成更小的等长数据段，然后加上首部(包含一些控制信息)，构成了一个分组，分组的首部称为一个包头。<strong>单个分组（只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</strong></li><li>报文交换：<strong>整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</strong></li><li>路由器的工作流程：路由器接收到一个分组后，暂存数据到路由器自己的缓存中即自身的存储器中，然后检查其首部，查找转发表。按照首部中的目的地址，找到合适的接口转发除去，把分组交给下一个路由器。这样一步一步以存储转发的方式，把分组交给最终的目的主机。<strong>路由器只是暂存一个分组，不是整个报文。分组在哪段链路上传送时才会占用此段链路上的通信资源，在各分组传输之间的空闲时间，此链路也是可以被其他主机发送的分组使用。</strong><h4 id="计算机网络中的常见硬件设备介绍："><a href="#计算机网络中的常见硬件设备介绍：" class="headerlink" title="计算机网络中的常见硬件设备介绍："></a>计算机网络中的常见硬件设备介绍：</h4></li></ul></li></ul></li><li>物理层：实现网络互连的主要设备有<strong>中继器和HUB(集线器)</strong></li><li>数据链路层：实现网络互联的主要设备有<strong>二层交换机和网桥</strong></li><li>网络层：实现网络互连的主要设备有<strong>三层交换机和路由器</strong></li><li>传输层（包括传输层）以上：实现网络互连的设备有<strong>网关</strong></li></ul><h3 id="1-计算机网络体系结构"><a href="#1-计算机网络体系结构" class="headerlink" title="1.计算机网络体系结构"></a>1.计算机网络体系结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/13407176-7fe56a6a91c93d29?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><ul><li><strong>应用层</strong>：应用层是体系结构中的最高层。应用层直接为用户的应用进程程序提供服务。这里的进程就是指正在运行的程序。在因特网中的应用层协议很多，如支持万维网应用的http协议支持电子邮件的SMTP协议，支持文件传送的FTP协议等。</li><li><strong>运输层</strong>：运输层的任务就是负责向两个主机中进程之间的通信提供服务。由于一个主机可以同时运行多个进程，因此运输层有复用和分用的功能。复用就是多个应用层进程可以同时使用下面运输层的服务，分用就是运输层把收到的信息分别交付给上面应用层中的相应进程。<ul><li>运输层主要使用下面两个协议：<ul><li>传输控制协议TCP：面向连接的，数据传输的基本单位是报文段，能够提供可靠的交付</li><li>用户数据包协议UDP：无连接的，数据传输的基本单位是用户数据报，不能保证提供可靠的交付，只能提供<strong>尽最大努力交付</strong>。</li></ul></li></ul></li><li><strong>网络层</strong>：  负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫作IP数据报。</li><li><strong>数据链路层</strong>：两个主机之间的数据传输，总是在一段一段的链路上传送的。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上透明地传送帧中的数据，每一帧包括数据和必要的控制信息。</li><li><strong>物理层</strong>：在物理层上传送的数据单位是比特。物理层的任务就是透明地传送比特流。</li></ul><h3 id="2-各层的作用和支持的协议"><a href="#2-各层的作用和支持的协议" class="headerlink" title="2.各层的作用和支持的协议"></a>2.各层的作用和支持的协议</h3><p><img src="https://upload-images.jianshu.io/upload_images/13407176-8576f94e43f01841?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h3 id="3-物理层"><a href="#3-物理层" class="headerlink" title="3.物理层"></a>3.物理层</h3><ul><li>传输数据的基本单位：比特流0和1</li><li>数据传输系统：源系统（源点、发送器） —&gt; 传输系统 —&gt; 目的系统（接收器、终点）</li><li>通道：<ul><li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li><li>双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li></ul></li><li>通道复用技术：<ul><li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li><li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li><li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li><li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li></ul></li></ul><h3 id="4-数据链路层"><a href="#4-数据链路层" class="headerlink" title="4.数据链路层"></a>4.数据链路层</h3><ul><li>主要信道：<ul><li>点对点信道</li><li>广播信道</li></ul></li><li>点对点信道：<ul><li>数据单元：帧</li><li>三个基本问题：<ul><li>封装成帧：把网络层的 IP 数据报封装成帧，SOH - 数据部分 - EOT</li><li>透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）</li><li>差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）</li></ul></li><li>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</li></ul></li><li>广播信道：<ul><li>硬件地址（物理地址、MAC 地址）</li><li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li><li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li><li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li></ul></li></ul><h3 id="5-网络层"><a href="#5-网络层" class="headerlink" title="5.网络层"></a>5.网络层</h3><ul><li>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</li><li>ARP（Address Resolution Protocol，地址解析协议）</li><li>ICMP（Internet Control Message Protocol，网际控制报文协议）</li><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li></ul><h4 id="5-1-IP网际协议"><a href="#5-1-IP网际协议" class="headerlink" title="5.1 IP网际协议"></a>5.1 IP网际协议</h4><ul><li>IP地址<strong>({&lt;网络号&gt;,&lt;主机号&gt;})</strong>分类：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-d17fd5c720d09ac7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP地址分类"></li><li>IP数据报格式：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-6c51c50ec528c7e5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP数据报格式"></li></ul><h4 id="5-2-ICMP网际控制报文协议"><a href="#5-2-ICMP网际控制报文协议" class="headerlink" title="5.2 ICMP网际控制报文协议"></a>5.2 ICMP网际控制报文协议</h4><ul><li>ICMP报文格式：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-6b5180a4aef64d5c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" ICMP报文格式"></li><li>应用：<ul><li>PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性</li><li>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</li></ul></li></ul><h4 id="5-3-内部网关协议"><a href="#5-3-内部网关协议" class="headerlink" title="5.3 内部网关协议"></a>5.3 内部网关协议</h4><ul><li>RIP（Routing Information Protocol，路由信息协议）</li><li>OSPF（Open Sortest Path First，开放最短路径优先）</li></ul><h4 id="5-4-外部网关协议"><a href="#5-4-外部网关协议" class="headerlink" title="5.4 外部网关协议"></a>5.4 外部网关协议</h4><ul><li>BGP（Border Gateway Protocol，边界网关协议）</li></ul><h4 id="5-5-IP多播"><a href="#5-5-IP多播" class="headerlink" title="5.5 IP多播"></a>5.5 IP多播</h4><ul><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li><li>多播路由选择协议</li></ul><h4 id="5-6-VPN和NAT"><a href="#5-6-VPN和NAT" class="headerlink" title="5.6 VPN和NAT"></a>5.6 VPN和NAT</h4><ul><li>VPN（Virtual Private Network，虚拟专用网）</li><li>NAT（Network Address Translation，网络地址转换）</li></ul><h4 id="5-7-路由表包含什么？"><a href="#5-7-路由表包含什么？" class="headerlink" title="5.7 路由表包含什么？"></a>5.7 路由表包含什么？</h4><ul><li>网络 ID（Network ID, Network number）：就是目标地址的网络 ID。</li><li>子网掩码（subnet mask）：用来判断 IP 所属哪个子网络</li><li>下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: 0.0.0.0, Netmask: 0.0.0.0）指向自治系统的出口。</li><li>根据应用和执行的不同，路由表可能含有如下附加信息：<ul><li>花费（Cost）：就是数据发送过程中通过路径所需要的花费</li><li>路由的服务质量</li><li>路由中需要过滤的出/入连接列表</li></ul></li></ul><h3 id="6-传输层"><a href="#6-传输层" class="headerlink" title="6.传输层"></a>6.传输层</h3><ul><li>支持的协议：<ul><li>TCP（Transmission Control Protocol，传输控制协议）</li><li>UDP（User Datagram Protocol，用户数据报协议）</li></ul></li><li>端口号：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-5c31b958235daae0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="端口号"></li></ul><h4 id="6-1-TCP（Transmission-Control-Protocol，传输控制协议）"><a href="#6-1-TCP（Transmission-Control-Protocol，传输控制协议）" class="headerlink" title="6.1 TCP（Transmission Control Protocol，传输控制协议）"></a>6.1 TCP（Transmission Control Protocol，传输控制协议）</h4><ul><li>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。</li><li>特征：<ul><li>面向连接</li><li>只能点对点（一对一）通信</li><li>可靠交互</li><li>全双工通信</li><li>面向字节流</li></ul></li><li>TCP如何保证可靠传输？<ul><li>确认和超时重传</li><li>数据合理分片和排序</li><li>流量控制</li><li>拥塞控制</li><li>数据校验</li></ul></li><li>TCP报文结构<br><img src="https://upload-images.jianshu.io/upload_images/13407176-b75609962acd02c7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP报文结构"></li><li>TCP首部<br><img src="https://upload-images.jianshu.io/upload_images/13407176-00e1f7be59ced0c3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP首部"></li><li>TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：<ul><li>URG：紧急比特（urgent），当 URG＝1 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。</li><li>ACK：确认比特（Acknowledge）。只有当 ACK＝1 时确认号字段才有效，代表这个封包为确认封包。当 ACK＝0 时，确认号无效。</li><li>PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。</li><li>RST：复位比特(Reset)，当 RST＝1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li><li>SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。</li><li>FIN：终止比特(Final)，用来释放一个连接。当 FIN＝1 时，表明此报文段的发送端的数据已发送完毕，并要求释放传输连接。</li></ul></li></ul><h4 id="6-2-UDP（User-Datagram-Protocol，用户数据报协议）"><a href="#6-2-UDP（User-Datagram-Protocol，用户数据报协议）" class="headerlink" title="6. 2 UDP（User Datagram Protocol，用户数据报协议）"></a>6. 2 UDP（User Datagram Protocol，用户数据报协议）</h4><ul><li>UDP是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。</li><li>特征：<ul><li>无连接</li><li>尽最大努力交付</li><li>面向报文</li><li>没有拥塞控制</li><li>支持一对一、一对多、多对多的交互通信</li><li>首部开销小</li></ul></li><li>UDP报文结构<br><img src="https://upload-images.jianshu.io/upload_images/13407176-34146b4de4078b50?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP报文结构"></li><li>UDP首部<br><img src="https://upload-images.jianshu.io/upload_images/13407176-2aee214a6316bad1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP首部"></li></ul><h4 id="6-3-TCP与UDP的区别"><a href="#6-3-TCP与UDP的区别" class="headerlink" title="6.3 TCP与UDP的区别"></a>6.3 TCP与UDP的区别</h4><ul><li>TCP面向连接、UDP是无连接的；</li><li>TCP提供可靠的服务、也就是说，通过TCP连接传输的数据是无差错、不丢失、不重复且按序到达；UDP尽最大努力交付，即不保证可靠交付</li><li>TCP的逻辑通信信息是全双工的可靠信息；UDP则是不可靠信息</li><li>每一条TCP连接只能是点对点的；UDP支持一对多、多对一、多对多的交互通信</li><li>TCP面向字节流(可能会出现黏包问题)，实际上是TCP白数据看成一连串无结构的字节流；UDP是面向报文的(不会出现黏包问题)</li><li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如IP电话，实时视频会议等)</li><li>TCP首部开销20字节；UDP的首部开销小，只有8字节</li></ul><h4 id="6-4-TCP的黏包问题"><a href="#6-4-TCP的黏包问题" class="headerlink" title="6.4 TCP的黏包问题"></a>6.4 TCP的黏包问题</h4><ul><li>出现黏包问题的原因：TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的，所以可能会出现两个数据包黏在一起的情况。</li><li>解决方法：<ul><li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li><li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li><li>在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。</li><li>使用更加复杂的应用层协议<h4 id="6-5-TCP流量控制"><a href="#6-5-TCP流量控制" class="headerlink" title="6.5 TCP流量控制"></a>6.5 TCP流量控制</h4></li></ul></li><li>概念：流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。</li><li>方法：利用可变窗口进行流量控制<br><img src="https://upload-images.jianshu.io/upload_images/13407176-89d12260a132081f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流量控制"></li></ul><h4 id="6-6-TCP拥塞控制"><a href="#6-6-TCP拥塞控制" class="headerlink" title="6.6 TCP拥塞控制"></a>6.6 TCP拥塞控制</h4><ul><li>概念：拥塞控制就是防止过多的数据注入到网络中，可以使网络中的路由器或链路不致过载。</li><li>解决方法：<ul><li>慢启动( slow-start )</li><li>拥塞避免( congestion avoidance )</li><li>快重传( fast retransmit )</li><li>快恢复( fast recovery )<br><img src="https://upload-images.jianshu.io/upload_images/13407176-163d146352f644df?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP拥塞窗口cwnd在拥塞控制时的变化情况"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-712bcfb5f81b82b0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP的拥塞控制流程图"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-9c1c63e1f94a6aff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="快重传"></li></ul></li></ul><h4 id="6-7-TCP传输连接管理-重点"><a href="#6-7-TCP传输连接管理-重点" class="headerlink" title="6.7 TCP传输连接管理(重点)"></a><strong>6.7 TCP传输连接管理(重点)</strong></h4><ul><li>一.TCP建立连接：三次握手<br><img src="https://upload-images.jianshu.io/upload_images/13407176-2c267347f110bf71?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP三次握手建立连接"></li><li>TCP 建立连接全过程解释：<ul><li>1.客户端发生SYN给服务器，表示客户端向服务器请求建立连接；</li><li>2.服务端收到客户端的SYN，并回复SYN+ACK给客户端(同意建立连接)；</li><li>3.客户端收到来自服务器的SYN+ACK后，回复ACK给服务端(表示客户端收到了服务端发的同意报文)；</li><li>4.服务端收到客户端的ACK，连接已建立，可以进行数据传输。</li></ul></li><li>建立连接的详细过程：<ul><li>a.B的TCP服务器进程首先创建传输控制块TCB,准备接受客户进程的连接请求。然后服务器进程就处于LISTEN(收听)状态，等待客户的连接请求。如有，就做出响应。</li><li>b.A的TCP客户进程也是首先创建传输控制模块TCB，然后向B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq=x。TCP规定，SYN报文段(即SYN=1的报文段)不能携带数据，但是要消耗一个序号。这时，TCP客户进程进入SYN-SENT(同步已发送)状态。</li><li>c.B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中应把SYN和ACK位都置1，确认号是ack=x+1,同时也为自己选择一个初始序号seq=y。注意：<strong>这个报文段也不能携带数据，但同样要消耗一个序号</strong>。这时TCP服务器进程进入SYN-RECV(同步收到)状态。</li><li>d.TCP客户进程收到B的确认后，还要向B给出确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。<strong>TCP标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号</strong>。在这种情况下，下一个数据报文段的序号仍然是seq=x+1。这时，TCP的连接已经建立，A进入ESTABLISHED(已建立连接)状态。当B接收到A的确认后，B也进入ESTABLISHED(已建立连接)状态。</li></ul></li><li>Q1：TCP为什么要进行三次握手？<ul><li>因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。(而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手)</li><li>因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信</li><li>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</li></ul></li><li>二.TCP断开连接：四次挥手<br><img src="https://upload-images.jianshu.io/upload_images/13407176-7c3eb002a1527b14?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP四次挥手释放连接"><ul><li>TCP 断开连接全过程解释：<ul><li>1.客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；</li><li>2.服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；</li><li>3.客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；</li><li>4.服务端继续发送之前没发完的数据给客户端；</li><li>5.服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；</li><li>6.服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；</li><li>7.服务端收到客户端的 ACK 后，断开从服务端到客户端的连接</li></ul></li><li>释放连接的详细过程：<ul><li>a.A和B都处于ESTABLISHED状态，A的应用进程首先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。A把连接释放报文段首部的FIN置1，其序列号seq=u，它等于前面已经传送过的数据的最后一个字节的序号加1。这时，A进入FIN-WAIT-1(终止等待1)状态，等待B的确认。<strong>注意：TCP规定：FIN报文段即使不携带数据，它也会消耗一个序号。</strong></li><li>b.B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等待B前面已经传送过的数据的最后一个字节的序号加1。然后B就进入CLOSE-WAIT(关闭等待)状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍要接收。也就是说，从B到A这个方向的连接并没有关闭，这个连接可能会持续一段时间。</li><li>c.A收到来自B的确认后，就进入FIN-WAIT-2(终止等待2)状态，等待B发出的连接释放报文段。如果B已经没有要向A发送的数据，其应用进程就会通知TCP释放连接。这时B发出的连接释放报文段必须使FIN=1。现假定B的序号为w(在半关闭状态B可能又发送了一些数据)。B还必须重复上次已经发送过的确认号ack=u+1。这时，B就进入LAST-ACK(最后确认状态)，等待A的确认。</li><li>d.A在收到B的释放连接报文段后，必须对此发出一个确认。在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1(根据TCP标准，前面发送过的FIN报文段要消耗一个序号)。然后经过时间等待计时器(TIME-WAIT)设置的时间2MSL后，A才进入到CLOSED状态。时间MSL叫做最长报文段寿命</li></ul></li><li>Q2：TCP 为什么要进行四次挥手？<ul><li>因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</li></ul></li><li>Q3：为什么 TCP 建立连接时可以 ACK 和 SYN 一起发送，而断开连接时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）<ul><li>因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。</li></ul></li><li>Q4：为什么客户端断开连接时，最后需要 TIME-WAIT 等待 2MSL 呢？<ul><li>1.为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li><li>2.防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。<h4 id="6-8-TCP有限状态机"><a href="#6-8-TCP有限状态机" class="headerlink" title="6.8 TCP有限状态机"></a>6.8 TCP有限状态机</h4><img src="https://upload-images.jianshu.io/upload_images/13407176-9997deb1e8e31655?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP的有限状态机"></li></ul></li></ul></li></ul><h3 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7.应用层"></a>7.应用层</h3><h4 id="7-1-DNS-Domain-Name-System，域名系统"><a href="#7-1-DNS-Domain-Name-System，域名系统" class="headerlink" title="7.1 DNS(Domain Name System，域名系统)"></a>7.1 DNS(Domain Name System，域名系统)</h4><ul><li>DNS是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。<ul><li>域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}，如：blog.huihut.com</li></ul></li></ul><h4 id="7-2-FTP-File-Transfer-Protocol，文件传输协议"><a href="#7-2-FTP-File-Transfer-Protocol，文件传输协议" class="headerlink" title="7.2 FTP(File Transfer Protocol，文件传输协议)"></a>7.2 FTP(File Transfer Protocol，文件传输协议)</h4><ul><li>FTP是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</li><li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</li></ul><h4 id="7-3-TELNET"><a href="#7-3-TELNET" class="headerlink" title="7.3 TELNET"></a>7.3 TELNET</h4><ul><li>TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</li></ul><h4 id="7-4-HTTP（HyperText-Transfer-Protocol，超文本传输协议）"><a href="#7-4-HTTP（HyperText-Transfer-Protocol，超文本传输协议）" class="headerlink" title="7.4 HTTP（HyperText Transfer Protocol，超文本传输协议）"></a>7.4 HTTP（HyperText Transfer Protocol，超文本传输协议）</h4><ul><li>HTTP是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。</li></ul><h4 id="7-5-SMTP（Simple-Mail-Transfer-Protocol，简单邮件传输协议）"><a href="#7-5-SMTP（Simple-Mail-Transfer-Protocol，简单邮件传输协议）" class="headerlink" title="7.5 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）"></a>7.5 SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</h4><ul><li>SMTP是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。它是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器，SMTP 使用 TCP 端口 25。</li></ul><h4 id="7-6-DHCP（Dynamic-Host-Configuration-Protocol，动态主机设置协议）"><a href="#7-6-DHCP（Dynamic-Host-Configuration-Protocol，动态主机设置协议）" class="headerlink" title="7.6 DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）"></a>7.6 DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）</h4><ul><li>DHCP是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：<ul><li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li><li>用于内部网络管理员作为对所有电脑作中央管理的手段</li></ul></li></ul><h4 id="7-7-SNMP（Simple-Network-Management-Protocol，简单网络管理协议）"><a href="#7-7-SNMP（Simple-Network-Management-Protocol，简单网络管理协议）" class="headerlink" title="7.7 SNMP（Simple Network Management Protocol，简单网络管理协议）"></a>7.7 SNMP（Simple Network Management Protocol，简单网络管理协议）</h4><ul><li>SNMP构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</li></ul><h3 id="8-相关概念"><a href="#8-相关概念" class="headerlink" title="8.相关概念"></a>8.相关概念</h3><h4 id="8-1-Socket（套接字）"><a href="#8-1-Socket（套接字）" class="headerlink" title="8.1 Socket（套接字）"></a>8.1 Socket（套接字）</h4><ul><li>Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。</li></ul><h4 id="8-2-WWW（World-Wide-Web，环球信息网，万维网）"><a href="#8-2-WWW（World-Wide-Web，环球信息网，万维网）" class="headerlink" title="8.2 WWW（World Wide Web，环球信息网，万维网）"></a>8.2 WWW（World Wide Web，环球信息网，万维网）</h4><ul><li>WWW是一个由许多互相链接的超文本组成的系统，通过互联网访问<h4 id="8-3-URL（Uniform-Resource-Locator，统一资源定位符）"><a href="#8-3-URL（Uniform-Resource-Locator，统一资源定位符）" class="headerlink" title="8.3 URL（Uniform Resource Locator，统一资源定位符）"></a>8.3 URL（Uniform Resource Locator，统一资源定位符）</h4></li><li>概念：URL是因特网上标准的资源的地址（Address）</li><li>标准格式：协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</li><li>完整格式：协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]  注意：其中[访问凭证信息@；:端口号；?查询；#片段ID]都属于选填项,可以省略，如：<a href="https://github.com/cdlwhm1217096231" target="_blank" rel="noopener">https://github.com/cdlwhm1217096231</a></li></ul><h3 id="9-HTTP详解"><a href="#9-HTTP详解" class="headerlink" title="9.HTTP详解"></a>9.HTTP详解</h3><ul><li>概念：HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</li><li>请求方法：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-96c25506dffe9b6f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="请求方法"></li><li>状态码：<ul><li>1xx：表示通知信息，如请求收到了或正在进行处理<ul><li>100 Continue：继续，客户端应继续其请求</li><li>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li></ul></li><li>2xx：表示成功，如接收或知道了<ul><li>200 OK: 请求成功</li></ul></li><li>3xx：表示重定向，如要完成请求还必须采取进一步的行动<ul><li>301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替</li></ul></li><li>4xx：表示客户的差错，如请求中有错误的语法或不能完成<ul><li>400 Bad Request: 客户端请求的语法错误，服务器无法理解</li><li>401 Unauthorized: 请求要求用户的身份认证</li><li>403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）</li><li>404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面</li><li>408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时</li></ul></li><li>5xx：表示服务器的差错，如服务器失效无法完成请求<ul><li>500 Internal Server Error: 服务器内部错误，无法完成请求</li><li>503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</li><li>504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求</li></ul></li></ul></li></ul><h3 id="10-DNS-域名解析协议"><a href="#10-DNS-域名解析协议" class="headerlink" title="10.DNS(域名解析协议)"></a>10.DNS(域名解析协议)</h3><ul><li>DNS劫持：指用户访问一个被标记的地址时，DNS服务器故意将此地址指向一个错误的IP地址的行为。范例：收到各种推送广告等网站</li><li>DNS污染：指的是用户访问一个地址，国内的服务器(非DNS)监控到用户访问的已经被标记地址时，服务器伪装成DNS服务器向用户发回错误的地址的行为。比如不能访问Google、YouTube等。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;0-互联网的组成&quot;&gt;&lt;a href=&quot;#0-互联网的组成&quot; class=&quot;headerlink&quot; title=&quot;0.互联网的组成&quot;&gt;&lt;/a&gt;0.互联网的组成&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;边缘部分：所有连接在互联网上的主机（主机指的是所有与网络直接相连的计算机）组成，
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://cdlwhm1217096231.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://cdlwhm1217096231.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP协议栈" scheme="https://cdlwhm1217096231.github.io/tags/TCP-IP%E5%8D%8F%E8%AE%AE%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode刷题记录</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://cdlwhm1217096231.github.io/数据结构与算法/Leetcode刷题记录/</id>
    <published>2019-07-29T11:33:19.000Z</published>
    <updated>2019-07-29T11:34:02.147Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>递归方法和循环方法的对比</strong></li><li>递归方法代码实现比较简洁，但是性能不如循环方法，还有可能出现栈溢出的问题。一般情况下优先考虑递归方法来实现！</li><li><strong>搜索路径的题目</strong>：一般使用回溯法，回溯法很适合使用递归方法的代码来实现！当要求不能使用递归实现的时候，考虑使用栈模拟递归的过程</li><li><strong>求某个问题的最优解时，并且该问题可以拆分为多个子问题时</strong>：可以尝试使用动态规划的方法！在使用自上而下的递归思路去分析动态规划问题时，会发现子问题之间存在重叠<br>的更小的子问题。为了避免不必要的重复计算，使用自下而上的循环代码来实现，即把子问题的最优解先计算出来并用数组保存下来，然后基于子问题的解计算大问题的解。</li><li><strong>特殊情况</strong>：在分解子问题的时候存在某个特殊的选择，采用这个特殊的选择将一定那个得到最优解，则此题目可能适用于贪心算法！</li><li><strong>典型题目的解题思路</strong>：在一个已经排好序的数组中查找一个数字或者统计某个数字出现的次数，可以尝试使用二分查找算法！</li><li>Q1:给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。<strong>注意：答案中不可以包含重复的三元组。</strong></li><li><p>自己写的：暴力解决，时间复杂度太大</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Solution</span>(<span class="keyword">object</span>):</span><br><span class="line">    def threeSum(self, nums):</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="literal">result</span> = []</span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(j + <span class="number">1</span>, len(nums)):</span><br><span class="line">                    <span class="keyword">if</span> nums[i] + nums[j] + nums[k] == <span class="number">0</span>:</span><br><span class="line">                        <span class="literal">result</span>.append([nums[i], nums[j], nums[k]])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(len(<span class="literal">result</span>)):</span><br><span class="line">            <span class="keyword">if</span> <span class="literal">result</span>[i] <span class="keyword">not</span> <span class="keyword">in</span> temp:</span><br><span class="line">                temp.append(<span class="literal">result</span>[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    s = <span class="type">Solution</span>()</span><br><span class="line">    <span class="literal">result</span> = s.threeSum([-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>, <span class="number">3</span>, -<span class="number">5</span>, -<span class="number">2</span>, -<span class="number">3</span>])</span><br><span class="line">    print(<span class="literal">result</span>)</span><br></pre></td></tr></table></figure></li><li><p>网上大神的解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="comment"># 存储结果列表</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 对nums列表进行排序，无返回值，排序直接改变nums顺序</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="comment"># 因为是升序排列，如果排序后第一个数都大于0，则跳出循环，不可能有为0的三数之和</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 排序后相邻两数如果相等，则跳出当前循环继续下一次循环，相同的数只需要计算一次</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 记录i的下一个位置</span></span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 最后一个元素的位置</span></span><br><span class="line">            k = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                <span class="comment"># 判断三数之和是否为0</span></span><br><span class="line">                <span class="keyword">if</span> nums[j] + nums[k] == -nums[i]:</span><br><span class="line">                    <span class="comment"># 把结果加入数组中</span></span><br><span class="line">                    result.append([nums[i], nums[j], nums[k]])</span><br><span class="line">                    <span class="comment"># 判断j相邻元素是否相等，有的话跳过这个</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[j] == nums[j+<span class="number">1</span>]: j += <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 判断后面k的相邻元素是否相等，是的话跳过</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k <span class="keyword">and</span> nums[k] == nums[k<span class="number">-1</span>]: k -= <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 没有相等则j+1，k-1，缩小范围</span></span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="comment"># 小于-nums[i]的话还能往后取</span></span><br><span class="line">                <span class="keyword">elif</span> nums[j] + nums[k] &lt; -nums[i]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li><li><p>Q2:见下图<br><img src="https://upload-images.jianshu.io/upload_images/13407176-7d98c1f7b72578aa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="罗马数字转整数.jpg"></p></li><li><p>A2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    d = &#123;<span class="string">'M'</span>: <span class="number">1000</span>,<span class="string">'D'</span>: <span class="number">500</span> ,<span class="string">'C'</span>: <span class="number">100</span>,<span class="string">'L'</span>: <span class="number">50</span>,<span class="string">'X'</span>: <span class="number">10</span>,<span class="string">'V'</span>: <span class="number">5</span>,<span class="string">'I'</span>: <span class="number">1</span>&#125;</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    s_len = len(s)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(s_len<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> d[s[i]] &lt; d[s[i+<span class="number">1</span>]]:</span><br><span class="line">            result -= d[s[i]]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result += d[s[i]]</span><br><span class="line">    result += d[s[<span class="number">-1</span>]]</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li><li><p>Q3:编写一个函数来查找字符串数组中的最长公共前缀,如果不存在公共前缀，返回空字符串 “”。</p></li><li><p>A3：仅仅比较最长与最短的字符串，如果存在相同的前缀就返回；不存在就返回一个空字符串。重要的是如何从两个字符串中取相同位置的字符进行比较。</p>  <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">def</span> longest_str(<span class="keyword">strs):</span></span><br><span class="line"><span class="keyword"> </span>   <span class="built_in">s1</span> = min(<span class="keyword">strs) </span> # 最短字符串</span><br><span class="line">    <span class="built_in">s2</span> = max(<span class="keyword">strs) </span># 最长字符串</span><br><span class="line">    for i, v in enumerate(<span class="built_in">s1</span>):</span><br><span class="line">        <span class="meta">if</span> v != <span class="built_in">s2</span>[i]:</span><br><span class="line">            return <span class="built_in">s2</span>[:i]   # 当第一个字符就不相等时,返回<span class="built_in">s2</span>[:<span class="number">0</span>]=[],执行下面的<span class="meta">if</span>语句</span><br><span class="line">    <span class="meta">if</span> not <span class="keyword">strs:</span></span><br><span class="line"><span class="keyword"> </span>       return <span class="string">""</span></span><br><span class="line"><span class="symbol">if</span>  __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">strs </span>= [<span class="string">"dog"</span>, <span class="string">"racecar"</span>, <span class="string">"car"</span>]</span><br><span class="line">    <span class="keyword">strs1 </span>= [<span class="string">"flower"</span>, <span class="string">"flow"</span>, <span class="string">"flight"</span>]</span><br><span class="line">    result = longest_str(<span class="keyword">strs)</span></span><br><span class="line"><span class="keyword"> </span>   result1 = longest_str(<span class="keyword">strs1)</span></span><br><span class="line"><span class="keyword"> </span>   print(result)</span><br><span class="line">    print(result1)</span><br></pre></td></tr></table></figure></li><li><p>Q4:给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：<strong>左括号必须用相同类型的右括号闭合;左括号必须以正确的顺序闭合;注意空字符串可被认为是有效字符串</strong></p></li><li><p>A4:只有完整出现[],{},()的情况才会返回true,同时空字符串也被任何是有效字符串,所以,用空格进行替换[],{},()，然后比较替换后的结果是否是空字符串，不是的话说明不是有效字符串。</p>  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_Valid</span><span class="params">(s)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="string">"&#123;&#125;"</span> <span class="keyword">in</span>  s <span class="keyword">or</span> <span class="string">"()"</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">"[]"</span> <span class="keyword">in</span> s)<span class="symbol">:</span></span><br><span class="line">        s = s.replace(<span class="string">"&#123;&#125;"</span>, <span class="string">""</span>)</span><br><span class="line">        s = s.replace(<span class="string">"()"</span>, <span class="string">""</span>)</span><br><span class="line">        s = s.replace(<span class="string">"[]"</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> s == <span class="string">""</span></span><br></pre></td></tr></table></figure></li><li><p>Q5:将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 例如，输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4；输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></li><li><p>A5:</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span>&#123;</span><br><span class="line">    int val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span> *next;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// 借助归并排序的思路，递归方法实现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span>* mergeTwoLists(<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span> *l1, <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span> *l2)&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span> *p;</span><br><span class="line">    <span class="keyword">if</span> (!l1)</span><br><span class="line">        retutn l2;</span><br><span class="line">    <span class="keyword">if</span> (!l2)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;   <span class="comment">// 将两个链表中小的元素放在新的链表中，用指针p指向它</span></span><br><span class="line">        p = l1;</span><br><span class="line">        p-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p = l2;</span><br><span class="line">        p-&gt;next = mergeTwoLists(l2-&gt;next,l1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Q6:给定一个排序数组，你需要在<strong>原地</strong>删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。</p></li><li><p>A6:</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int removeDuplicates(int *nums, int numsSize)&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> numsSize;</span><br><span class="line">    int <span class="built_in">i</span>, <span class="built_in">j</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">i</span>=<span class="number">1</span>;<span class="built_in">i</span>&lt;numsSize;<span class="built_in">i</span>++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="built_in">j</span>] != nums[<span class="built_in">i</span>])</span><br><span class="line">                nums[++<span class="built_in">j</span>]=nums[<span class="built_in">i</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">j</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Q7:给定一个数组 nums 和一个值 val，你需要<strong>原地</strong>移除所有数值等于 <strong>val</strong>的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在<strong>原地修改输入数组</strong>并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p></li><li><p>A7:</p>  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int removeElement(int* nums, int numsSize, int val)&#123;</span><br><span class="line">    int <span class="built_in">i</span>,<span class="built_in">j</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span> &lt; numsSize;<span class="built_in">i</span>++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="built_in">i</span>] != val)</span><br><span class="line">            nums[<span class="built_in">j</span>++] = nums[<span class="built_in">i</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">j</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Q8:统计小于非负整数n的质数的个数。例如。n=10,则输出小于10的质数个数是4个，具体是2, 3, 5, 7。</p></li><li><p>A8:使用<strong>厄拉多塞筛法</strong>：首先从数字2开始，依次删除2的倍数；接着从3开始，依次删除3的倍数，然后从5开始(因为4是2的倍数，已经被删除了)，依次删除5的倍数。一直循环上面的步骤的n-1即可，然后统计最后剩余的数的个数，即质数的个数。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">self</span>, <span class="symbol">n:</span> int)</span></span> -&gt; <span class="symbol">int:</span></span><br><span class="line">       <span class="keyword">if</span> n&lt;=<span class="number">2</span><span class="symbol">:</span></span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">       isPrime = [<span class="number">1</span>] * n  <span class="comment"># 生成一个全为1的列表</span></span><br><span class="line">       isPrime[<span class="number">0</span>], isPrime[<span class="number">1</span>] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(n**<span class="number">0</span>.<span class="number">5</span>)+<span class="number">1</span>):   <span class="comment"># 质数：除1和本身外，没有其他的因数。如果有其他因数p,则p*p = n,即p = n**0.5</span></span><br><span class="line">           <span class="keyword">if</span> isPrime[i] == <span class="number">1</span>:  <span class="comment"># 如果i是质数</span></span><br><span class="line">               isPrime[<span class="number">2</span>*<span class="symbol">i:</span><span class="symbol">n:</span>i] = [<span class="number">0</span>] * len(isPrime[i*<span class="number">2</span><span class="symbol">:n</span><span class="symbol">:i</span>])  <span class="comment"># 将i的倍数置为0</span></span><br><span class="line">             <span class="comment">#  print(i, isPrime)</span></span><br><span class="line">       <span class="keyword">return</span> sum(isPrime)</span><br></pre></td></tr></table></figure></li><li><p>Q9：给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。</p></li><li><p>A9：思路是如果最后一位不是9，而是0到8，就执行普通的最后一位的加1操作；如果最后一位是9，就要考虑向前面一位产生进位标志1，这是此题的关键！</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def plusOne(self, <span class="keyword">digits</span>: List[int]) -&gt; List[int]:</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(len(<span class="keyword">digits</span>)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):  # 反向遍历list(起点，终点,步长)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">digits</span>[i] <span class="keyword">is</span> <span class="number">9</span>:</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">digits</span>[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">digits</span>[i] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">digits</span></span><br><span class="line">        <span class="keyword">if</span> flag:   # 防止出现list=[<span class="number">9</span>]的情况</span><br><span class="line">            <span class="keyword">digits</span>.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">digits</span></span><br></pre></td></tr></table></figure></li><li><p>Q10:删除链表中等于给定值 val 的所有节点。示例:输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6  输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p></li><li><p>A10:</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition <span class="keyword">for</span> singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *<span class="keyword">next</span>;</span><br><span class="line"> *     ListNode(int x) : val(x), <span class="keyword">next</span>(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* removeElements(ListNode*<span class="built_in"> head</span>, int val) &#123;</span><br><span class="line">        // 空链表的情况</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">!head</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">        // 删除的节点是头节点</span><br><span class="line">        while<span class="built_in">(head</span>-&gt;val == val)&#123;</span><br><span class="line">           <span class="built_in"> head</span> =<span class="built_in"> head</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">!head</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* pNode =<span class="built_in"> head</span>;</span><br><span class="line">        ListNode* pCur =<span class="built_in"> head</span>-&gt;<span class="keyword">next</span>;</span><br><span class="line">        // 删除的是中间的某个节点</span><br><span class="line">        while(pCur)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pCur-&gt;val == val)&#123;</span><br><span class="line">                pNode-&gt;<span class="keyword">next</span> = pCur-&gt;<span class="keyword">next</span>;</span><br><span class="line">                pCur = pCur-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pNode = pCur;</span><br><span class="line">                pCur = pCur-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span><span class="built_in"> head</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Q11：编写一个算法来判断一个数是不是“快乐数”。一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-646c19c262b72ce5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示例"></p></li><li><p>A11:</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    bool isHappy(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1到9中只有1和7符合快乐数的定义！</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> || n==<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 其余不符合的情况，都不是快乐数!</span></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">sum</span> = isHappyCore(n);</span><br><span class="line">        <span class="keyword">return</span> isHappy(<span class="keyword">sum</span>);  <span class="comment">// 递归判断</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> isHappyCore(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="comment">// 下面的代码是取一个整数的各个位置上的数，具有一般性，记忆！</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">mod</span> = n % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">sum</span> += <span class="keyword">mod</span> * nod;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Q12:给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-c020d4ec291b6d1c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除链表中的重复元素"></p></li><li><p>A12：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* deleteDuplicates(ListNode* head) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(!head || head-&gt;</span>next == nullptr)&#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* pNode = head;  <span class="comment">// 慢指针</span></span><br><span class="line">        L<span class="function"><span class="title">istNode</span>* pCur = head-&gt;</span>next;  <span class="comment">// 快指针</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(pNode-&gt;</span>next != nullptr)&#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(pNode-&gt;</span><span class="function"><span class="title">val</span> == pCur-&gt;</span>val)&#123;  <span class="comment">// 找到重复元素</span></span><br><span class="line">                <span class="function"><span class="title">if</span>(pCur-&gt;</span>next == nullptr)&#123;  <span class="comment">// 快指针后面若没有元素直接剔除</span></span><br><span class="line">                    <span class="function"><span class="title">pNode</span>-&gt;</span>next = nullptr;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 快指针后有元素</span></span><br><span class="line">                    <span class="function"><span class="title">pNode</span>-&gt;</span><span class="function"><span class="title">next</span> = pCur-&gt;</span>next;</span><br><span class="line">                    <span class="function"><span class="title">pCur</span> = pCur-&gt;</span>next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">//元素不相等</span></span><br><span class="line">                <span class="function"><span class="title">pNode</span> = pNode-&gt;</span>next;</span><br><span class="line">                <span class="function"><span class="title">pCur</span> = pCur-&gt;</span>next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Q13：给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-693ffa68c46c1060?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实例"></p></li><li><p>A13：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * <span class="keyword">Definition</span> <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *<span class="built_in">left</span>;</span><br><span class="line"> *     TreeNode *<span class="built_in">right</span>;</span><br><span class="line"> *     TreeNode(int x) : val(x), <span class="built_in">left</span>(NULL), <span class="built_in">right</span>(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSameTree(TreeNode* p, TreeNode* q) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p==nullptr &amp;&amp; q==nullptr)&#123;</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p != nullptr &amp;&amp; q != nullptr &amp;&amp; p-&gt;val == q-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p-&gt;<span class="built_in">left</span>, q-&gt;<span class="built_in">left</span>) &amp;&amp; isSameTree(p-&gt;<span class="built_in">right</span>, q-&gt;<span class="built_in">right</span>);  // 在左右子树上递归实现！</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Q14：给定一个二叉树，检查它是否是镜像对称的。例如，二叉树 [1,2,2,3,4,4,3] 是对称的。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-4ef1c6c76672b65a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实例"></p></li><li><p>A14：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果是对称二叉树，则从左子树开始遍历与从右子树开始遍历时，遍历的结果都相同！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> isMirror(root,root);  <span class="comment">// 递归实现</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMirror</span><span class="params">(TreeNode* root1, TreeNode* root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> || root2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (root1-&gt;val == root2-&gt;val) &amp;&amp; isMirror(root1-&gt;left, root2-&gt;right) &amp;&amp; isMirror(root1-&gt;right, root2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>A15：给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-ae22671c2543635a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="求众数"></p></li><li><p>Q15：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># nums.sort()</span></span><br><span class="line">        <span class="comment"># nums_len = len(nums)</span></span><br><span class="line">        <span class="comment"># return nums[nums_len // 2]   # 返回中间的数</span></span><br><span class="line">        candidate = <span class="literal">None</span>   <span class="comment"># 摩尔投票法</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == candidate:  <span class="comment"># 如果数组中的下一个元素num与candidate相同，就不会碰撞，此时count加1</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> count &gt; <span class="number">0</span>:  <span class="comment"># 如果数组中的下一个元素num与candidate不同，就会发生碰撞，此时count减1，candidate维持上一次的数据</span></span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                candidate, count = num, <span class="number">1</span>  <span class="comment"># 第一次进入循环，candidate是第一个元素，count加1</span></span><br><span class="line">        <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure></li><li><p>A16：实现一个函数，将字符串中的每个空格替换成%20。例如，输入“hello world.”，则输出”hello%20world.”</p></li><li><p>Q16：解题思路：观察出空格替换后原始字符串变长的关系。在原始字符串的基础上进行修改，利用观察出的关系，使用两个指针从后向前移动将字符串从原始字符串复制到新的字符串中。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="meta">#include &lt;string&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解题思路：在原始字符串的基础上进行修改，注意原始字符串有足够的空间。使用两个指针，发现空格数量与原始字符串增加的长度关系！</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">void</span> ReplaceSPace(<span class="keyword">char</span>* <span class="keyword">str</span>, <span class="keyword">int</span> len)&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">str</span> == nullptr || len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> original_len = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> number_blank = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">// 遍历原始字符串，统计空格的数目</span></span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">str</span>[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">           ++original_len;</span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">str</span>[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">               ++number_blank;</span><br><span class="line">           &#125;</span><br><span class="line">           ++i;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> new_len = original_len + <span class="number">2</span> * number_blank;</span><br><span class="line">       <span class="keyword">if</span>(new_len &gt; len)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> original_index = original_len;</span><br><span class="line">       <span class="keyword">int</span> new_index = new_len;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(original_index &gt;= <span class="number">0</span> &amp;&amp; new_index &gt; original_index)&#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">str</span>[original_index] == <span class="string">' '</span>)&#123;</span><br><span class="line">               <span class="keyword">str</span>[new_index--] = <span class="string">'0'</span>;</span><br><span class="line">               <span class="keyword">str</span>[new_index--] = <span class="string">'2'</span>;</span><br><span class="line">               <span class="keyword">str</span>[new_index--] = <span class="string">'%'</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">str</span>[new_index--] = <span class="keyword">str</span>[original_index];</span><br><span class="line">           &#125;</span><br><span class="line">           original_index--;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Q17：单向链表的基础操作：<strong>在单向链表的末尾插入一个节点和找到第一个值为value的节点并将其删除</strong></p></li><li><p>A17：<strong>注意不要忘记释放在堆空间上申请的动态内存</strong></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">    int m_pVal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表的末尾插入一个节点</span></span><br><span class="line">void AddNodeToTail(ListNode** pHead, int value)&#123;</span><br><span class="line">    <span class="comment">// 为新插入的节点分配空间</span></span><br><span class="line">    ListNode* pNew = new ListNode();</span><br><span class="line">    <span class="function"><span class="title">pNew</span>-&gt;</span>m_pNext = nullptr;</span><br><span class="line">    <span class="function"><span class="title">pNew</span>-&gt;</span>m_pVal = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pHead == nullptr)&#123;  <span class="comment">// 空链表</span></span><br><span class="line">        *pHead = pNew;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ListNode* pNode = *pHead;</span><br><span class="line">        <span class="function"><span class="title">while</span>(pNode-&gt;</span>m_pNext != nullptr)&#123;</span><br><span class="line">            <span class="function"><span class="title">pNode</span> = pNode-&gt;</span>m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">pNode</span>-&gt;</span>m_pNext = pNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个含某值value的节点并删除此节点</span></span><br><span class="line">void RemoveNode(ListNode** pHead, int value)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == nullptr || *pHead == nullptr)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* pToDeleted = nullptr;</span><br><span class="line">    <span class="function"><span class="title">if</span>((*pHead)-&gt;</span>m_pVal == value)&#123;  <span class="comment">// 头节点就是要删除的那个节点</span></span><br><span class="line">        pToDeleted = *pHead;</span><br><span class="line">        *<span class="function"><span class="title">pHead</span> = (*pHead)-&gt;</span>m_pNext;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                               <span class="comment">// 头节点不是要删除的那个节点</span></span><br><span class="line">        ListNode* pNode = *pHead;</span><br><span class="line">        <span class="function"><span class="title">while</span>(pNode-&gt;</span><span class="function"><span class="title">m_pNext</span> != nullptr &amp;&amp; pNode-&gt;</span><span class="function"><span class="title">m_pNext</span>-&gt;</span>m_pVal != value)&#123;   <span class="comment">// 头节点不是要删除的那个节点，后面的节点也没有出现value，则一直向后查找</span></span><br><span class="line">            <span class="function"><span class="title">pNode</span> = pNode-&gt;</span>m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span>(pNode-&gt;</span><span class="function"><span class="title">m_pNext</span> != nullptr &amp;&amp; pNode-&gt;</span><span class="function"><span class="title">m_pNext</span>-&gt;</span>m_pVal == value)&#123;   <span class="comment">//  头节点不是要删除的那个节点,后面的节点找到了value，则执行删除操作</span></span><br><span class="line">            <span class="function"><span class="title">pToDeleted</span> = pNode-&gt;</span>m_pNext;</span><br><span class="line">            <span class="function"><span class="title">pNode</span>-&gt;</span><span class="function"><span class="title">m_pNext</span> = pNode-&gt;</span><span class="function"><span class="title">m_pNext</span>-&gt;</span>m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pToDeleted != nullptr)&#123;</span><br><span class="line">        delete pToDeleted;</span><br><span class="line">        pToDeleted = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Q18：从尾到头反向打印出单向链表</p></li><li>A18：因为单向链表方向不能反过来，如果将指针反过来来实现改变单向链表的方向。但是，这会改变单向链表的数据结构，<strong>故在不改变数据结构的基础上，使用栈来实现</strong>！<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">    <span class="keyword">int</span> m_pVal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用栈这个数据结构，后进先出！因为单向链表方向不能反过来，如果将指针反过来，从而实现改变链表的方向，但是这会改变链表的数据结构，故在不改变数据结构的基础上，使用栈来实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* pHead)&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nodes;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        ListNode* pNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            nodes.push(pNode-&gt;m_pVal);</span><br><span class="line">            pNode = pNode-&gt;m_pNext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            result.push_back(nodes.top());</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;strong&gt;递归方法和循环方法的对比&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;递归方法代码实现比较简洁，但是性能不如循环方法，还有可能出现栈溢出的问题。一般情况下优先考虑递归方法来实现！&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;搜索路径的题目&lt;/strong&gt;：一般使
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://cdlwhm1217096231.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://cdlwhm1217096231.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>神经网络中的注意力机制总结及PyTorch实战</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93%E5%8F%8APyTorch%E5%AE%9E%E6%88%98/"/>
    <id>https://cdlwhm1217096231.github.io/深度学习/神经网络中的注意力机制总结及PyTorch实战/</id>
    <published>2019-07-29T11:29:05.000Z</published>
    <updated>2019-07-29T12:56:37.646Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h4><ul><li>当神经网络来处理大量的输入信息时，也可以借助人脑的注意力机制，只选择一些关键的信息输入进行处理，用来提高神经网络的效率。在目前的神经网络模型中，可以将max pooling和gating机制近似地看作是自下而上的基于显著性的注意力机制。此外，自上而下的聚焦式注意力也是一种有效的信息选择方法。例如：给定一篇很长的文章，然后就此文章的内容进行提问，提出的问题只和文章中某个段落中的一两个句子相关，其余都无关的。为了减小神经网络的计算代价，只需要把相关的片段挑选出来让后续的神经网络来处理，而不需要把所有文章内容都输入到神经网络中。</li></ul><h4 id="1-Attention机制基础知识"><a href="#1-Attention机制基础知识" class="headerlink" title="1.Attention机制基础知识"></a>1.Attention机制基础知识</h4><ul><li>用$X=\left[\mathbf{x}<em>{1}, \cdots, \mathbf{x}</em>{N}\right]$表示N组输入信息，其中每个向量$\mathbf{x}_{i}, i \in[1, N]$都表示一组输入信息。为了节省计算资源，不需要将所有的信息都输入到神经网络中，只需要从X中选择一些和任务相关的信息。注意力机制的计算可以分为两步：<ul><li>(1)在所有输入信息上计算注意力分布；</li><li>(2)根据注意力分布来计算输入信息的加权平均</li></ul></li><li>1.1 <strong>注意力分布</strong><ul><li>为了从N个输入向量$\left[\mathbf{x}<em>{1}, \cdots, \mathbf{x}</em>{N}\right]$中选择出与某个特定任务相关的信息，需要引入一个和任务相关的表示，称为<strong>查询向量q</strong>，并通过一个打分函数来计算每个输入向量和查询向量之间的相关性。</li><li>给定一个和任务相关的查询向量q，用注意力变量$z \in[1, N]$来表示被选择信息的索引位置，即z=i表示选择了第i个输入向量。为了方便计算，下面首先介绍<strong>Soft Attention注意力机制</strong>。首先计算在给定q和X下，选择第i个输入向量的概率$\alpha_{i}$<script type="math/tex; mode=display">\begin{aligned} \alpha_{i} &=p(z=i | X, \mathbf{q}) \\ &=\operatorname{softmax}\left(s\left(\mathbf{x}_{i}, \mathbf{q}\right)\right) \\ &=\frac{\exp \left(s\left(\mathbf{x}_{i}, \mathbf{q}\right)\right)}{\sum_{j=1}^{N} \exp \left(s\left(\mathbf{x}_{j}, \mathbf{q}\right)\right)} \end{aligned}</script>其中$\alpha<em>{i}$称为注意力分布，$S\left(\mathbf{x}</em>{i}, \mathbf{q}\right)$是注意力打分函数，可以使用下面的几种方法来计算：<ul><li>加性模型       $s\left(\mathbf{x}<em>{i}, \mathbf{q}\right)=\mathbf{v}^{\mathrm{T}} \tanh \left(W \mathbf{x}</em>{i}+U \mathbf{q}\right)$</li><li>点积模型  $s\left(\mathbf{x}<em>{i}, \mathbf{q}\right)=\mathbf{x}</em>{i}^{\mathrm{T}} \mathbf{q}$</li><li>缩放点积模型 $s\left(\mathbf{x}<em>{i}, \mathbf{q}\right)=\frac{\mathbf{x}</em>{i}^{\mathrm{T}} \mathbf{q}}{\sqrt{d}}$</li><li>双线性模型  $s\left(\mathbf{x}<em>{i}, \mathbf{q}\right)=\mathbf{x}</em>{i}^{\mathrm{T}} W \mathbf{q}$</li></ul></li><li>上式中W、U、v是可学习的参数，d是输入向量的维度。理论上，加性模型和点积模型的复杂度差不多，但是点积模型在实现上可以更好地利用矩阵乘积，从而计算效率更高。但当输入向量的维度d比较高，点积模型的值通常有较大的方差，从而导致softmax函数的梯度比较小。因此，缩放点积模型可以很好地解决这个问题。双线性模型可以看做是一种泛化的点积模型。假设 $s\left(\mathbf{x}<em>{i}, \mathbf{q}\right)=\mathbf{x}</em>{i}^{\mathrm{T}} W \mathbf{q}$中$W=U^{\mathrm{T}} V$，则双线性模型可以写为$s\left(\mathbf{x}<em>{i}, \mathbf{q}\right)=\mathbf{x}</em>{i}^{\mathrm{T}} U^{\mathrm{T}} V \mathbf{q}=(U \mathbf{x})^{\mathrm{T}}(V \mathbf{q})$即分别对x和q进行线性变换后计算点积。相比点积模型，双线性模型在计算相似度时引入了非对称性。</li></ul></li><li><strong>1.2 加权平均</strong><ul><li>注意力分布$\alpha_{i}$可以解释为在给定任务相关的查询q时，第i个输入向量受注意的程度。下面采用一种<strong>软性</strong>的信息选择机制对输入信息进行汇总。<script type="math/tex; mode=display">\begin{aligned} \operatorname{att}(X, \mathbf{q}) &=\sum_{i=1}^{N} \alpha_{i} \mathbf{x}_{i} \\ &=\mathbb{E}_{z \sim p(z | X, \mathbf{q})}\left[\mathbf{x}_{z}\right] \end{aligned}</script>上式称为<strong>软注意力机制(Soft Attention Mechanism)</strong>。下图给出了软注意力机制的示例图：<br>  <img src="https://upload-images.jianshu.io/upload_images/13407176-8f9c246814375066?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="软注意力机制"></li></ul></li></ul><h4 id="2-其他类型的注意力机制"><a href="#2-其他类型的注意力机制" class="headerlink" title="2.其他类型的注意力机制"></a>2.其他类型的注意力机制</h4><ul><li><strong>2.1 硬注意力机制</strong><ul><li>上面的公式$\mathbb{E}<em>{z \sim p(z | X, \mathbf{q})}\left[\mathbf{x}</em>{z}\right]$提到的是软注意力机制，其选择的信息是所有输入向量在注意力分布下的期望。此外还有一种注意力是只关注到某一个输入向量，叫做<strong>硬注意力机制(Hard Attention Mechanism)</strong>。硬注意力机制有两种方法可以实现：<ul><li>(1)选择最高概率的一个输入向量，即<script type="math/tex; mode=display">\operatorname{att}(X, \mathbf{q})=\mathbf{x}_{j}</script>其中j为概率最大的输入向量的下标，即<script type="math/tex">\begin{array}{c}{j=\arg \max _{i=1}^{N} a_{i}}\end{array}</script></li><li>(2)通过在注意力分布上随机采样的方式实现</li></ul></li><li>硬注意力的一个缺点是基于最大采样或随机采样的方式来选择信息。因此最终的损失函数与注意力分布之间的函数关系不可导，因此无法使用反向传播算法进行训练。为了使用反向传播算法进行训练，一般使用软注意力机制。</li></ul></li><li><strong>2.2 键值对注意力</strong><ul><li>可以使用键值对格式来表示输入信息，其中键用来计算注意力分布$\alpha<em>{i}$，值用来计算聚合信息。用$(K, V)=\left[\left(\mathbf{k}</em>{1}, \mathbf{v}<em>{1}\right), \cdots,\left(\mathbf{k}</em>{N}, \mathbf{v}_{N}\right)\right]$来表示N组输入信息，给定任务相关的查询向量q时，注意力函数为：<script type="math/tex; mode=display">\begin{aligned} \operatorname{att}((K, V), \mathbf{q}) &=\sum_{i=1}^{N} \alpha_{i} \mathbf{v}_{i} \\ &=\sum_{i=1}^{N} \frac{\exp \left(s\left(\mathbf{k}_{i}, \mathbf{q}\right)\right)}{\sum_{j} \exp \left(s\left(\mathbf{k}_{j}, \mathbf{q}\right)\right)} \mathbf{v}_{i} \end{aligned}</script>其中$s\left(\mathbf{k}_{i}, \mathbf{q}\right)$是打分函数，1.2节的图中给出了键值对注意力机制的示意图。当K=V时，键值对模式等于普通模式的注意力机制。</li></ul></li><li><strong>2.3 多头注意力</strong><ul><li>多头注意力(Multi-head Attention)是利用多个查询 $Q=\left[\mathbf{q}<em>{1}, \cdots, \mathbf{q}</em>{M}\right]$来平行计算从输入信息中选取多组信息。每个注意 力关注输入信息的不同部分。<script type="math/tex; mode=display">\operatorname{att}((K, V), Q)=\operatorname{att}\left((K, V), \mathbf{q}_{1}\right) \oplus \cdots \oplus \operatorname{att}\left((K, V), \mathbf{q}_{M}\right)</script>其中⊕表示向量拼接。</li></ul></li><li><strong>2.4 自注意力模型(Self Attention)</strong><ul><li>当使用神经网络来处理一个变化长度的向量序列时，通过可以使用卷积网络或循环网络进行编码来得到一个相同长度的输出向量序列，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-0bf4dfb1fbcf218a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基于卷积神经网络和循环神经网络的变长序列编码"></li><li>基于卷积或循环网络的序列编码都是可以看做是一种局部的编码方式，只建模了输入信息的局部依赖关系。虽然循环网络理论上可以建立长距离依赖关系，但是由于信息传递的容量以及梯度消失问题，实际上也只能建立短距离依赖关系。</li><li>如果要建立输入序列之间的长距离依赖关系，可以使用以下两种方法：一种方法是增加网络的层数，通过一个深层网络来获取远距离的信息交互；另一种方法是使用全连接网络。全连接网络是一种非常直接的建模远距离依赖的模型，但是无法处理变长的输入序列。不同的输入长度，其连接权重的大小也是不同的。这时，就可以利用注意力机制来“动态”地生成不同连接的权重，这就是<strong>自注意力模型（Self-Attention Model）</strong>。</li><li>假设输入序列为$X=\left[\mathbf{x}<em>{1}, \cdots, \mathbf{x}</em>{N}\right] \in \mathbb{R}^{d<em>{1} \times N}$，输出序列为$H=\left[\mathbf{h}</em>{1}, \cdots, \mathbf{h}<em>{N}\right] \in \mathbb{R}^{d</em>{2} \times N}$，则可以通过线性变换得到三组向量序列：<script type="math/tex; mode=display">\begin{aligned} Q &=W_{Q} X \in \mathbb{R}^{d_{3} \times N} \\ K &=W_{K} X \in \mathbb{R}^{d_{3} \times N} \\ V &=W_{V} X \in \mathbb{R}^{d_{2} \times N} \end{aligned}</script>其中，Q、K、V分别为查询向量序列，键向量序列、值向量序列，$W<em>{Q} \in \mathbb{R}^{d</em>{3} \times d<em>{1}}$、$W</em>{K} \in \mathbb{R}^{d<em>{3} \times d</em>{1}}$、$W<em>{V} \in \mathbb{R}^{d</em>{2} \times d<em>{1}}$分别表示可学习的参数矩阵。根据$\operatorname{att}((K, V), \mathbf{q})=\sum</em>{i=1}^{N} \alpha<em>{i} \mathbf{v}</em>{i}$，可以得到输出向量$\mathbf{h}<em>{i}$：<br>$\mathbf{h}</em>{i}=\operatorname{att}\left((K, V), \mathbf{q}<em>{i}\right)=\sum</em>{j=1}^{N} \alpha<em>{i j} \mathbf{v}</em>{j}=\sum<em>{j=1}^{N} \operatorname{softmax}\left(s\left(\mathbf{k}</em>{j}, \mathbf{q}<em>{i}\right)\right) \mathbf{v}</em>{j}$<br>其中，$i, j \in[1, N]$为输出和输入向量序列的位置，连接权重$\alpha_{i j}$由注意力机制动态生成。<br>如果使用缩放点积来作为注意力打分函数，输出向量序列可以写为：<script type="math/tex; mode=display">H=V \operatorname{softmax}\left(\frac{K^{\mathrm{T}} Q}{\sqrt{d_{3}}}\right)</script>其中softmax函数为按列进行归一化的函数。</li><li>下图给出了全连接模型和自注意力模型的对比，其中实线表示可学习的权重，虚线表示动态生成的权重。由于自注意力模型的权重是动态生成的，因此可以处理变长的信息序列。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-510d0c5391bc8ed5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="全连接模型与自注意力模型"></li><li>自注意力模型可以作为神经网络中的一层来使用，既可以用来替换卷积层和循环层，也可以和它们一起交替使用(例如输入向量X可以是卷积层或循环层的输出)。自注意模型计算的权重$\alpha<em>{i j}$只依赖于$\mathbf{q}</em>{i}$和$\mathbf{k}_{j}$的相关性，从而忽略了输入信息的位置信息。因此，在单独使用时，自注意模型一般需要加入位置编码信息来进行修正。</li></ul></li></ul><h4 id="3-实战———以Seq2Seq网络进行法语到英语的翻译为例进行说明"><a href="#3-实战———以Seq2Seq网络进行法语到英语的翻译为例进行说明" class="headerlink" title="3.实战———以Seq2Seq网络进行法语到英语的翻译为例进行说明"></a>3.实战———以Seq2Seq网络进行法语到英语的翻译为例进行说明</h4><ul><li>利用机器翻译中的经典网络结构Seq2Seq(具体结构见参考资料中的文献)，其中包含Encoder编码网络将输入的法语句子进行编码，然后输入到Decoder解码网络进行解码，输出期望得到的英文句子。整个网络的结构如下：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-91259671c5a6e418?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Seq2Seq网络结构"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-2df3b1f7ccdc066e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Encoder部分"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-faefaa607c75a828?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Decoder部分"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-310f3d39f7a9fc4d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意力权重可视化"></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/13407176-be8ea154c2fc28a9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加坐标轴的注意力权重可视化1"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-4f8c1d8d22ea5719?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加坐标轴的注意力权重可视化2"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-31b166d4bcdeea3f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加坐标轴的注意力权重可视化3"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-aac78b93c36adfa7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="增加坐标轴的注意力权重可视化4"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals, print_function, division</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> open</span><br><span class="line"><span class="keyword">import</span> unicodedata</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">"cuda"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将法语翻译成英语</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SOS_token = <span class="number">0</span>  <span class="comment"># 开始的标注</span></span><br><span class="line">EOS_token = <span class="number">1</span>  <span class="comment"># 结束的标注</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 辅助类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lang</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.word2index = &#123;&#125;   <span class="comment"># word----&gt;index</span></span><br><span class="line">        self.index2word = &#123;<span class="number">0</span>: <span class="string">"SOS"</span>, <span class="number">1</span>: <span class="string">"EOS"</span>&#125;  <span class="comment"># index----&gt;word</span></span><br><span class="line">        self.word2count = &#123;&#125;   <span class="comment"># 稍后用来替换稀有单词，统计每个单词出现的次数</span></span><br><span class="line">        self.n_words = <span class="number">2</span>  <span class="comment"># 统计单词总数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addSentence</span><span class="params">(self, sentence)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> sentence.split(<span class="string">" "</span>):</span><br><span class="line">            self.addWord(word)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addWord</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> self.word2index:</span><br><span class="line">            self.word2index[word] = self.n_words</span><br><span class="line">            self.word2count[word] = <span class="number">1</span></span><br><span class="line">            self.index2word[self.n_words] = word</span><br><span class="line">            self.n_words += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.word2count[word] += <span class="number">1</span></span><br><span class="line"> <span class="comment"># Turn a Unicode string to plain ASCII</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unicodeToAscii</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(</span><br><span class="line">        c <span class="keyword">for</span> c <span class="keyword">in</span> unicodedata.normalize(<span class="string">'NFD'</span>, s)</span><br><span class="line">        <span class="keyword">if</span> unicodedata.category(c) != <span class="string">'Mn'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小写，修剪和删除非字母字符</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalizeString</span><span class="params">(s)</span>:</span></span><br><span class="line">    s = unicodeToAscii(s.lower().strip())</span><br><span class="line">    s = re.sub(<span class="string">r"([.!?])"</span>, <span class="string">r" \1"</span>, s)</span><br><span class="line">    s = re.sub(<span class="string">r"[^a-zA-Z.!?]+"</span>, <span class="string">r" "</span>, s)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="comment"># 加载文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readLangs</span><span class="params">(lang1, lang2, reverse=False)</span>:</span></span><br><span class="line">    print(<span class="string">"Reading lines......."</span>)</span><br><span class="line">    <span class="comment"># 读取文件并进行划分成行</span></span><br><span class="line">    lines = open(<span class="string">r"E://DeepLearning//jupyter_code//dataset//corpus//translation_data//%s-%s.txt"</span> % (lang1, lang2), encoding=<span class="string">'utf-8'</span>).\</span><br><span class="line">                read().strip().split(<span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将每行切成一组pairs</span></span><br><span class="line">    pairs = [[normalizeString(s) <span class="keyword">for</span> s <span class="keyword">in</span> l.split(<span class="string">"\t"</span>)] <span class="keyword">for</span> l <span class="keyword">in</span> lines]</span><br><span class="line">    <span class="comment"># 将其他语言翻译成英语</span></span><br><span class="line">    <span class="keyword">if</span> reverse:</span><br><span class="line">        pairs = [list(reversed(p)) <span class="keyword">for</span> p <span class="keyword">in</span> pairs]</span><br><span class="line">        input_lang = Lang(lang2)</span><br><span class="line">        output_lang = Lang(lang1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        input_lang = Lang(lang1)</span><br><span class="line">        output_lang = Lang(lang2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> input_lang, output_lang, pairs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于有很多例句，为了能快速训练，我们会将数据集修剪成相对简短的句子。这里最大长度是10个单词（包括结束标点符号）</span></span><br><span class="line"></span><br><span class="line">MAX_LENGTH = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 英语前缀</span></span><br><span class="line">eng_prefixes = (</span><br><span class="line">    <span class="string">"i am "</span>, <span class="string">"i m "</span>,</span><br><span class="line">    <span class="string">"he is"</span>, <span class="string">"he s "</span>,</span><br><span class="line">    <span class="string">"she is"</span>, <span class="string">"she s "</span>,</span><br><span class="line">    <span class="string">"you are"</span>, <span class="string">"you re "</span>,</span><br><span class="line">    <span class="string">"we are"</span>, <span class="string">"we re "</span>,</span><br><span class="line">    <span class="string">"they are"</span>, <span class="string">"they re "</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filterPair</span><span class="params">(p)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(p[<span class="number">0</span>].split(<span class="string">' '</span>)) &lt; MAX_LENGTH <span class="keyword">and</span> \</span><br><span class="line">        len(p[<span class="number">1</span>].split(<span class="string">' '</span>)) &lt; MAX_LENGTH <span class="keyword">and</span> \</span><br><span class="line">        p[<span class="number">1</span>].startswith(eng_prefixes)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filterPairs</span><span class="params">(pairs)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [pair <span class="keyword">for</span> pair <span class="keyword">in</span> pairs <span class="keyword">if</span> filterPair(pair)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prepareData</span><span class="params">(lang1, lang2, reverse=False)</span>:</span></span><br><span class="line">    input_lang, output_lang, pairs = readLangs(lang1, lang2, reverse)</span><br><span class="line">    print(<span class="string">"Read %s sentence pairs"</span> % len(pairs))</span><br><span class="line">    pairs = filterPairs(pairs)</span><br><span class="line">    print(<span class="string">"Trimmed to %s sentence pairs"</span> % len(pairs))</span><br><span class="line">    print(<span class="string">"Counting words..."</span>)</span><br><span class="line">    <span class="keyword">for</span> pair <span class="keyword">in</span> pairs:</span><br><span class="line">        input_lang.addSentence(pair[<span class="number">0</span>])</span><br><span class="line">        output_lang.addSentence(pair[<span class="number">1</span>])</span><br><span class="line">    print(<span class="string">"Counted words:"</span>)</span><br><span class="line">    print(input_lang.name, input_lang.n_words)</span><br><span class="line">    print(output_lang.name, output_lang.n_words)</span><br><span class="line">    <span class="keyword">return</span> input_lang, output_lang, pairs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">input_lang, output_lang, pairs = prepareData(<span class="string">'eng'</span>, <span class="string">'fra'</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># print("pairs:\n", pairs)  pairs = [法语,英语]</span></span><br><span class="line">print(random.choice(pairs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Encoder 部分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncoderRNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_size, hidden_size)</span>:</span></span><br><span class="line">        super(EncoderRNN, self).__init__()</span><br><span class="line">        self.hidden_size = hidden_size   <span class="comment"># 隐藏状态a的大小</span></span><br><span class="line"></span><br><span class="line">        self.embedding = nn.Embedding(input_size, hidden_size)  <span class="comment"># 词嵌入层</span></span><br><span class="line">        self.gru = nn.GRU(hidden_size, hidden_size)   <span class="comment"># 多层的GRU</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input, hidden)</span>:</span></span><br><span class="line">        embedded = self.embedding(input).view(<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">        output = embedded</span><br><span class="line">        output, hidden = self.gru(output, hidden)</span><br><span class="line">        <span class="keyword">return</span> output, hidden</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initHidden</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> torch.zeros(<span class="number">1</span>,<span class="number">1</span>, self.hidden_size, device=device)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Decoder部分</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoderRNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hidden_size, output_size)</span>:</span></span><br><span class="line">        super(DecoderRNN, self).__init__()</span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line"></span><br><span class="line">        self.embedding = nn.Embedding(output_size, hidden_size)</span><br><span class="line">        self.gru = nn.GRU(hidden_size, hidden_size)</span><br><span class="line">        self.out = nn.Linear(hidden_size, output_size)</span><br><span class="line">        self.softmax = nn.LogSoftmax(dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input, hidden)</span>:</span></span><br><span class="line">        output = self.embedding(input).view(<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">        output = F.relu(output)</span><br><span class="line">        output, hidden = self.gru(output, hidden)</span><br><span class="line">        output = self.softmax(self.out(output[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">return</span> output, hidden</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initHidden</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> torch.zeros(<span class="number">1</span>,<span class="number">1</span>,self.hidden_size, device=device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Attention 部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AttnDecoderRNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hidden_size, output_size, dropout_p=<span class="number">0.1</span>, max_length=MAX_LENGTH)</span>:</span></span><br><span class="line">        super(AttnDecoderRNN, self).__init__()</span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.output_size = output_size</span><br><span class="line">        self.dropout_p = dropout_p</span><br><span class="line">        self.max_length = max_length</span><br><span class="line"></span><br><span class="line">        self.embedding = nn.Embedding(self.output_size, self.hidden_size)</span><br><span class="line">        self.attn = nn.Linear(self.hidden_size*<span class="number">2</span>, self.max_length)</span><br><span class="line">        self.attn_combine = nn.Linear(self.hidden_size*<span class="number">2</span>, self.hidden_size)</span><br><span class="line">        self.dropout = nn.Dropout(self.dropout_p)</span><br><span class="line">        self.gru = nn.GRU(self.hidden_size, self.hidden_size)</span><br><span class="line">        self.out = nn.Linear(self.hidden_size, self.output_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, input, hidden, encoder_outputs)</span>:</span></span><br><span class="line">        embedded = self.embedding(input).view(<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">        embedded = self.dropout(embedded)</span><br><span class="line"></span><br><span class="line">        attn_weights = F.softmax(self.attn(torch.cat((embedded[<span class="number">0</span>], hidden[<span class="number">0</span>]), <span class="number">1</span>)), dim=<span class="number">1</span>)  <span class="comment"># 注意力权重</span></span><br><span class="line">        attn_applied = torch.bmm(attn_weights.unsqueeze(<span class="number">0</span>), encoder_outputs.unsqueeze(<span class="number">0</span>))  <span class="comment"># 两个batch之间的矩阵乘法</span></span><br><span class="line"></span><br><span class="line">        output = torch.cat((embedded[<span class="number">0</span>], attn_applied[<span class="number">0</span>]), <span class="number">1</span>)</span><br><span class="line">        output = self.attn_combine(output).unsqueeze(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        output = F.relu(output)</span><br><span class="line">        output, hidden = self.gru(output, hidden)</span><br><span class="line"></span><br><span class="line">        output = F.log_softmax(self.out(output[<span class="number">0</span>]), dim=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output, hidden, attn_weights</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 隐状态初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initHidden</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> torch.zeros(<span class="number">1</span>, <span class="number">1</span>, self.hidden_size, device=device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备训练数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">indexesFromSentence</span><span class="params">(lang, sentence)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [lang.word2index[word] <span class="keyword">for</span> word <span class="keyword">in</span> sentence.split(<span class="string">" "</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tensorFromSentence</span><span class="params">(lang, sentence)</span>:</span></span><br><span class="line">    indexes = indexesFromSentence(lang, sentence)</span><br><span class="line">    indexes.append(EOS_token)   <span class="comment"># EOS作为encoder编码器网络的结束标志，  SOS作为Decoder解码器网络的开始标志</span></span><br><span class="line">    <span class="keyword">return</span> torch.tensor(indexes, dtype=torch.long, device=device).view(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tensorsFromPair</span><span class="params">(pair)</span>:</span></span><br><span class="line">    input_tensor = tensorFromSentence(input_lang, pair[<span class="number">0</span>])   <span class="comment"># pair[0]是法语</span></span><br><span class="line">    targe_tensor = tensorFromSentence(output_lang, pair[<span class="number">1</span>])  <span class="comment"># pair[1]是英语</span></span><br><span class="line">    <span class="keyword">return</span> (input_tensor, targe_tensor)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># “tearcher_forcing_ratio将上一时刻的真实目标输出当作下一个时刻的Encoder网络的输入，而不是使用Encoder网络的上一时刻的预测输出作为下一时刻的输入。</span></span><br><span class="line">tearcher_forcing_ratio = <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(input_tensor, target_tensor, encoder, decoder, encoder_optimizer, decoder_optimizer, criterion, max_length=MAX_LENGTH)</span>:</span></span><br><span class="line">    encoder_hidden = encoder.initHidden()</span><br><span class="line"></span><br><span class="line">    encoder_optimizer.zero_grad()</span><br><span class="line">    decoder_optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    input_length = input_tensor.size(<span class="number">0</span>)</span><br><span class="line">    target_length = target_tensor.size(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    encoder_outputs = torch.zeros(max_length, encoder.hidden_size, device=device)</span><br><span class="line"></span><br><span class="line">    loss = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># encoder部分</span></span><br><span class="line">    <span class="keyword">for</span> ei <span class="keyword">in</span> range(input_length):</span><br><span class="line">        encoder_output, encoder_hidden = encoder(input_tensor[ei], encoder_hidden)</span><br><span class="line">        encoder_outputs[ei] = encoder_output[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># decoder部分</span></span><br><span class="line">    decoder_input = torch.tensor([[SOS_token]], device=device)</span><br><span class="line"></span><br><span class="line">    decoder_hidden = encoder_hidden</span><br><span class="line"></span><br><span class="line">    use_teacher_foring = <span class="literal">True</span> <span class="keyword">if</span> random.random() &lt; tearcher_forcing_ratio <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># using teacher forcing</span></span><br><span class="line">    <span class="keyword">if</span> use_teacher_foring:</span><br><span class="line">        <span class="keyword">for</span> di <span class="keyword">in</span> range(target_length):</span><br><span class="line">            decoder_output, decoder_hidden, decoder_attention = decoder(decoder_input, decoder_hidden, encoder_outputs)</span><br><span class="line">            loss += criterion(decoder_output, target_tensor[di])</span><br><span class="line">            decoder_input = target_tensor[di]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 不使用teacher forcing,使用上一时刻的输出作为下一时刻的输入</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> di <span class="keyword">in</span> range(target_length):</span><br><span class="line">            decoder_output, decoder_hidden, decoder_attention = decoder(decoder_input, decoder_hidden, encoder_outputs)</span><br><span class="line">            topv, topi = decoder_output.topk(<span class="number">1</span>)</span><br><span class="line">            decoder_input = topi.squeeze().detach()</span><br><span class="line"></span><br><span class="line">            loss += criterion(decoder_output, target_tensor[di])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> decoder_input.item() == EOS_token:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    loss.backward()</span><br><span class="line"></span><br><span class="line">    encoder_optimizer.step()</span><br><span class="line">    decoder_optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> loss.item() / target_length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 辅助函数------记录时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asMinutes</span><span class="params">(s)</span>:</span></span><br><span class="line">    m = math.floor(s / <span class="number">60</span>)</span><br><span class="line">    s -= m * <span class="number">60</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"%dm %ds"</span> % (m, s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeSince</span><span class="params">(since, percent)</span>:</span></span><br><span class="line">    now = time.time()</span><br><span class="line">    s = now - since</span><br><span class="line">    es = s / (percent)</span><br><span class="line">    rs = es - s</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"%s (- %s)"</span> % (asMinutes(s), asMinutes(rs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个训练过程如下：</span></span><br><span class="line"> <span class="comment"># 开启定时器</span></span><br><span class="line"> <span class="comment"># 初始化优化器和loss函数</span></span><br><span class="line"> <span class="comment"># 创建training pairs</span></span><br><span class="line"> <span class="comment"># 开始训练并绘图</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainIters</span><span class="params">(encoder, decoder, n_iters, print_every=<span class="number">1000</span>, plot_every=<span class="number">100</span>, learning_rate=<span class="number">0.01</span>)</span>:</span></span><br><span class="line">    start = time.time()  <span class="comment"># 开启定时器</span></span><br><span class="line">    plot_losses = []</span><br><span class="line">    print_loss_total = <span class="number">0</span>  <span class="comment"># Reset every print_every</span></span><br><span class="line">    plot_loss_total = <span class="number">0</span>  <span class="comment"># Reset every plot_every</span></span><br><span class="line"></span><br><span class="line">    encoder_optimizer = optim.SGD(encoder.parameters(), lr=learning_rate)  <span class="comment"># 定义优化算法</span></span><br><span class="line">    decoder_optimizer = optim.SGD(decoder.parameters(), lr=learning_rate)</span><br><span class="line">    training_pairs = [tensorsFromPair(random.choice(pairs))  <span class="comment"># 创建training pairs</span></span><br><span class="line">                      <span class="keyword">for</span> i <span class="keyword">in</span> range(n_iters)]</span><br><span class="line">    criterion = nn.NLLLoss()  <span class="comment"># 定义损失函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> iter <span class="keyword">in</span> range(<span class="number">1</span>, n_iters + <span class="number">1</span>):</span><br><span class="line">        training_pair = training_pairs[iter - <span class="number">1</span>]</span><br><span class="line">        input_tensor = training_pair[<span class="number">0</span>]</span><br><span class="line">        target_tensor = training_pair[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        loss = train(input_tensor, target_tensor, encoder,</span><br><span class="line">                     decoder, encoder_optimizer, decoder_optimizer, criterion)</span><br><span class="line">        print_loss_total += loss</span><br><span class="line">        plot_loss_total += loss</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> iter % print_every == <span class="number">0</span>:</span><br><span class="line">            print_loss_avg = print_loss_total / print_every</span><br><span class="line">            print_loss_total = <span class="number">0</span></span><br><span class="line">            print(<span class="string">'%s (%d %d%%) %.4f'</span> % (timeSince(start, iter / n_iters),</span><br><span class="line">                                         iter, iter / n_iters * <span class="number">100</span>, print_loss_avg))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> iter % plot_every == <span class="number">0</span>:</span><br><span class="line">            plot_loss_avg = plot_loss_total / plot_every</span><br><span class="line">            plot_losses.append(plot_loss_avg)</span><br><span class="line">            plot_loss_total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    showPlot(plot_losses)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制loss曲线</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.switch_backend(<span class="string">'agg'</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.ticker <span class="keyword">as</span> ticker</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showPlot</span><span class="params">(points)</span>:</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    fig, ax = plt.subplots()</span><br><span class="line">    <span class="comment"># this locator puts ticks at regular intervals</span></span><br><span class="line">    loc = ticker.MultipleLocator(base=<span class="number">0.2</span>)</span><br><span class="line">    ax.yaxis.set_major_locator(loc)</span><br><span class="line">    plt.plot(points)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试阶段--------测试阶段整体与训练阶段类似，但是测试阶段，不用给出target_tensor,只是将decoder网络上一时刻的预测值作为下一时刻的输入值</span></span><br><span class="line"><span class="comment"># 当预测值是EOS时，则停止预测</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(encoder, decoder, sentence, max_length = MAX_LENGTH)</span>:</span></span><br><span class="line">     <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        input_tensor = tensorFromSentence(input_lang, sentence)</span><br><span class="line">        input_length = input_tensor.size()[<span class="number">0</span>]</span><br><span class="line">        encoder_hidden = encoder.initHidden()</span><br><span class="line"></span><br><span class="line">        encoder_outputs = torch.zeros(max_length, encoder.hidden_size, device=device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># encoder部分</span></span><br><span class="line">        <span class="keyword">for</span> ei <span class="keyword">in</span> range(input_length):</span><br><span class="line">            encoder_output, encoder_hidden = encoder(input_tensor[ei],</span><br><span class="line">                                                     encoder_hidden)</span><br><span class="line">            encoder_outputs[ei] += encoder_output[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        decoder_input = torch.tensor([[SOS_token]], device=device)  <span class="comment"># SOS</span></span><br><span class="line"></span><br><span class="line">        decoder_hidden = encoder_hidden</span><br><span class="line"></span><br><span class="line">        decoded_words = []</span><br><span class="line">        decoder_attentions = torch.zeros(max_length, max_length)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># decoder部分</span></span><br><span class="line">        <span class="keyword">for</span> di <span class="keyword">in</span> range(max_length):</span><br><span class="line">            decoder_output, decoder_hidden, decoder_attention = decoder(</span><br><span class="line">                decoder_input, decoder_hidden, encoder_outputs)</span><br><span class="line">            decoder_attentions[di] = decoder_attention.data</span><br><span class="line">            topv, topi = decoder_output.data.topk(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> topi.item() == EOS_token:  <span class="comment"># 结束时的条件</span></span><br><span class="line">                decoded_words.append(<span class="string">'&lt;EOS&gt;'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                decoded_words.append(output_lang.index2word[topi.item()])</span><br><span class="line"></span><br><span class="line">            decoder_input = topi.squeeze().detach()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> decoded_words, decoder_attentions[:di + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机地从训练集中选择pairs,然后在测试集上进行评估</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluateRandomly</span><span class="params">(encoder, decoder, n=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        pair = random.choice(pairs)</span><br><span class="line">        print(<span class="string">'输入:&gt;'</span>, pair[<span class="number">0</span>])</span><br><span class="line">        print(<span class="string">'目标:='</span>, pair[<span class="number">1</span>])</span><br><span class="line">        output_words, attentions = evaluate(encoder, decoder, pair[<span class="number">0</span>])</span><br><span class="line">        output_sentence = <span class="string">' '</span>.join(output_words)</span><br><span class="line">        print(<span class="string">'预测:&lt;'</span>, output_sentence)</span><br><span class="line">        print(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正式训练开始运行</span></span><br><span class="line"></span><br><span class="line">hidden_size = <span class="number">256</span></span><br><span class="line">encoder1 = EncoderRNN(input_lang.n_words, hidden_size).to(device)</span><br><span class="line">attn_decoder1 = AttnDecoderRNN(hidden_size, output_lang.n_words, dropout_p=<span class="number">0.1</span>).to(device)</span><br><span class="line"></span><br><span class="line">trainIters(encoder1, attn_decoder1, <span class="number">75000</span>, print_every=<span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line">evaluateRandomly(encoder1, attn_decoder1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意力可视化</span></span><br><span class="line"></span><br><span class="line">output_words, attentions = evaluate(</span><br><span class="line">    encoder1, attn_decoder1, <span class="string">"je suis trop froid ."</span>)</span><br><span class="line">plt.matshow(attentions.numpy());</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加坐标轴，更加清楚的可视化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">showAttention</span><span class="params">(input_sentence, output_words, attentions)</span>:</span></span><br><span class="line">    <span class="comment"># Set up figure with colorbar</span></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    cax = ax.matshow(attentions.numpy(), cmap=<span class="string">'bone'</span>)</span><br><span class="line">    fig.colorbar(cax)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set up axes</span></span><br><span class="line">    ax.set_xticklabels([<span class="string">''</span>] + input_sentence.split(<span class="string">' '</span>) +</span><br><span class="line">                       [<span class="string">'&lt;EOS&gt;'</span>], rotation=<span class="number">90</span>)</span><br><span class="line">    ax.set_yticklabels([<span class="string">''</span>] + output_words)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Show label at every tick</span></span><br><span class="line">    ax.xaxis.set_major_locator(ticker.MultipleLocator(<span class="number">1</span>))</span><br><span class="line">    ax.yaxis.set_major_locator(ticker.MultipleLocator(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluateAndShowAttention</span><span class="params">(input_sentence)</span>:</span></span><br><span class="line">    output_words, attentions = evaluate(</span><br><span class="line">        encoder1, attn_decoder1, input_sentence)</span><br><span class="line">    print(<span class="string">'input ='</span>, input_sentence)</span><br><span class="line">    print(<span class="string">'output ='</span>, <span class="string">' '</span>.join(output_words))</span><br><span class="line">    showAttention(input_sentence, output_words, attentions)</span><br></pre></td></tr></table></figure></p><h4 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4.参考资料"></a>4.参考资料</h4><ul><li><a href="https://nndl.github.io/" target="_blank" rel="noopener">邱锡鹏：《神经网络与深度学习》</a></li><li><a href="https://pytorch.org/tutorials/intermediate/seq2seq_translation_tutorial.html" target="_blank" rel="noopener">Translation with a Sequence to Sequence Network and Attention</a></li><li><a href="https://pytorch-cn.readthedocs.io/zh/latest/" target="_blank" rel="noopener">PyTorch中文文档</a></li><li><a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation</a></li><li><a href="https://arxiv.org/abs/1409.3215" target="_blank" rel="noopener">Sequence to Sequence Learning with Neural Networks</a></li><li><a href="https://arxiv.org/abs/1409.0473" target="_blank" rel="noopener">Neural Machine Translation by Jointly Learning to Align and Translate</a></li><li><a href="https://arxiv.org/abs/1506.05869" target="_blank" rel="noopener">A Neural Conversational Model</a></li><li><a href="https://github.com/cdlwhm1217096231/Machine_Learning/tree/master/%E4%B8%AD%E6%96%87NLP%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/05_Attention_Mechanism" target="_blank" rel="noopener">本文中的代码及数据下载地址</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0.概述&quot;&gt;&lt;/a&gt;0.概述&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;当神经网络来处理大量的输入信息时，也可以借助人脑的注意力机制，只选择一些关键的信息输入进行处理，用来提高神经网络
      
    
    </summary>
    
      <category term="深度学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="NLP" scheme="https://cdlwhm1217096231.github.io/tags/NLP/"/>
    
      <category term="PyTorch" scheme="https://cdlwhm1217096231.github.io/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>轻松优化Jupyter Notebook:技巧、诀窍、魔法</title>
    <link href="https://cdlwhm1217096231.github.io/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/%E8%BD%BB%E6%9D%BE%E4%BC%98%E5%8C%96Jupyter-Notebook-%E6%8A%80%E5%B7%A7%E3%80%81%E8%AF%80%E7%AA%8D%E3%80%81%E9%AD%94%E6%B3%95/"/>
    <id>https://cdlwhm1217096231.github.io/开发工具/轻松优化Jupyter-Notebook-技巧、诀窍、魔法/</id>
    <published>2019-07-29T11:26:25.000Z</published>
    <updated>2019-07-29T12:56:11.661Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-更换主题"><a href="#0-更换主题" class="headerlink" title="0.更换主题"></a>0.更换主题</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install </span><span class="keyword">jupyterthemes</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"># </span>使用暗黑主题</span><br><span class="line"><span class="keyword">jt </span>-t chesterish</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复默认主题</span></span><br><span class="line"><span class="keyword">jt </span>-r</span><br></pre></td></tr></table></figure><h4 id="1-常用技巧"><a href="#1-常用技巧" class="headerlink" title="1.常用技巧"></a>1.常用技巧</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ctrl + <span class="built_in">shift</span> + p  <span class="comment"># 查看所有的快捷键按钮</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在开头加上感叹号，则可以运行bash命令，例如： !pip install numpy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在某个函数的末尾加上分号来随时限制函数在最后一行代码上的输出</span></span><br><span class="line"></span><br><span class="line">ctr + /   <span class="comment"># 用来注释或者取消代码</span></span><br></pre></td></tr></table></figure><h4 id="2-MarkDown模式"><a href="#2-MarkDown模式" class="headerlink" title="2.MarkDown模式"></a>2.MarkDown模式</h4><p>在markdown模式下支持latex 例如：$p(A \mid B) = \frac{p(B \mid A)p(A)}{p(B)}$</p><h4 id="3-输出打印"><a href="#3-输出打印" class="headerlink" title="3.输出打印"></a>3.输出打印</h4><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印出所有输出</span></span><br><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印最后一行输出</span></span><br><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"last_expr"</span></span><br></pre></td></tr></table></figure><h4 id="4-安装扩展插件"><a href="#4-安装扩展插件" class="headerlink" title="4.安装扩展插件"></a>4.安装扩展插件</h4><ul><li><p>安装Nbextensions</p><ul><li><p>pip安装</p>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install </span><span class="keyword">jupyter_contrib_nbextensions</span></span><br><span class="line"><span class="keyword">jupyter </span>contrib nbextension <span class="keyword">install </span>--user</span><br></pre></td></tr></table></figure></li><li><p>Anaconda安装</p>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="keyword">install </span>-c conda-forge <span class="keyword">jupyter_contrib_nbextensions</span></span><br><span class="line"><span class="keyword">conda </span><span class="keyword">install </span>-c conda-forge <span class="keyword">jupyter_nbextensions_configurator</span></span><br><span class="line"><span class="keyword">jupyter </span>contrib nbextension <span class="keyword">install </span>--user</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="5-魔法函数"><a href="#5-魔法函数" class="headerlink" title="5.魔法函数"></a>5.魔法函数</h4><ul><li>line magic在一条线上使用,以%开头</li><li>cell magic    # 在整个cell上使用，以%%开头<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">lsmagic</span></span>   # 查看所有的魔法函数</span><br><span class="line"><span class="tag">%<span class="selector-tag">env</span></span>    # 查看环境变量</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-文件的导入与导出"><a href="#6-文件的导入与导出" class="headerlink" title="6.文件的导入与导出"></a>6.文件的导入与导出</h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在cell中插入外部的<span class="keyword">py</span>文件</span><br><span class="line">%load basic_import.<span class="keyword">py</span></span><br><span class="line"></span><br><span class="line"># 将cell中的代码导出到一个<span class="keyword">py</span>文件中</span><br><span class="line">%%<span class="built_in">writefile</span> thiscode.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><h4 id="7-运行与查看导入的文件"><a href="#7-运行与查看导入的文件" class="headerlink" title="7.运行与查看导入的文件"></a>7.运行与查看导入的文件</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行py文件中的内容</span></span><br><span class="line">%<span class="keyword">run</span><span class="bash"> basic_import.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不确定脚本文件中的内容，可以随时显示它</span></span><br><span class="line">%pycat basic_import.py</span><br></pre></td></tr></table></figure><h4 id="8-设置自动保存"><a href="#8-设置自动保存" class="headerlink" title="8.设置自动保存"></a>8.设置自动保存</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span>autosave <span class="number">60</span>  <span class="attr"># 每60</span>秒自动保存</span><br></pre></td></tr></table></figure><h4 id="9-显示图像"><a href="#9-显示图像" class="headerlink" title="9.显示图像"></a>9.显示图像</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">matplotlib</span></span> inline</span><br></pre></td></tr></table></figure><h4 id="10-定时器"><a href="#10-定时器" class="headerlink" title="10.定时器"></a>10.定时器</h4><ul><li>%timeit和%%time放在需要指定的语句前，例如：%%time print(“hello python!”)<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%<span class="keyword">time</span>       <span class="comment"># 计算给出cell中的代码运行一次所花费的时间</span></span><br><span class="line">%timeit      <span class="comment"># 多次运行指定的代码计算平均值，使用的是python中的timeit模块</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="11-运行其他语言的代码"><a href="#11-运行其他语言的代码" class="headerlink" title="11.运行其他语言的代码"></a>11.运行其他语言的代码</h4><ul><li>在不同放入kernel中运行代码，在kernel的开头加上下面对应语言的语句才可以使用！<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%%bash</span><br><span class="line">%%HTML</span><br><span class="line">%%<span class="keyword">python</span></span><br><span class="line">%%python2</span><br><span class="line">%%python3</span><br><span class="line">%%ruby</span><br><span class="line">%%perl</span><br><span class="line">%%capture</span><br><span class="line">%%javascript</span><br><span class="line">%%js</span><br><span class="line">%%latex</span><br><span class="line">%%markdown</span><br><span class="line">%%pypy</span><br></pre></td></tr></table></figure></li></ul><h4 id="12-查看变量"><a href="#12-查看变量" class="headerlink" title="12.查看变量"></a>12.查看变量</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找全局范围内的所有变量</span></span><br><span class="line">%who</span><br><span class="line">%who str  <span class="comment"># 只查看str类型的变量</span></span><br><span class="line"><span class="comment"># 查看执行某个函数花费的实际</span></span><br><span class="line">%prun 语句名</span><br><span class="line"><span class="comment"># 使用pdb进行调试</span></span><br><span class="line">必须在每个cell的开头，加上%pdb</span><br></pre></td></tr></table></figure><h4 id="13-提供高分辨率的图"><a href="#13-提供高分辨率的图" class="headerlink" title="13.提供高分辨率的图"></a>13.提供高分辨率的图</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="built_in">config</span> InlineBackend.figure_format = <span class="string">'retina'</span></span><br></pre></td></tr></table></figure><h4 id="14-选择执行某些cell"><a href="#14-选择执行某些cell" class="headerlink" title="14.选择执行某些cell"></a>14.选择执行某些cell</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%%<span class="keyword">script</span> <span class="literal">false</span>     <span class="comment"># 在cell的开头加上此句</span></span><br></pre></td></tr></table></figure><h4 id="15-当需要一直运行某段代码时，通过下面的方法提醒我们的代码何时跑完"><a href="#15-当需要一直运行某段代码时，通过下面的方法提醒我们的代码何时跑完" class="headerlink" title="15.当需要一直运行某段代码时，通过下面的方法提醒我们的代码何时跑完"></a>15.当需要一直运行某段代码时，通过下面的方法提醒我们的代码何时跑完</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预先安装sox：</span></span><br><span class="line">brew install sox  (mac上)</span><br><span class="line"><span class="comment"># Linux/Mac系统上：</span></span><br><span class="line">import os</span><br><span class="line">duration = 1 // second</span><br><span class="line">freq=440</span><br><span class="line">os.system('play --no-show-progress --null --channels 1 synth %s sine %f' % (duration,freq))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Windows系统上：</span></span><br><span class="line">import winsound</span><br><span class="line">duration = 1000</span><br><span class="line">freq = 440</span><br><span class="line">winsound.Beep(freq.duration)</span><br></pre></td></tr></table></figure><h4 id="16-参考博客"><a href="#16-参考博客" class="headerlink" title="16.参考博客"></a>16.参考博客</h4><ul><li><a href="https://towardsdatascience.com/how-to-effortlessly-optimize-jupyter-notebooks-e864162a06ee" target="_blank" rel="noopener">博客原文</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;0-更换主题&quot;&gt;&lt;a href=&quot;#0-更换主题&quot; class=&quot;headerlink&quot; title=&quot;0.更换主题&quot;&gt;&lt;/a&gt;0.更换主题&lt;/h4&gt;&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
      <category term="开发工具" scheme="https://cdlwhm1217096231.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Python3" scheme="https://cdlwhm1217096231.github.io/tags/Python3/"/>
    
      <category term="Ubuntu" scheme="https://cdlwhm1217096231.github.io/tags/Ubuntu/"/>
    
      <category term="Jupyter Notebook" scheme="https://cdlwhm1217096231.github.io/tags/Jupyter-Notebook/"/>
    
  </entry>
  
  <entry>
    <title>C++中虚函数可以是内联函数吗？</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中虚函数可以是内联函数吗？/</id>
    <published>2019-07-29T11:24:45.000Z</published>
    <updated>2019-07-29T11:25:35.091Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1.<strong>需要注意的几点</strong>：<ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul></li><li>2.代码实例如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="comment">// 基类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">virtual</span> ~Base()&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 派生类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span>&#123;   <span class="comment">// 不写inline时隐式内联</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。</span></span><br><span class="line">    Base b;</span><br><span class="line">    b.who();</span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。</span></span><br><span class="line">    Base *bptr = <span class="keyword">new</span> Derived();</span><br><span class="line">    bptr-&gt;who();</span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> bptr;</span><br><span class="line">    bptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;1.&lt;strong&gt;需要注意的几点&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。&lt;/li&gt;
&lt;li&gt;内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/tags/C/"/>
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的volatile关键字</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的volatile关键字/</id>
    <published>2019-07-29T11:22:42.000Z</published>
    <updated>2019-07-29T11:24:11.136Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-使用"><a href="#1-使用" class="headerlink" title="1.使用"></a>1.使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h4 id="2-使用volatile时要几个注意的点："><a href="#2-使用volatile时要几个注意的点：" class="headerlink" title="2.使用volatile时要几个注意的点："></a>2.使用volatile时要几个注意的点：</h4><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是 volatile</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-使用&quot;&gt;&lt;a href=&quot;#1-使用&quot; class=&quot;headerlink&quot; title=&quot;1.使用&quot;&gt;&lt;/a&gt;1.使用&lt;/h4&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/tags/C/"/>
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++面试知识点总结</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-面试知识点总结/</id>
    <published>2019-07-29T11:11:02.000Z</published>
    <updated>2019-07-31T09:28:39.467Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-static关键字的作用"><a href="#一-static关键字的作用" class="headerlink" title="一.static关键字的作用"></a>一.static关键字的作用</h4><ul><li>1.修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li><li>2.修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li><li>3.修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li><li>4.修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li></ul><h4 id="二-C-和C的区别"><a href="#二-C-和C的区别" class="headerlink" title="二.C++和C的区别"></a>二.C++和C的区别</h4><ul><li>设计思想上：<ul><li>C++是面向对象的语言，而C是面向过程的结构化编程语言</li></ul></li><li>语法上：<ul><li>C++具有重载、继承和多态三种特性</li><li>C++相比C，增加多许多类型安全的功能，比如强制类型转换</li><li>C++支持范式编程，比如模板类、函数模板等</li></ul></li></ul><h4 id="三-c-中四种cast转换"><a href="#三-c-中四种cast转换" class="headerlink" title="三.c++中四种cast转换"></a>三.c++中四种cast转换</h4><ul><li>C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast<ul><li>1.const_cast:对于未定义const版本的成员函数，我们通常需要使用const_cast来去除const引用对象的const，完成函数调用。另外一种使用方式，结合static_cast，可以在非const版本的成员函数内添加const，调用完const版本的成员函数后，再使用const_cast去除const限定。</li><li>2.static_cast:完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换。</li><li>3.dynamic_cast:用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上(指的是子类向基类的转换)和向下转化(指的是基类向子类的转换)。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</li><li>4.reinterpret_cast:几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</li></ul></li></ul><h4 id="四-C-C-中指针和引用的区别？"><a href="#四-C-C-中指针和引用的区别？" class="headerlink" title="四.C/C++ 中指针和引用的区别？"></a>四.C/C++ 中指针和引用的区别？</h4><ul><li>1.指针有自己的一块空间，而引用只是一个别名；</li><li>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；</li><li>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；</li><li>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；</li><li>5.可以有const指针，但是没有const引用；</li><li>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能 被改变；</li><li>7.指针可以有多级指针（**p），而引用只有一级</li><li>8.指针和引用使用++运算符的意义不一样；</li><li>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露</li></ul><h4 id="五-c-中的四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr"><a href="#五-c-中的四个智能指针：-shared-ptr-unique-ptr-weak-ptr-auto-ptr" class="headerlink" title="五.c++中的四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr"></a>五.c++中的四个智能指针： shared_ptr,unique_ptr,weak_ptr,auto_ptr</h4><ul><li>智能指针出现的原因：智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。<ul><li>1.auto_ptr（c++98的方案，c++11已经抛弃）原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。</li><li>2.unique_ptr（替换auto_ptr）：是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。unique_ptr 用于取代 auto_ptr</li><li>3.shared_ptr：shared_ptr实现共享式拥有概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</li><li>4.weak_ptr：weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题。</li></ul></li></ul><h4 id="六-野指针"><a href="#六-野指针" class="headerlink" title="六.野指针"></a>六.野指针</h4><ul><li>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</li></ul><h4 id="七-为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数"><a href="#七-为什么析构函数必须是虚函数？为什么C-默认的析构函数不是虚函数" class="headerlink" title="七.为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数"></a>七.为什么析构函数必须是虚函数？为什么C++默认的析构函数不是虚函数</h4><ul><li>将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。</li><li>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数。</li></ul><h4 id="八-函数指针"><a href="#八-函数指针" class="headerlink" title="八.函数指针"></a>八.函数指针</h4><ul><li>1.定义：函数指针是指向函数的指针变量。函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。<strong>C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的</strong>。</li><li>2.用途：调用函数和做函数的参数，比如回调函数。</li><li>3.示例：  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char * <span class="function"><span class="title">fun</span><span class="params">(char * p)</span></span>  &#123;…&#125;       <span class="comment">//  指针函数fun</span></span><br><span class="line">char * (*pf)(char * p);             <span class="comment">//  函数指针pf</span></span><br><span class="line">pf = <span class="function"><span class="keyword">fun</span>;                        // 函数指针pf指向函数<span class="keyword">fun</span></span></span><br><span class="line">pf(p);                        <span class="comment">// 通过函数指针pf调用函数fun</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="九-fork函数的作用"><a href="#九-fork函数的作用" class="headerlink" title="九.fork函数的作用"></a>九.fork函数的作用</h4><ul><li><p>Fork：创建一个和当前进程映像一样的进程可以通过fork( )系统调用，如下所示</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure></li><li><p>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。</p></li><li>最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。</li></ul><h4 id="十-C-中析构函数的作用"><a href="#十-C-中析构函数的作用" class="headerlink" title="十.C++中析构函数的作用"></a>十.C++中析构函数的作用</h4><ul><li>析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。</li><li>析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别于构造函数。它不能带任何参数，也没有返回值（包括void类型）。<strong>只能有一个析构函数，不能重载</strong>。</li><li>如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作，所以许多简单的类中没有用显式的析构函数。</li><li>如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显式构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。</li><li>类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。</li></ul><h4 id="十一-静态函数和虚函数的区别"><a href="#十一-静态函数和虚函数的区别" class="headerlink" title="十一.静态函数和虚函数的区别"></a>十一.静态函数和虚函数的区别</h4><ul><li>静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销。</li></ul><h4 id="十二-重载和重写"><a href="#十二-重载和重写" class="headerlink" title="十二.重载和重写"></a>十二.重载和重写</h4><ul><li>重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，在同一作用域中</li><li>重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写</li></ul><h4 id="十三-虚函数和多态"><a href="#十三-虚函数和多态" class="headerlink" title="十三.虚函数和多态"></a>十三.虚函数和多态</h4><ul><li>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。</li><li>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</li></ul><h4 id="十四-下面四个代码的区别const-char-arr-“123”-char-brr-“123”-const-char-crr-“123”-char-drr-“123”"><a href="#十四-下面四个代码的区别const-char-arr-“123”-char-brr-“123”-const-char-crr-“123”-char-drr-“123”" class="headerlink" title="十四.下面四个代码的区别const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;"></a>十四.下面四个代码的区别const char * arr = “123”; char * brr = “123”; const char crr[] = “123”; char drr[] = “123”;</h4><ul><li>const char * arr = “123”;  // 字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样</li><li>char * brr = “123”; // 字符串123保存在常量区，这个brr指针指向的是同一个位置，同样不能通过brr去修改”123”的值</li><li>const char crr[] = “123”;   // 这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区</li><li>char drr[] = “123”;  // 字符串123保存在栈区，可以通过drr去修改</li></ul><h4 id="十五-const修饰成员函数的目的是什么？"><a href="#十五-const修饰成员函数的目的是什么？" class="headerlink" title="十五.const修饰成员函数的目的是什么？"></a>十五.const修饰成员函数的目的是什么？</h4><ul><li>const修饰的成员函数表明函数调用不会对对象做出任何更改，事实上，如果确认不会对对象做更改，就应该为函数加上const限定，这样无论const对象还是普通对象都可以调用该函数。</li></ul><h4 id="十六-C-里是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#十六-C-里是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="十六.C++里是怎么定义常量的？常量存放在内存的哪个位置？"></a>十六.C++里是怎么定义常量的？常量存放在内存的哪个位置？</h4><ul><li>对于局部常量，存放在栈区；对于全局常量，编译期一般不分配内存，放在符号表中以提高访问效率；字面值常量，比如字符串，放在常量区。</li></ul><h4 id="十七-new-delete与malloc-free的区别是什么"><a href="#十七-new-delete与malloc-free的区别是什么" class="headerlink" title="十七.new/delete与malloc/free的区别是什么"></a>十七.new/delete与malloc/free的区别是什么</h4><ul><li>首先，new/delete是C++的关键字，而malloc/free是C语言的库函数；后者使用必须指明申请内存空间的大小，对于类类型的对象，后者不会调用构造函数和析构函数。</li></ul><h4 id="十八-虚函数表具体是怎样实现运行时多态的"><a href="#十八-虚函数表具体是怎样实现运行时多态的" class="headerlink" title="十八.虚函数表具体是怎样实现运行时多态的?"></a>十八.虚函数表具体是怎样实现运行时多态的?</h4><ul><li>子类若重写父类虚函数，虚函数表中，该函数的地址会被替换，对于存在虚函数的类的对象，在VS中，对象模型的头部存放指向虚函数表的指针，通过该机制实现多态。</li></ul><h4 id="十九-C语言是怎么进行函数调用的？"><a href="#十九-C语言是怎么进行函数调用的？" class="headerlink" title="十九.C语言是怎么进行函数调用的？"></a>十九.C语言是怎么进行函数调用的？</h4><ul><li>每一个函数调用都会分配函数栈，在栈内进行函数执行过程。调用前，先把返回地址压栈，然后把当前函数的esp指针压栈。</li></ul><h4 id="二十-C-如何处理返回值？"><a href="#二十-C-如何处理返回值？" class="headerlink" title="二十.C++如何处理返回值？"></a>二十.C++如何处理返回值？</h4><ul><li>生成一个临时变量，把它的引用作为函数参数传入函数内。</li></ul><h4 id="二十一-C-中拷贝赋值函数的形参能否进行值传递？"><a href="#二十一-C-中拷贝赋值函数的形参能否进行值传递？" class="headerlink" title="二十一.C++中拷贝赋值函数的形参能否进行值传递？"></a>二十一.C++中拷贝赋值函数的形参能否进行值传递？</h4><ul><li>不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。</li></ul><h4 id="二十二-malloc与new区别"><a href="#二十二-malloc与new区别" class="headerlink" title="二十二.malloc与new区别"></a>二十二.malloc与new区别</h4><ul><li>malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存大小，返回的指针不用强转。</li></ul><h4 id="二十三-fork-wait-exec函数的作用"><a href="#二十三-fork-wait-exec函数的作用" class="headerlink" title="二十三.fork,wait,exec函数的作用"></a>二十三.fork,wait,exec函数的作用</h4><ul><li>父进程产生子进程使用fork拷贝出来一个父进程的副本，此时只拷贝了父进程的页表，两个进程都读同一块内存，当有进程写的时候使用写实拷贝机制分配内存；exec函数可以加载一个elf文件去替换父进程，从此父进程和子进程就可以运行不同的程序了。fork从父进程返回子进程的pid，从子进程返回0；调用了wait的父进程将会发生阻塞，直到有子进程状态改变,执行成功返回0，错误返回-1。exec执行成功则子进程从新的程序开始运行，无返回值，执行失败返回-1。</li></ul><h4 id="二十四-C-中类成员的访问权限"><a href="#二十四-C-中类成员的访问权限" class="headerlink" title="二十四.C++中类成员的访问权限"></a>二十四.C++中类成员的访问权限</h4><ul><li>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。</li></ul><h4 id="二十五-C-中struct和class的区别"><a href="#二十五-C-中struct和class的区别" class="headerlink" title="二十五. C++中struct和class的区别"></a>二十五. C++中struct和class的区别</h4><ul><li>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</li><li>区别：最本质的一个区别就是默认的访问控制<ul><li>默认的继承访问权限。struct 是 public 的，class 是 private 的</li><li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li></ul></li></ul><h4 id="二十六-C-类的内部可以定义引用数据成员吗？"><a href="#二十六-C-类的内部可以定义引用数据成员吗？" class="headerlink" title="二十六.C++类的内部可以定义引用数据成员吗？"></a>二十六.C++类的内部可以定义引用数据成员吗？</h4><ul><li>可以，必须通过成员函数初始化列表初始化  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="keyword">int</span> &amp;i):  a(<span class="number">1</span>),   b(i)&#123;         <span class="comment">//  构造函数初始化列表中是初始化工作</span></span><br><span class="line">        <span class="comment">//   在这里做的是赋值而非初始化工作</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> &amp;b;  <span class="comment">// 引用数据成员b,必须通过列表初始化！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="二十七-什么是右值引用，跟左值又有什么区别？"><a href="#二十七-什么是右值引用，跟左值又有什么区别？" class="headerlink" title="二十七.什么是右值引用，跟左值又有什么区别？"></a>二十七.什么是右值引用，跟左值又有什么区别？</h4><ul><li>左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。</li><li>右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。</li><li>右值引用和左值引用的区别：<ul><li>1.左值可以寻址，而右值不可以；</li><li>2.左值可以被赋值，右值不可以被赋值，可以用来给左值赋值；</li><li>3.左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。</li></ul></li></ul><h4 id="二十八-C-源文件从文本到可执行文件经历的过程？"><a href="#二十八-C-源文件从文本到可执行文件经历的过程？" class="headerlink" title="二十八.C++源文件从文本到可执行文件经历的过程？"></a>二十八.C++源文件从文本到可执行文件经历的过程？</h4><ul><li>对于C++源文件，从文本到可执行文件一般需要四个过程：<ul><li>预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。</li><li>编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件</li><li>汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件</li><li>链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件</li></ul></li></ul><h4 id="二十九-include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？"><a href="#二十九-include头文件的顺序以及双引号””和尖括号-lt-gt-的区别？" class="headerlink" title="二十九.include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？"></a>二十九.include头文件的顺序以及双引号””和尖括号&lt;&gt;的区别？</h4><ul><li>include头文件的顺序：对于include的头文件来说，如果在文件a.h中声明一个在文件b.h中定义的变量，而不引用b.h。那么要在a.c文件中引用b.h文件，并且要先引用b.h，后引用a.h,否则汇报变量类型未声明错误。</li><li>双引号和尖括号的区别：<strong>编译器预处理阶段查找头文件的路径不一样</strong>。<strong>对于使用双引号包含的头文件</strong>，查找头文件路径的顺序为：当前头文件目录、编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）、系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径；<strong>对于使用尖括号包含的头文件</strong>，查找头文件的路径顺序为：编译器设置的头文件路径（编译器可使用-I显式指定搜索路径）、系统变量CPLUS_INCLUDE_PATH/C_INCLUDE_PATH指定的头文件路径。</li></ul><h4 id="三十-什么时候会发生段错误？"><a href="#三十-什么时候会发生段错误？" class="headerlink" title="三十.什么时候会发生段错误？"></a>三十.什么时候会发生段错误？</h4><ul><li>段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：<ul><li>使用野指针</li><li>试图修改字符串常量的内容</li></ul></li></ul><h4 id="三十一-C-11有哪些新特性？"><a href="#三十一-C-11有哪些新特性？" class="headerlink" title="三十一.C++11有哪些新特性？"></a>三十一.C++11有哪些新特性？</h4><ul><li>auto关键字：编译器可以根据初始值自动推导出类型，但是不能用于函数传参以及数组类型的推导；</li><li>nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。</li><li>智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。</li><li>初始化列表：使用初始化列表来对类进行初始化</li><li>右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率</li><li>atomic原子操作用于多线程资源互斥操作</li><li>新增STL容器array以及tuple</li></ul><h4 id="三十二-const的作用"><a href="#三十二-const的作用" class="headerlink" title="三十二.const的作用"></a>三十二.const的作用</h4><ul><li>1.修饰变量，说明该变量不可以被修改</li><li>2.修饰指针，分为指向常量的指针(即常量指针)和指针常量</li><li>3.常量引用，经常用于形参类型，既避免了拷贝，又避免了函数对值的修改</li><li>4.修饰成员函数，说明该成员函数内不能修改成员变量</li><li>const用法如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 常指针</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 常引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 常量指针即常指针，指针的指向可以改变，但是所存的内容不能变</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* p2 = greeting;     <span class="comment">// 与const char* p2 等价</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 指针常量，指针是一个常量，即指针的指向不能改变，但是指针所存的内容可以改变</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 指向常量的常指针，指针和指针所存的内容都不能改变，本质是一个常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数为常量指针即指针所指的内容为常量不能变，指针指向可以改变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数为指针常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量即常量指针，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针即指针常量，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="三十三-this-指针"><a href="#三十三-this-指针" class="headerlink" title="三十三.this 指针"></a>三十三.this 指针</h4><ul><li>this 指针是一个隐含于每一个<strong>非静态成员函数</strong>中的特殊指针。它指向调用该成员函数的那个对象。</li><li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。</li><li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li><li>this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li><li>this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。<br>在以下场景中，经常需要显式引用 this 指针：<ul><li>为实现对象的链式引用；</li><li>为避免对同一对象进行赋值操作；</li><li>在实现一些数据结构时，如 list。</li></ul></li></ul><h4 id="三十四-inline内联函数"><a href="#三十四-inline内联函数" class="headerlink" title="三十四.inline内联函数"></a>三十四.inline内联函数</h4><ul><li>内联函数的特点：<ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li></ul></li><li><p>内联函数的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> A::doA() &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure></li><li><p><strong>编译器对内联函数的处理步骤</strong>:</p><ul><li>将 inline 函数体复制到 inline 函数调用点处；</li><li>为所用 inline 函数中的局部变量分配内存空间；</li><li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）</li></ul></li><li><strong>使用内联函数的优缺点</strong>:<ul><li>优点:<ul><li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li><li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li><li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li><li>内联函数在运行时可调试，而宏定义不可以。</li></ul></li><li>缺点:<ul><li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li><li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li><li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li></ul></li></ul></li><li><strong>虚函数可以是内联函数吗？</strong><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li><li>虚函数内联使用实例如下:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。</span></span><br><span class="line">    Base b;</span><br><span class="line">    b.who();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。</span></span><br><span class="line">    Base *ptr = <span class="keyword">new</span> Derived();</span><br><span class="line">    ptr-&gt;who();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() &#123;&#125;），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="三十五-volatile关键字"><a href="#三十五-volatile关键字" class="headerlink" title="三十五.volatile关键字"></a>三十五.volatile关键字</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><ul><li>volatile 关键字是一种类型修饰符，<strong>用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改</strong>。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li><li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li><li>const 可以是 volatile （如只读的状态寄存器）</li><li>指针可以是volatile</li></ul><h4 id="三十六-assert"><a href="#三十六-assert" class="headerlink" title="三十六.assert()"></a>三十六.assert()</h4><ul><li><strong>断言是宏，而非函数</strong>。assert 宏的原型定义在 <assert.h>（C）、\<cassert\>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include <assert.h> 之前。</assert.h></cassert\></assert.h></li><li>assert()使用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG          <span class="comment">// 加上这行，则 assert 不可用</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">assert( p != <span class="literal">NULL</span> );    <span class="comment">// assert 不可用</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="三十七-sizeof-运算符"><a href="#三十七-sizeof-运算符" class="headerlink" title="三十七.sizeof()运算符"></a>三十七.sizeof()运算符</h4><ul><li>sizeof 对数组，得到整个数组所占空间大小。</li><li>sizeof 对指针，得到指针本身所占空间大小。</li></ul><h4 id="三十八-pragma-pack-n"><a href="#三十八-pragma-pack-n" class="headerlink" title="三十八.#pragma pack(n)"></a>三十八.#pragma pack(n)</h4><ul><li>用途：设定结构体、联合以及类成员变量以 n 字节方式对齐</li><li>#pragma pack(n)使用实例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push)  <span class="comment">// 保存对齐状态</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)     <span class="comment">// 设定为 4 字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> m1;</span><br><span class="line">    <span class="keyword">double</span> m4;</span><br><span class="line">    <span class="keyword">int</span> m3;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop)   <span class="comment">// 恢复对齐状态</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="三十九-extern-“C”"><a href="#三十九-extern-“C”" class="headerlink" title="三十九. extern “C”"></a>三十九. extern “C”</h4><ul><li>用途：extern “C” 的作用是让 C++ 编译器将 extern “C” 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</li><li>被 extern 限定的函数或变量是 extern 类型的；被 extern “C” 修饰的变量和函数是按照 C 语言方式编译和链接的</li><li>extern “C”实例如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><h4 id="四十-struct-和-typedef-struct"><a href="#四十-struct-和-typedef-struct" class="headerlink" title="四十.struct 和 typedef struct"></a>四十.struct 和 typedef struct</h4><ul><li><p>C语言中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; S;</span><br><span class="line"><span class="comment">// 等价于下面</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">S</span>;</span></span><br></pre></td></tr></table></figure></li><li><p>C++中：</p><ul><li><p>1.如果在类标识符空间定义了 struct Student {…};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。即表现为可以使用 Student 也可以使用 struct Student，如下：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( Student me )</span></span>;       <span class="comment">// 正确，"struct" 关键字可省略</span></span><br></pre></td></tr></table></figure></li><li><p>2.若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;           <span class="comment">// 正确，定义后 "Student" 只代表此函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void S() &#123;&#125;               // 错误，符号 "S" 已经被定义为一个 "struct Student" 的别名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">me</span>;</span>      <span class="comment">// 或者 "S me";</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="四十一-union联合体"><a href="#四十一-union联合体" class="headerlink" title="四十一.union联合体"></a>四十一.union联合体</h4><ul><li>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：<ul><li>默认访问控制符为 public</li><li>可以含有构造函数、析构函数</li><li>不能含有引用类型的成员</li><li>不能继承自其他类，不能作为基类</li><li>不能含有虚函数</li><li>匿名 union 在定义所在作用域可直接访问 union 成员</li><li>匿名 union 不能包含 protected 成员或 private 成员</li><li>全局匿名联合必须是静态（static）的</li></ul></li><li>union使用实例如下：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> UnionTest &#123;</span><br><span class="line">    UnionTest() : i(<span class="number">10</span>) &#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UnionTest u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u.i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出 UnionTest 联合的 10</span></span><br><span class="line"></span><br><span class="line">    ::i = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出全局静态匿名联合的 20</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 输出局部匿名联合的 30</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="四十二-explicit（显式）关键字"><a href="#四十二-explicit（显式）关键字" class="headerlink" title="四十二.explicit（显式）关键字"></a>四十二.explicit（显式）关键字</h4><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化，必须显式初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换，但按语境转换 除外</li><li>explicit使用实例如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A(<span class="keyword">int</span>) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doA</span><span class="params">(A a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doB</span><span class="params">(B b)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">1</span>)</span></span>;        <span class="comment">// OK：直接初始化</span></span><br><span class="line">    A a2 = <span class="number">1</span>;       <span class="comment">// OK：复制初始化</span></span><br><span class="line">    A a3&#123; <span class="number">1</span> &#125;;      <span class="comment">// OK：直接列表初始化</span></span><br><span class="line">    A a4 = &#123; <span class="number">1</span> &#125;;       <span class="comment">// OK：复制列表初始化</span></span><br><span class="line">    A a5 = (A)<span class="number">1</span>;        <span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">    doA(<span class="number">1</span>);         <span class="comment">// OK：允许从 int 到 A 的隐式转换</span></span><br><span class="line">    <span class="keyword">if</span> (a1);        <span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">    <span class="keyword">bool</span> a6（a1）;        <span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">    <span class="keyword">bool</span> a7 = a1;       <span class="comment">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换</span></span><br><span class="line">    <span class="keyword">bool</span> a8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(a1);  <span class="comment">// OK ：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;        <span class="comment">// OK：直接初始化</span></span><br><span class="line">    B b2 = <span class="number">1</span>;       <span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化</span></span><br><span class="line">    B b3&#123; <span class="number">1</span> &#125;;      <span class="comment">// OK：直接列表初始化</span></span><br><span class="line">    B b4 = &#123; <span class="number">1</span> &#125;;       <span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化</span></span><br><span class="line">    B b5 = (B)<span class="number">1</span>;        <span class="comment">// OK：允许 static_cast 的显式转换</span></span><br><span class="line">    doB(<span class="number">1</span>);         <span class="comment">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换</span></span><br><span class="line">    <span class="keyword">if</span> (b1);        <span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">b6</span><span class="params">(b1)</span></span>;        <span class="comment">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换</span></span><br><span class="line">    <span class="keyword">bool</span> b7 = b1;       <span class="comment">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换</span></span><br><span class="line">    <span class="keyword">bool</span> b8 = <span class="keyword">static_cast</span>&lt;<span class="keyword">bool</span>&gt;(b1);  <span class="comment">// OK：static_cast 进行直接初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="四十三-friend友元类和友元函数"><a href="#四十三-friend友元类和友元函数" class="headerlink" title="四十三.friend友元类和友元函数"></a>四十三.friend友元类和友元函数</h4><ul><li>能访问私有成员、破坏封装性、友元关系不可传递、友元关系的单向性、友元声明的形式及数量不受限制</li></ul><h4 id="四十四-范围解析运算符"><a href="#四十四-范围解析运算符" class="headerlink" title="四十四.:: 范围解析运算符"></a>四十四.:: 范围解析运算符</h4><ul><li>种类：<ul><li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ul></li><li>使用实例：  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;        <span class="comment">// 全局（::）的 count</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">count</span>; <span class="comment">// 类 A 的 count（A::count）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    ::<span class="keyword">count</span> = <span class="number">1</span>;      <span class="comment">// 设置全局的 count 的值为 1</span></span><br><span class="line"></span><br><span class="line">    A::<span class="keyword">count</span> = <span class="number">2</span>;     <span class="comment">// 设置类 A 的 count 为 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;    <span class="comment">// 局部的 count</span></span><br><span class="line">    <span class="keyword">count</span> = <span class="number">3</span>;        <span class="comment">// 设置局部的 count 的值为 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="四十五-enum枚举类型"><a href="#四十五-enum枚举类型" class="headerlink" title="四十五.enum枚举类型"></a>四十五.enum枚举类型</h4><ul><li><p>限定作用域的枚举类型:</p>  <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> <span class="title">open_modes</span> &#123; <span class="title">input</span>, <span class="title">output</span>, <span class="title">append</span> &#125;;</span></span><br></pre></td></tr></table></figure></li><li><p>不限定作用域的枚举类型:</p>  <figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> </span>&#123; red, yellow, green &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="四十六-decltype关键字"><a href="#四十六-decltype关键字" class="headerlink" title="四十六.decltype关键字"></a>四十六.decltype关键字</h4><ul><li>作用和用法：用于检查实体的声明类型或表达式的类型及值分类。语法：decltype ( expression )</li><li>decltype实例如下：  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="keyword">auto</span> fcn(It beg, It <span class="built_in">end</span>) -&gt; <span class="keyword">decltype</span>(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="built_in">return</span> *beg;    <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为了使用模板参数成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="keyword">auto</span> fcn2(It beg, It <span class="built_in">end</span>) -&gt; <span class="keyword">typename</span> remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="built_in">return</span> *beg;    <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="四十七-引用和宏"><a href="#四十七-引用和宏" class="headerlink" title="四十七.引用和宏"></a>四十七.引用和宏</h4><ul><li>左值引用：常规引用，一般表示对象的身份</li><li>右值引用：右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值；右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：<ul><li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li><li>能够更简洁明确地定义泛型函数。</li></ul></li><li>引用折叠： X&amp; &amp;、X&amp; &amp;&amp;、X&amp;&amp; &amp; 可折叠成 X&amp;；X&amp;&amp; &amp;&amp; 可折叠成 X&amp;&amp;</li><li>宏：宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，<strong>在宏展开的时候对 “参数” 进行的是一对一的替换</strong>。</li></ul><h4 id="四十八-必须使用成员初始化列表的场合"><a href="#四十八-必须使用成员初始化列表的场合" class="headerlink" title="四十八.必须使用成员初始化列表的场合"></a>四十八.必须使用成员初始化列表的场合</h4><ul><li>好处：更高效：少了一次调用默认构造函数的过程。</li><li><strong>有些场合必须要用初始化列表：</strong><ul><li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li><li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li><li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li></ul></li></ul><h4 id="四十九-面向对象三大特征"><a href="#四十九-面向对象三大特征" class="headerlink" title="四十九.面向对象三大特征"></a>四十九.面向对象三大特征</h4><ul><li><strong>封装</strong>：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。<ul><li>public 成员：可以被任意实体访问</li><li>protected 成员：只允许被子类及本类的成员函数访问</li><li>private 成员：只允许被本类的成员函数、友元类或友元函数访问</li></ul></li><li><strong>继承</strong>：基类（父类）——&gt; 派生类（子类）</li><li><p><strong>多态</strong>：即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。<strong>多态是以封装和继承为基础的</strong>。</p><ul><li>C++ 多态分类及实现：<ul><li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li><li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li><li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li><li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li></ul></li><li><p><strong>静态多态(编译期/早绑定)</strong></p><ul><li>函数重载实例:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>动态多态(运行期/晚绑定)</strong></p><ul><li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li><li><strong>注意：</strong><ul><li>普通函数（非类成员函数）不能是虚函数</li><li>静态函数（static）不能是虚函数</li><li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li><li>内联函数不能是表现多态性时的虚函数</li></ul></li><li>动态多态实例  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>                     // 形状类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Shape       <span class="comment">// 矩形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    Shape * shape2 = <span class="keyword">new</span> Rect(<span class="number">5.0</span>, <span class="number">6.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();         <span class="comment">// 调用圆形类里面的方法</span></span><br><span class="line">    shape2-&gt;calcArea();         <span class="comment">// 调用矩形类里面的方法</span></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    shape1 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    shape2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="五十-虚析构函数"><a href="#五十-虚析构函数" class="headerlink" title="五十.虚析构函数"></a>五十.虚析构函数</h4><ul><li>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</li><li>虚析构函数的使用如下: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Shape();                    <span class="comment">// 构造函数不能是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~Shape();           <span class="comment">// 虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shape     <span class="comment">// 圆形类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">calcArea</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape * shape1 = <span class="keyword">new</span> Circle(<span class="number">4.0</span>);</span><br><span class="line">    shape1-&gt;calcArea();</span><br><span class="line">    <span class="keyword">delete</span> shape1;  <span class="comment">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。</span></span><br><span class="line">    shape1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="五十一-纯虚函数"><a href="#五十一-纯虚函数" class="headerlink" title="五十一.纯虚函数"></a>五十一.纯虚函数</h4><ul><li>定义：纯虚函数是一种特殊的虚函数，<strong>在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做</strong>。</li><li>用法：  virtual int A() = 0;</li></ul><h4 id="五十二-虚函数、纯虚函数"><a href="#五十二-虚函数、纯虚函数" class="headerlink" title="五十二.虚函数、纯虚函数"></a>五十二.虚函数、纯虚函数</h4><ul><li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖，这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li><li>虚函数在子类里面也可以不重载的；但纯虚函数必须在子类去实现。</li><li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。当然大家也可以完成自己的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li><li><strong>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</strong></li><li>虚基类是虚继承中的基类。</li></ul><h4 id="五十三-虚函数指针、虚函数表"><a href="#五十三-虚函数指针、虚函数表" class="headerlink" title="五十三.虚函数指针、虚函数表"></a>五十三.虚函数指针、虚函数表</h4><ul><li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li><li>虚函数表：在程序只读数据段，存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚函数表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li></ul><h4 id="五十四-虚继承"><a href="#五十四-虚继承" class="headerlink" title="五十四.虚继承"></a>五十四.虚继承</h4><ul><li>用途：用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）</li><li>底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</li></ul><h4 id="五十五-虚继承、虚函数"><a href="#五十五-虚继承、虚函数" class="headerlink" title="五十五.虚继承、虚函数"></a>五十五.虚继承、虚函数</h4><ul><li>相同点：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li><li>不同点：<ul><li>虚继承：<ul><li>虚基类依旧存在继承类中，只占用存储空间</li><li>虚基类表存储的是虚基类相对直接继承类的偏移</li></ul></li><li>虚函数：<ul><li>虚函数不占用存储空间</li><li>虚函数表存储的是虚函数地址</li></ul></li></ul></li></ul><h4 id="五十六-模板类、成员模板、虚函数"><a href="#五十六-模板类、成员模板、虚函数" class="headerlink" title="五十六.模板类、成员模板、虚函数"></a>五十六.模板类、成员模板、虚函数</h4><ul><li>模板类中可以使用虚函数</li><li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li></ul><h4 id="五十七-抽象类、接口类、聚合类"><a href="#五十七-抽象类、接口类、聚合类" class="headerlink" title="五十七.抽象类、接口类、聚合类"></a>五十七.抽象类、接口类、聚合类</h4><ul><li>抽象类：含有纯虚函数的类</li><li>接口类：仅含有纯虚函数的抽象类</li><li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：<ul><li>所有成员都是 public</li><li>没有定义任何构造函数</li><li>没有类内初始化</li><li>没有基类，也没有 virtual 函数</li></ul></li></ul><h4 id="五十八-内存分配和管理"><a href="#五十八-内存分配和管理" class="headerlink" title="五十八.内存分配和管理"></a>五十八.内存分配和管理</h4><ul><li>malloc、calloc、realloc、alloca<ul><li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li><li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li><li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li><li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li></ul></li><li><p>malloc和free</p><ul><li>用途：用于分配、释放内存</li><li><p>使用：</p><ul><li><p>申请内存，确认是否申请成功</p> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *str = (<span class="name">char*</span>) malloc(<span class="number">100</span>)<span class="comment">;</span></span><br><span class="line">assert(<span class="name">str</span> != nullptr)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>释放内存后指针置空</p>  <figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">free(p)<span class="comment">;</span></span><br><span class="line"><span class="attribute">p</span> = nullptr<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>new和delete</p><ul><li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li><li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li><li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li><li>使用：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T* t = <span class="keyword">new</span> T();     <span class="comment">// 先内存分配 ，再构造函数</span></span><br><span class="line">    <span class="keyword">delete</span> t;           <span class="comment">// 先析构函数，再内存释放</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="五十九-delete-this-合法吗？"><a href="#五十九-delete-this-合法吗？" class="headerlink" title="五十九.delete this 合法吗？"></a>五十九.delete this 合法吗？</h4><ul><li>合法，但是：<ul><li>必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 delete this 后面没有调用 this 了</li><li>必须保证 delete this 后没有人使用了</li></ul></li></ul><h4 id="六十-如何定义一个只能在堆上（栈上）生成对象的类？"><a href="#六十-如何定义一个只能在堆上（栈上）生成对象的类？" class="headerlink" title="六十.如何定义一个只能在堆上（栈上）生成对象的类？"></a>六十.如何定义一个只能在堆上（栈上）生成对象的类？</h4><ul><li><strong>只能在堆上</strong><ul><li>方法： 将析构函数设置为私有</li><li>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</li></ul></li><li><strong>只能在栈上</strong><ul><li>方法：将 new 和 delete 重载为私有</li><li>原因： 在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</li></ul></li></ul><h4 id="六十一-强制类型转换运算符-4种"><a href="#六十一-强制类型转换运算符-4种" class="headerlink" title="六十一.强制类型转换运算符(4种)"></a>六十一.强制类型转换运算符(4种)</h4><ul><li>static_cast<ul><li>特点：静态转换，在编译处理期间。</li><li>应用场合： 主要用于C++中内置的基本数据类型之间的转换，但是没有运行时类型的检测来保证转换的安全性。<ul><li>a.用于基类和子类之间的指针或引用之间的转换，这种转换把子类的指针或引用转换为基类表示是安全的；进行下行转换，把积累的指针或引用转换为子类表示时，由于没有进行动态类型检测，所以是不安全的。</li><li>b.把void类型的指针转换成目标类型的指针（不安全）</li><li>c.不能用于两个不相关的类型转换</li><li>d.不能把const对象转换成非const对象</li></ul></li></ul></li><li>const_cast<ul><li>特点：去常转换，编译时执行。</li><li>应用场合： const_cast操作不能在不同的种类间转换。相反，它仅仅把它作用的表达式转换成常量。它可以使一个本来不是const类型的数据转换成const类型的，或者把const属性去掉。</li></ul></li><li>reinterpret_cast:<ul><li>特点：重解释类型转换</li><li>应用场合： 它有着和c风格强制类型转换同样的功能；它可以转化任何的内置数据类型为其他的类型，同时它也可以把任何类型的指针转化为其他的类型；它的机理是对二进制进行重新的解释，不会改变原来的格式。</li></ul></li><li>dynamic_cast &lt; type-id &gt; ( expression )<ul><li>特点：该运算符将expression转换成type_id类型的对象。type_id必须是类的指针，类的引用或者空类型的指针。</li><li>应用场合：<ul><li>a.如果type_id是一个指针类型，那么expression也必须是一个指针类型，如果type_id是一个引用类型，那么expression也必须是一个引用类型。</li><li>b.如果type_id是一个空类型的指针，在运行的时候，就会检测expression的实际类型，结果是一个由expression决定的指针类型。</li><li>c.如果type_id不是空类型的指针，在运行的时候指向expression对象的指针能否可以转换成type_id类型的指针</li><li>d.在运行的时候决定真正的类型，如果向下转换是安全的，就返回一个转换后的指针，若不安全，则返回一个空指针</li><li>e.主要用于上下行之间的转换，也可以用于类之间的交叉转换。上行转换时和static_cast效果一样，下行转换时，具有检测功能，比static_cast更安全。</li></ul></li></ul></li></ul><h4 id="六十二-new-delete和malloc-free的联系和区别"><a href="#六十二-new-delete和malloc-free的联系和区别" class="headerlink" title="六十二.new delete和malloc free的联系和区别"></a>六十二.new delete和malloc free的联系和区别</h4><ul><li>malloc与free是C语言的标准库函数， new/delete是C++的运算符。它们都可用于申请动态内存和释放内存;</li><li>对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构<br>造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之<br>内，不能够把执行构造函数和析构函数的任务强加于malloc/free;</li><li>C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete，注意new/delete不是库函数。</li></ul><h4 id="六十三-hash冲突及解决方法"><a href="#六十三-hash冲突及解决方法" class="headerlink" title="六十三.hash冲突及解决方法"></a>六十三.hash冲突及解决方法</h4><ul><li>关键字值不同的元素可能会映射到哈希表的同一地址上就会发生哈希冲突。解决办法：<ul><li><strong>开放定址法</strong>：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。查找时探查到开放的 地址则表明表中无待查的关键字，即查找失败。</li><li>再哈希法：同时构造多个不同的哈希函数</li><li>链地址法：将所有哈希地址为 i 的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第 i 个<br>单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况</li><li>建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</li></ul></li></ul><h4 id="六十四-多态是什么-多态的作用？"><a href="#六十四-多态是什么-多态的作用？" class="headerlink" title="六十四.多态是什么,多态的作用？"></a>六十四.多态是什么,多态的作用？</h4><ul><li>定义：同一个对象，在不同时刻体现出来的不同状态。</li><li>多态的前提：<ul><li>要有继承关系或实现关系（接口）</li><li>要有方法重写；</li><li>要有父类或者父接口引用指向子类Base b= new Derived()；</li></ul></li><li>作用：提高了代码的维护性（继承保证）；提高了代码的扩展性</li></ul><h4 id="六十五-继承含有纯虚函数的父类，子类能否实例化？"><a href="#六十五-继承含有纯虚函数的父类，子类能否实例化？" class="headerlink" title="六十五. 继承含有纯虚函数的父类，子类能否实例化？"></a>六十五. 继承含有纯虚函数的父类，子类能否实例化？</h4><ul><li>如果父类中存在纯虚函数，子类继承父类时，必须重写父类的纯虚函数，函数名、返回类型、参数个数和类型都不能改。若父类中的虚函数自己有定义，子类也可以不重写。之后便可以实例化子类。</li></ul><h4 id="六十六-构造函数是否可以用private修饰，如果可以，会有什么效果？"><a href="#六十六-构造函数是否可以用private修饰，如果可以，会有什么效果？" class="headerlink" title="六十六.构造函数是否可以用private修饰，如果可以，会有什么效果？"></a>六十六.构造函数是否可以用private修饰，如果可以，会有什么效果？</h4><ul><li>如果一个类的构造函数只有一个且为private，这是可以编译通过的；</li><li>如果一个类的构造函数只有一个且是private，如果类的内部没有专门创建实例的代码，则是无法创建任何实例的；</li><li>如果一个类的构造函数只有一个且是private，如果类的内部有专门创建实例的代码，则只能创建一个或多个实例（根据类内部声明的成员对象个数来定）；</li><li>如果一个类的构造函数不止一个，private 构造函数如果参数 为void(无参)，则子类无法编译；换言之，如果一个类构造函数只有private且存在子类，则无法编译，除非父类构造函数为public。</li></ul><h4 id="六十七-子类的指针能否转换为父类的指针？父类指针能否访问子类成员？"><a href="#六十七-子类的指针能否转换为父类的指针？父类指针能否访问子类成员？" class="headerlink" title="六十七.子类的指针能否转换为父类的指针？父类指针能否访问子类成员？"></a>六十七.子类的指针能否转换为父类的指针？父类指针能否访问子类成员？</h4><ul><li>当自己的类指针指向自己类的对象时，无论调用的是虚函数还是实函数，其调用的都是自己的</li><li>当指向父类对象的父类指针被强制转换成子类指针时候，子类指针调用函数时，只有非重写函数是自己的，虚函数是父类的；</li><li>当指向子类对象的子类指针被强制转换成父类指针的时候，也就是父类指针指向子类对象，此时，父类指针调用的虚函数都是子类的，而非虚函数都是自己的；</li></ul><h4 id="六十八-虚函数的实现机制"><a href="#六十八-虚函数的实现机制" class="headerlink" title="六十八.虚函数的实现机制"></a>六十八.虚函数的实现机制</h4><ul><li><a href="https://blog.csdn.net/jiangnanyouzi/article/details/3720807" target="_blank" rel="noopener">虚函数实现机制</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一-static关键字的作用&quot;&gt;&lt;a href=&quot;#一-static关键字的作用&quot; class=&quot;headerlink&quot; title=&quot;一.static关键字的作用&quot;&gt;&lt;/a&gt;一.static关键字的作用&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1.修饰普通变量，修改变量的存储
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/tags/C/"/>
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++常用参考资料</title>
    <link href="https://cdlwhm1217096231.github.io/%E5%B8%B8%E7%94%A8%E8%B5%84%E6%96%99/C-%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"/>
    <id>https://cdlwhm1217096231.github.io/常用资料/C-常用参考资料/</id>
    <published>2019-07-29T11:09:15.000Z</published>
    <updated>2019-07-29T11:10:16.456Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-常用参考资料"><a href="#1-常用参考资料" class="headerlink" title="1.常用参考资料"></a>1.常用参考资料</h4><ul><li><a href="http://c.biancheng.net/stl/" target="_blank" rel="noopener">STL标准模板库的使用</a></li><li><a href="https://zh.cppreference.com/w/cpp" target="_blank" rel="noopener">C++参考手册</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-常用参考资料&quot;&gt;&lt;a href=&quot;#1-常用参考资料&quot; class=&quot;headerlink&quot; title=&quot;1.常用参考资料&quot;&gt;&lt;/a&gt;1.常用参考资料&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://c.biancheng.net/stl/&quot; ta
      
    
    </summary>
    
      <category term="常用资料" scheme="https://cdlwhm1217096231.github.io/categories/%E5%B8%B8%E7%94%A8%E8%B5%84%E6%96%99/"/>
    
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/tags/C/"/>
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>神经网络中的批量归一化Batch Normalization(BN)原理总结</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%89%B9%E9%87%8F%E5%BD%92%E4%B8%80%E5%8C%96Batch-Normalization-BN-%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/深度学习/神经网络中的批量归一化Batch-Normalization-BN-原理总结/</id>
    <published>2019-07-29T11:02:46.000Z</published>
    <updated>2019-07-29T11:07:14.646Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h4><ul><li><strong>深层神经网络存在的问题(从当前层的输入的分布来分析)</strong>：在深层神经网络中，中间层的输入是上一层神经网络的输出。因此，之前的层的神经网络参数的变化会导致当前层输入的分布发生较大的差异。在使用随机梯度下降法来训练神经网络时，每次参数更新都会导致网络中每层的输入分布发生变化。越是深层的神经网络，其输入的分布会改变的越明显。</li><li><strong>解决方法(归一化操作)</strong>：从机器学习角度来看，如果某层的输入分布发生了变化，那么其参数需要重新学习，这种现象称为<strong>内部协变量偏移</strong>。为了解决内部协变量偏移问题，就要使得每一层神经网络输入的分布在训练过程中要保持一致。最简单的方法是<strong>对每一层神经网络都进行归一化操作，使其分布保持稳定</strong>。</li></ul><h4 id="1-批量归一化"><a href="#1-批量归一化" class="headerlink" title="1.批量归一化"></a>1.批量归一化</h4><ul><li><strong>协变量偏移介绍</strong><ul><li>在传统机器学习中，一个常见的问题是协变量偏移。协变量是一个统计学概念，是可能影响预测结果的统计变量。在机器学习中，协变量可以看作是<strong>输入</strong>。一般的机器学习算法都要求输入在训练集和测试集上的分布式相似的。如果不满足这个假设，在训练集上学习到的模型在测试集上的表现会比较差，如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/13407176-d93a5b732347ea1a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协变量偏移"></li></ul></li><li><strong>BN原理介绍</strong><ul><li>批量归一化方法是一种有效的逐层归一化的方法，可以对神经网络中任意的中间层进行归一化操作。对一个深层神经网络来说，令第l层的净输入为$\mathbf{z}^{(l)}$， 经过激活函数后的输出是$\mathbf{a}^{(l)}$，即<script type="math/tex; mode=display">\mathbf{a}^{(l)}=f\left(\mathbf{z}^{(l)}\right)=f\left(W \mathbf{a}^{(l-1)}+\mathbf{b}\right)</script>其中，$f(\cdot)$是激活函数，W和b是权重和偏置参数。</li><li>为了减少内部协变量偏移问题，就要使得净输入$\mathbf{z}^{(l)}$的分布一致，比如都归一化到标准正态分布。虽然归一化操作可以应用在输入$\mathbf{a}^{(l-1)}$上，但其分布性质不如$\mathbf{z}^{(l)}$稳定。因此，<strong>在实践中归一化操作一般应用在仿射变换之后，在下一次激活函数之前</strong>。利用数据预处理方法对$\mathbf{z}^{(l)}$进行归一化，相当于每一层都进行一次数据预处理，从而加速收敛速度。但是，逐层归一化需要在中间层进行操作，要求效率比较高，因此复杂度比较高的白话方法就不太合适。为了提高归一化效率，一般使用标准归一化，将净输入$\mathbf{z}^{(l)}$的每一维都归一到标准正态分布。<script type="math/tex; mode=display">\hat{\mathbf{z}}^{(l)}=\frac{\mathbf{z}^{(l)}-\mathbb{E}\left[\mathbf{z}^{(l)}\right]}{\sqrt{\operatorname{var}\left(\mathbf{z}^{(l)}\right)+\epsilon}}</script>其中，$\mathbb{E}\left[\mathbf{z}^{(l)}\right]$和$\operatorname{var}\left(\mathbf{z}^{(l)}\right)$是当前参数下，$\mathbf{z}^{(l)}$的每一维度在整个训练集上的期望和方差。因为目前主要的训练方法是基于Mini-Batch的随机梯度下降算法，所以准确地计算$\mathbf{z}^{(l)}$的期望和方差是不可行的。因此，$\mathbf{z}^{(l)}$的期望和方差通常用当前小批量Mini-Batch样本集的均值和方差近似估计。</li><li>给定一个包含K个样本的小批量样本集合，第l层神经元的净输入$\mathbf{z}^{(1,l)}$，….，$\mathbf{z}^{(K,l)}$的均值和方差为：<script type="math/tex; mode=display">\begin{aligned} \mu_{\mathcal{B}} &=\frac{1}{K} \sum_{k=1}^{\mathrm{N}} \mathbf{z}^{(k, l)} \\ \sigma_{\mathcal{B}}^{2} &=\frac{1}{K} \sum_{k=1}^{K}\left(\mathbf{z}^{(k, l)}-\mu_{\mathcal{B}}\right) \odot\left(\mathbf{z}^{(k, l)}-\mu_{\mathcal{B}}\right) \end{aligned}</script></li><li>对净输入$\mathbf{z}^{(l)}$的标准归一化会使得其取值集中到0附近，如果使用sigmoid激活函数时，这个取值区间刚好是接近线性变换区间，从而减弱了神经网络非线性变换的性质。<strong>因此，为了使归一化操作不对网络的表示能力造成负面影响，可以通过一个附加的缩放和平移变换改变取值区间</strong>。<br>$\hat{\mathbf{z}}^{(l)}=\frac{\mathbf{z}^{(l)}-\mu<em>{\mathcal{B}}}{\sqrt{\sigma</em>{\mathcal{B}}^{2}+\epsilon}} \odot \gamma+\beta\triangleq \mathrm{BN}<em>{\gamma, \beta}\left(\mathbf{z}^{(l)}\right)$<br>其中，$\gamma$、$\beta$分别表示缩放和平移的参数向量。<strong>从最保守的角度考虑，可以通过标准归一化的逆变换来使得归一化的变量可以被还原为原来的值</strong>。即：当$\gamma=\sqrt{\sigma</em>{\mathcal{B}}^{2}}$，$\beta=\mu_{\mathcal{B}}$时，$\hat{\mathbf{z}}^{(l)}=\mathbf{z}^{(l)}$。</li><li>批量归一化操作可以看作是一个特殊的神经网络层，<strong>该层是加在每一层非线性激活函数之前</strong>，即：<script type="math/tex; mode=display">\mathbf{a}^{(l)}=f\left(\mathbf{B} \mathbf{N}_{\gamma, \beta}\left(\mathbf{z}^{(l)}\right)\right)=f\left(\mathbf{B} \mathbf{N}_{\gamma, \beta}\left(W \mathbf{a}^{(l-1)}\right)\right)</script>其中，因为批量归一化本身具有平移变换，因此非线性变换$W \mathbf{a}^{(l-1)}$就不再需要偏置参数b。</li><li><strong>注意</strong>：每次小批量样本的$\mu<em>{\mathcal{B}}$和$\sigma</em>{\mathcal{B}}^{2}$是净输入$\mathbf{z}^{(l)}$的函数，而不是常量。因此，在计算参数梯度时，需要考虑$\mu<em>{\mathcal{B}}$和$\sigma</em>{\mathcal{B}}^{2}$的影响。当训练完成时，用整个数据集上的均值$\mu$和方差$\sigma^{2}$来分别替代每次小批量样本的$\mu<em>{\mathcal{B}}$和$\sigma</em>{\mathcal{B}}^{2}$。在实际中，$\mu<em>{\mathcal{B}}$和$\sigma</em>{\mathcal{B}}^{2}$也可以使用移动平均来计算。</li></ul></li></ul><h4 id="2-参考资料"><a href="#2-参考资料" class="headerlink" title="2.参考资料"></a>2.参考资料</h4><ul><li><a href="https://nndl.github.io/" target="_blank" rel="noopener">邱锡鹏：《神经网络与深度学习》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0.概述&quot;&gt;&lt;/a&gt;0.概述&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;深层神经网络存在的问题(从当前层的输入的分布来分析)&lt;/strong&gt;：在深层神经网络中，中间层
      
    
    </summary>
    
      <category term="深度学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常见的数据预处理方法总结</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/常见的数据预处理方法总结/</id>
    <published>2019-07-29T10:50:47.000Z</published>
    <updated>2019-07-29T11:07:49.330Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h4><ul><li>一般而言，样本的原始特征中的每一维特征由于来源以及度量单位不同，其特征取值的分布范围往往差异很大。当我们计算不同样本之间的欧氏距离时，取值范围大的特征会起到主导作用。这样，对于基于相似度比较的机器学习方法（比如最近邻分类器KNN），必须先对样本进行预处理，将各个维度的特征归一化到同一个取值区间，并且消除不同特征之间的相关性，才能获得比较理想的结果。虽然神经网络可以通过参数的调整来适应不同特征的取值范围，但是会导致训练效率比较低。</li><li>假设一个只有一层的网络 $y=\tanh \left(w<em>{1} x</em>{1}+w<em>{2} x</em>{2}+b\right)$，其中$x<em>{1} \in[0,10]$，$x</em>{2} \in[0,1]$。因为tanh函数的导数在区间 [−2, 2]上是敏感的，其余地方的导数接近于 0。因此，如果 $w<em>{1} x</em>{1}+w<em>{2} x</em>{2}+b$过大或过小，都会导致梯度过小，难以训练。为了提高训练效率，我们需要使$w<em>{1} x</em>{1}+w<em>{2} x</em>{2}+b$在 [−2, 2]区间，我们需要将w1设得小一点，比如在 [−0.1,0.1]之间。可以想象，如果数据维数很多时，我们很难这样精心去选择每一个参数。因此，如果每一个特征的取值范围都在相似的区间，比如 [0, 1]或者 [−1, 1]，我们就不太需要区别对待每一个参数，减少人工干预。</li><li>当不同输入特征的取值范围差异比较大时，梯度下降法的效率也会受到影响。下图给出了数据归一化对梯度的影响。其中，图a为未归一化数据的等高线图。取值范围不同会造成在大多数位置上的梯度方向并不是最优的搜索方向。当使用梯度下降法寻求最优解时，会导致需要很多次迭代才能收敛。如果我们把数据归一化为取值范围相同，如图b所示，大部分位置的梯度方向近似于最优搜索方向。这样，在梯度下降求解时，每一步梯度的方向都基本指向最小值，训练效率会大大提高。<br>  <img src="https://upload-images.jianshu.io/upload_images/13407176-8d338f7c89713b24?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="数据归一化对梯度的影响"></li></ul><h4 id="1-常用的归一化方法"><a href="#1-常用的归一化方法" class="headerlink" title="1.常用的归一化方法"></a>1.常用的归一化方法</h4><ul><li><strong>1.1 缩放归一化</strong>：通过缩放将每一个特征的取值范围归一到 [0, 1]或 [−1, 1]之间。假设有 N 个样本$\left{\mathbf{x}^{(n)}\right}_{n=1}^{N}$，对每一维特征x，<script type="math/tex; mode=display">\hat{x}^{(n)}=\frac{x^{(n)}-\min _{n}\left(x^{(n)}\right)}{\max _{n}\left(x^{(n)}\right)-\min _{n}\left(x^{(n)}\right)}</script>其中，min(x)和max(x)分别是特征x在所有样本上的最小值和最大值。</li><li><strong>1.2 标准归一化</strong>：将每一个维特征都处理为符合标准正态分布（均值为 0，标准差为 1）。假设有 N 个样本$\left{\mathbf{x}^{(n)}\right}_{n=1}^{N}$，对每一维特征x，先计算它的均值和标准差：<script type="math/tex; mode=display">\begin{aligned} \mu &=\frac{1}{N} \sum_{n=1}^{N} x^{(n)} \\ \sigma^{2} &=\frac{1}{N} \sum_{n=1}^{N}\left(x^{(n)}-\mu\right)^{2} \end{aligned}</script>然后，将特征$x^{(n)}$减去均值，并除以标准差，得到新的特征$\hat{x}^{(n)}$。<script type="math/tex; mode=display">\hat{x}^{(n)}=\frac{x^{(n)}-\mu}{\sigma}</script>这里$\sigma$不能为0，如果标准差为0，则说明这一维度的特征没有任务的区分性，可以直接删除。<strong>在标准归一化之后，每一维特征都服从标准正态分布。</strong></li><li><strong>1.3 白化</strong>：是一种重要的预处理方法，用来降低输入数据特征之间的冗余性。输入数据经过白化处理后，特征之间相关性较低，并且所有特征具有相同的方差。白化的一个主要实现方式是使用主成分分析PCA方法去除掉各个成分之间的相关性。<br>  <img src="https://upload-images.jianshu.io/upload_images/13407176-ef01f35e035469f9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="标准归一化与PCA白化对比"></li></ul><h4 id="2-参考资料"><a href="#2-参考资料" class="headerlink" title="2. 参考资料"></a>2. 参考资料</h4><ul><li><a href="https://nndl.github.io/" target="_blank" rel="noopener">邱锡鹏：《神经网络与深度学习》</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0.概述&quot;&gt;&lt;/a&gt;0.概述&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;一般而言，样本的原始特征中的每一维特征由于来源以及度量单位不同，其特征取值的分布范围往往差异很大。当我们计算不同
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习02统计学习方法(感知机perceptron machine)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A002%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%84%9F%E7%9F%A5%E6%9C%BAperceptron-machine-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习02统计学习方法-感知机perceptron-machine-图片版/</id>
    <published>2019-07-29T10:48:41.000Z</published>
    <updated>2019-07-29T11:07:36.241Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-2a3396fbb18b0018.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-2a3396fbb18b0018.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习01统计学习方法概论(机器学习中的重要概念)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A001%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%AE%BA-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习01统计学习方法概论-机器学习中的重要概念-图片版/</id>
    <published>2019-07-29T10:46:17.000Z</published>
    <updated>2019-07-29T11:08:01.053Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-f39bf23781f1aac2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-fa87d164d7048479?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-f39bf23781f1aac2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; al
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据库中的基本概念</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://cdlwhm1217096231.github.io/数据库/数据库中的基本概念/</id>
    <published>2019-07-28T06:50:37.000Z</published>
    <updated>2019-07-28T04:05:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h4><!-- 文字增加背景色块 --><!-- <span id="inline-blue"> 站点配置文件 </span><span id="inline-purple"> 主题配置文件 </span><span id="inline-yellow"> 站点配置文件 </span><span id="inline-green"> 主题配置文件 </span> --><!-- 下载样式--><!-- <a id="download" href="https://git-scm.com/download/win"><i class="fa fa-download"></i><span> Download Now</span> </a> --><!-- 文档中增加图标 --><!-- <i class="fa fa-pencil"></i>支持Markdown --><ul><li>数据（data）：描述事物的符号记录称为数据</li><li>数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点。</li><li><strong>数据库管理系统</strong>（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。</li><li>数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。</li><li><strong>实体</strong>（entity）：客观存在并可相互区别的事物称为实体。</li><li><strong>属性</strong>（attribute）：实体所具有的某一特性称为属性。</li><li>码（key）：唯一标识实体的属性集称为码。</li><li><strong>实体型</strong>（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</li><li><strong>实体集</strong>（entity set）：同一实体型的集合称为实体集。</li><li><strong>联系</strong>（relationship）：实体之间的联系通常是指不同实体集之间的联系。</li><li><strong>模式</strong>（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</li><li><strong>外模式</strong>（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</li><li><strong>内模式</strong>（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。<h4 id="2-常用数据模型"><a href="#2-常用数据模型" class="headerlink" title="2.常用数据模型"></a>2.常用数据模型</h4></li><li>层次模型（hierarchical model）</li><li>网状模型（network model）</li><li><strong>关系模型</strong>（relational model）<ul><li>关系（relation）：一个关系对应通常说的一张表</li><li>元组（tuple）：表中的一行即为一个元组</li><li>属性（attribute）：表中的一列即为一个属性</li><li>码（key）：表中可以唯一确定一个元组的某个属性组</li><li>域（domain）：一组具有相同数据类型的值的集合</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述，一般表示为 关系名(属性1, 属性2, …, 属性n)</li></ul></li><li>面向对象数据模型（object oriented data model）</li><li>对象关系数据模型（object relational data model）</li><li>半结构化数据模型（semistructure data model）<h4 id="3-常用SQL操作"><a href="#3-常用SQL操作" class="headerlink" title="3.常用SQL操作"></a>3.常用SQL操作</h4><img src="https://upload-images.jianshu.io/upload_images/13407176-05998a954f653817?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常用SQL操作"></li><li>更多操作请参见<a href="https://blog.csdn.net/cdlwhm1217096231/article/details/88548483" target="_blank" rel="noopener">我之前总结的数据库基本操作</a><h4 id="4-关系型数据库"><a href="#4-关系型数据库" class="headerlink" title="4.关系型数据库"></a>4.关系型数据库</h4></li><li>基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改</li><li><strong>关系模型中的三类完整性约束</strong>：实体完整性、参照完整性、用户定义的完整性<h4 id="5-索引"><a href="#5-索引" class="headerlink" title="5.索引"></a>5.索引</h4></li><li>数据库索引：顺序索引、B+ 树索引、hash 索引</li><li>更多信息: <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL 索引背后的数据结构及算法原理</a><h4 id="6-数据库完整性"><a href="#6-数据库完整性" class="headerlink" title="6.数据库完整性"></a>6.数据库完整性</h4></li><li>数据库的完整性是指数据的正确性和相容性。<ul><li>完整性：为了防止数据库中存在不符合语义（不正确）的数据。</li><li>安全性：为了保护数据库防止恶意破坏和非法存取。</li></ul></li><li>触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。<h4 id="7-关系数据理论"><a href="#7-关系数据理论" class="headerlink" title="7.关系数据理论"></a>7.关系数据理论</h4></li><li>数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。</li><li>最重要的数据依赖：函数依赖、多值依赖。<h4 id="8-范式"><a href="#8-范式" class="headerlink" title="8.范式"></a>8.范式</h4></li><li>第一范式（1NF）：<strong>属性（字段）是最小单位不可再分</strong>。</li><li>第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。</li><li>第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 主属性对码的传递函数依赖）。</li><li>鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。</li><li>第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。<h4 id="9-数据库恢复"><a href="#9-数据库恢复" class="headerlink" title="9.数据库恢复"></a>9.数据库恢复</h4></li><li>事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</li><li><strong>事物的 ACID 特性</strong>：原子性、一致性、隔离性、持续性。</li><li>恢复的实现技术：建立冗余数据 -&gt; 利用冗余数据实施数据库恢复。</li><li>建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。<h4 id="10-并发控制"><a href="#10-并发控制" class="headerlink" title="10.并发控制"></a>10.并发控制</h4></li><li><strong>事务是并发控制的基本单位</strong>。</li><li>并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。</li><li>并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。</li><li>基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。</li><li>活锁和死锁：<ul><li>活锁：事务永远处于等待状态，可通过先来先服务的策略避免。</li><li>死锁：事物永远不能结束<ul><li>预防：一次封锁法、顺序封锁法；</li><li>诊断：超时法、等待图法；</li><li>解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。</li></ul></li></ul></li><li>可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。<h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4></li><li><a href="https://blog.csdn.net/qq_35246620/article/details/70823903" target="_blank" rel="noopener">数据库简明教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-基本概念&quot;&gt;&lt;a href=&quot;#1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.基本概念&quot;&gt;&lt;/a&gt;1.基本概念&lt;/h4&gt;&lt;!-- 文字增加背景色块 --&gt;
&lt;!-- &lt;span id=&quot;inline-blue&quot;&gt; 站点配置文件 &lt;/s
      
    
    </summary>
    
      <category term="数据库" scheme="https://cdlwhm1217096231.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://cdlwhm1217096231.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
