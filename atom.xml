<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Curry_Coder的空间</title>
  
  <subtitle>好好学习，天天向上！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cdlwhm1217096231.github.io/"/>
  <updated>2020-03-12T03:31:20.261Z</updated>
  <id>https://cdlwhm1217096231.github.io/</id>
  
  <author>
    <name>Curry_Coder</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shell脚本编程基础</title>
    <link href="https://cdlwhm1217096231.github.io/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://cdlwhm1217096231.github.io/shell脚本编程/shell脚本编程基础/</id>
    <published>2020-03-12T03:06:14.000Z</published>
    <updated>2020-03-12T03:31:20.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="技术交流QQ群-1027579432，欢迎你的加入！"><a href="#技术交流QQ群-1027579432，欢迎你的加入！" class="headerlink" title="技术交流QQ群:1027579432，欢迎你的加入！"></a>技术交流QQ群:1027579432，欢迎你的加入！</h3><h3 id="本教程使用Linux发行版Centos7-0系统，请您注意"><a href="#本教程使用Linux发行版Centos7-0系统，请您注意" class="headerlink" title="本教程使用Linux发行版Centos7.0系统，请您注意~"></a>本教程使用Linux发行版Centos7.0系统，请您注意~</h3><h4 id="1-使用多个命令"><a href="#1-使用多个命令" class="headerlink" title="1.使用多个命令"></a>1.使用多个命令</h4><ul><li><p>shell脚本的关键之处在于输入多个命令并处理每个命令的结果，甚至需要将一个命令的结果传给另一个命令。shell可以让多个命令串起来，一次执行。<strong>如果要两个命令一起运行，可以将它们放在同一行，之间用逗号隔开</strong>。</p>  <figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[njust@njust tutorials]$ date;who</span><br><span class="line">2020年 03月 11日 星期三 22:39:16 CST</span><br><span class="line">njust    :0           2020<span class="string">-03</span><span class="string">-11</span> 22:28 (:0)</span><br><span class="line">njust    pts/0        2020<span class="string">-03</span><span class="string">-11</span> 22:35 (192.168.0.107)</span><br></pre></td></tr></table></figure></li><li><p>上述方法的缺点：使用上述方法可以将任意多个命令串联在一起使用，最大命令行字符数不超过255个。对小型的脚本适用，当有很多脚本时，直接在命令行中输入整个命令就很麻烦。</p></li></ul><h4 id="2-创建shell脚本文件"><a href="#2-创建shell脚本文件" class="headerlink" title="2.创建shell脚本文件"></a>2.创建shell脚本文件</h4><ul><li><p>创建shell脚本文件时，<strong>必须在文件的第一行指定使用的shell是哪种类型</strong>，格式为：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure></li><li><p>shell脚本中注释一般以#开头，shell脚本不会处理注释的行。但是，shell脚本的第一行是例外。<strong>#后的!会告诉shell用哪个shell来运行脚本</strong>，shell会根据命令在文件中出现的先后顺序进行处理。下面是创建脚本名为demo的文件。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">date</span><br><span class="line">who</span><br></pre></td></tr></table></figure></li><li><p>存在的问题：如何让bash shell找到你创建的脚本文件？shell会通过PATH环境变量来查找命令。PATH环境变量被设置成只在一组目录中查找命令。</p>  <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[njust<span class="meta">@njust</span> tutorials]$ echo $PATH</span><br><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin:/</span>usr<span class="regexp">/bin:/</span>usr<span class="regexp">/local/</span><span class="string">sbin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/home/</span>njust<span class="regexp">/.local/</span><span class="string">bin:</span><span class="regexp">/home/</span>njust/bin</span><br></pre></td></tr></table></figure></li><li><p>解决方法：让shell找到脚本文件，有两个方法：</p><ul><li>将shell脚本文件所处的目录添加到PATH环境变量中；</li><li>在命令行中使用绝对或相对的路径来引用shell脚本文件（常用）；</li></ul></li><li><p><strong>由于你还没有执行文件的权限，这是由于umask变量被设置为022，因此系统创建的文件只有读写权限</strong>。使用下面的命令赋予文件有可执行权限。</p>  <figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u+<span class="keyword">x</span> demo</span><br></pre></td></tr></table></figure></li><li><p>为了引用当前目录下的文件，可以在shell中使用单点操作符.。正式执行脚本demo</p>  <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./demo</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-显示消息"><a href="#3-显示消息" class="headerlink" title="3.显示消息"></a>3.显示消息</h4><ul><li><p>在echo命令后加上一个字符串，该命令就会显示出这个文本字符串。默认情况下，不需要使用引号将需要显示的字符串包含起来。</p>  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>echo hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></li><li><p>当字符串中含有单引号或双引号时，可以使用双引号或单引号(注意叙述的顺序)包含该字符串。</p>  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[njust<span class="meta">@njust</span> tutorials]$ echo <span class="string">"Let's see if this'll work"</span></span><br><span class="line"><span class="type">Let</span><span class="symbol">'s</span> see <span class="keyword">if</span> <span class="keyword">this</span><span class="symbol">'ll</span> work</span><br></pre></td></tr></table></figure></li><li><p><strong>echo命令可以添加到shell脚本中任何需要显示额外信息的地方</strong>！</p></li><li>当需要把字符串和命令输出显示在同一行时，可以使用带参数n的echo命令，如下所示：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"The time and date are: "</span></span><br><span class="line">date</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">The time and date are: 2020年 03月 11日 星期三 23:07:03 CST</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-使用变量"><a href="#4-使用变量" class="headerlink" title="4.使用变量"></a>4.使用变量</h4><ul><li>变量可以将临时信息存储在shell脚本中，便于和shell中其他的命令一起使用。</li><li><strong>环境变量</strong>：shell维护一组环境变量，用来记录特定的系统信息。<strong>可以使用set命令来显示一份完整的当前环境变量列表</strong>。</li><li><p><strong>在脚本中，可以在环境变量名称前加上美元符号$从而来使用这些变量</strong>。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print information about logger</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"User info for userid: <span class="variable">$USER</span>"</span></span><br><span class="line"><span class="built_in">echo</span> UID: <span class="variable">$UID</span></span><br><span class="line"><span class="built_in">echo</span> HOME: <span class="variable">$HOME</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">User info <span class="keyword">for</span> userid: njust</span><br><span class="line">UID: 1000</span><br><span class="line">HOME: /home/njust</span><br></pre></td></tr></table></figure></li><li><p>注意：echo命令中的环境变量会在脚本运行时替换成当前值，只要脚本在引号中出现美元符，它就会以为你在引用一个变量，因此在表示真实美元的含义时，需要在$符号前加\转义字符。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"The cost of the item is \$5."</span></span><br></pre></td></tr></table></figure></li><li><p>此外，还可以通过${变量名}的形式引用变量，变量名两侧的{}通常用于帮助识别美元符后的变量名。</p></li><li><strong>用户变量</strong>：除了环境变量外，shell还允许在脚本中定义和使用自己的变量。变量名使用字母、数字或下划线组成的字符串表示，长度最长不超过20个。</li><li><p>注意：<strong>使用等号将值赋给用户自定义的变量，在变量、等号和值之间不能出现空格</strong>！！！</p>  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">var1</span>=<span class="number">23</span>  <span class="comment"># 等号左右不能出现空格！！</span></span><br><span class="line"><span class="attr">var2</span>=demo</span><br><span class="line"><span class="attr">var3</span>=testing</span><br><span class="line"><span class="attr">var4</span>=<span class="string">"hello shell"</span></span><br></pre></td></tr></table></figure></li><li><p>shell脚本会自动决定变量值的数据类型。在脚本的整个生命周期内，shell脚本定义的变量会一直存在，在shell脚本结束时会被删除。<strong>用户变量也可以通过$引用</strong>。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">days=10</span><br><span class="line">guest=<span class="string">"curry"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$guest</span> checked in <span class="variable">$days</span> days ago"</span></span><br><span class="line"></span><br><span class="line">days=5</span><br><span class="line">guest=<span class="string">"durant"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$guest</span> cheked in <span class="variable">$days</span> days ago"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">curry checked <span class="keyword">in</span> 10 days ago</span><br><span class="line">durant cheked <span class="keyword">in</span> 5 days ago</span><br></pre></td></tr></table></figure></li><li><p>变量每次引用时，都会输出当前赋给它的值。引用一个变量时需要使用美元符号$，引用一个变量var1给另一个变量var2进行赋值时，被赋值的变量不要使用$。对var1忘记使用$号，就会使var2的赋值行变成普通的字符串。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=10</span><br><span class="line">var2=<span class="variable">$var1</span>  <span class="comment"># 在赋值语句中使用var1变量的值时，必须使用$符号</span></span><br><span class="line"><span class="built_in">echo</span> The resulting value is <span class="variable">$var2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">The resulting value is 10</span><br><span class="line"></span><br><span class="line">var2=var1;  <span class="comment"># 错误的代表案例，输出结果是普通字符串</span></span><br><span class="line"><span class="built_in">echo</span> The resulting value is <span class="variable">$var2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误结果</span></span><br><span class="line">The resulting value is var1</span><br></pre></td></tr></table></figure></li><li><p><strong>命令替换</strong>：shell最有用的特性之一是从命令输出中提取出信息，并将其赋值给变量。将命令的输出赋值给变量后，就可以在脚本中使用了。有两种方法可以将命令输出赋值给变量：</p><ul><li>反引号字符`</li><li>$()格式</li></ul></li><li><p>命令替换允许你将shell命令的输出赋值给变量，具体如下所示：</p>  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">testing=`<span class="built_in">date</span>`</span><br><span class="line">test=$(<span class="built_in">date</span>)</span><br><span class="line">echo The <span class="built_in">date</span> <span class="keyword">and</span> <span class="built_in">time</span> are: $testing</span><br><span class="line">echo The <span class="built_in">date</span> <span class="keyword">and</span> <span class="built_in">time</span> are: $test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">The <span class="built_in">date</span> <span class="keyword">and</span> <span class="built_in">time</span> are: <span class="number">2020</span>年 <span class="number">03</span>月 <span class="number">12</span>日 星期四 <span class="number">09</span>:<span class="number">11</span>:<span class="number">38</span> CST</span><br><span class="line">The <span class="built_in">date</span> <span class="keyword">and</span> <span class="built_in">time</span> are: <span class="number">2020</span>年 <span class="number">03</span>月 <span class="number">12</span>日 星期四 <span class="number">09</span>:<span class="number">11</span>:<span class="number">38</span> CST</span><br></pre></td></tr></table></figure></li><li><p>实例：通过命令替换获得当前日期并用它来生成唯一的文件名。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy the /usr/bin/directory listing to a log file</span></span><br><span class="line"></span><br><span class="line">today=$(date +%y%m%d)  <span class="comment"># +%y%m%d格式是告诉date命令将日期显示为两位数的年月日数字组合</span></span><br><span class="line">ls /usr/bin -al &gt; <span class="built_in">log</span>.<span class="variable">$today</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">生成log.200312日志文件</span><br></pre></td></tr></table></figure></li><li><p>命令替换会创建一个子shell来运行对应的命令，由该子shell所执行命令是无法使用脚本中所创建的变量。在命令行中使用路径./运行命令时，也会创建子shell；在运行命令时不加入路径，就不会创建子shell。</p></li></ul><h4 id="5-重定向输入和输出"><a href="#5-重定向输入和输出" class="headerlink" title="5.重定向输入和输出"></a>5.重定向输入和输出</h4><ul><li>重定向目的：想要保存某个命令的输出而不仅仅是让结果输出在屏幕上。</li><li><p><strong>输出重定向</strong>：最基本的重定向是将命令的输出发送在一个文件中。格式如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体命令 &gt; 输出文件名</span><br></pre></td></tr></table></figure></li><li><p>实例如下：</p>  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>date &gt; test6</span><br><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>cat test6</span><br><span class="line"><span class="number">2020</span>年 <span class="number">03</span>月 <span class="number">12</span>日 星期四 09<span class="symbol">:</span><span class="number">40</span><span class="symbol">:</span>09 CST</span><br></pre></td></tr></table></figure></li><li><p><strong>如果输出文件已经存在，重定向操作符会用新的文件数据覆盖已有文件</strong>。</p>  <figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[njust@njust tutorials]$ who &gt; test6</span><br><span class="line">[njust@njust tutorials]$ cat test6</span><br><span class="line">njust    :0           2020<span class="string">-03</span><span class="string">-11</span> 22:28 (:0)</span><br><span class="line">njust    pts/0        2020<span class="string">-03</span><span class="string">-12</span> 08:39 (192.168.0.107)</span><br><span class="line">njust    pts/1        2020<span class="string">-03</span><span class="string">-12</span> 08:41 (:0)</span><br></pre></td></tr></table></figure></li><li><p>有时候，你并不想覆盖原始文件中的内容，而是想将命令的输出追加到已有文件中。<strong>这种情况下，可以用&gt;&gt;来追加数据</strong>。</p>  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[njust@njust tutorials]$ date <span class="meta">&gt;&gt; </span>test6</span><br><span class="line">[njust@njust tutorials]$ cat test6</span><br><span class="line">njust    <span class="symbol">:</span><span class="number">0</span>           <span class="number">2020</span>-<span class="number">03</span>-<span class="number">11</span> <span class="number">22</span><span class="symbol">:</span><span class="number">28</span> (<span class="symbol">:</span><span class="number">0</span>)</span><br><span class="line">njust    pts/<span class="number">0</span>        <span class="number">2020</span>-<span class="number">03</span>-<span class="number">12</span> 08<span class="symbol">:</span><span class="number">39</span> (<span class="number">192.168</span>.<span class="number">0</span>.<span class="number">107</span>)</span><br><span class="line">njust    pts/<span class="number">1</span>        <span class="number">2020</span>-<span class="number">03</span>-<span class="number">12</span> 08<span class="symbol">:</span><span class="number">41</span> (<span class="symbol">:</span><span class="number">0</span>)</span><br><span class="line"><span class="number">2020</span>年 <span class="number">03</span>月 <span class="number">12</span>日 星期四 09<span class="symbol">:</span><span class="number">43</span><span class="symbol">:</span><span class="number">41</span> CST</span><br></pre></td></tr></table></figure></li><li><p><strong>输入重定向</strong>：输入重定向将文件的内容重定向到命令，而不是将命令输出重定向到文件。输入重定向的格式：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体命令 &lt; 输入文件</span><br></pre></td></tr></table></figure></li><li><p>具体实例：wc命令可以统计文件中的数据，默认情况下会输出3个值。</p>  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>wc &lt; test6</span><br><span class="line"><span class="number">4</span>  <span class="number">21</span> <span class="number">186</span>  <span class="comment"># 从左到右分别表示文本的行数、文本的词数、文本的字节数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>内联输入重定向</strong>：&lt;&lt;无需使用文件进行重定向，只需要在命令行中指定输入重定向的数据即可。注意：<strong>必须指定一个文本标记来划分输入数据的起始和结尾。任何字符串都可以作为文本标记，但数据的起始和结尾文本标记必须一致</strong>。格式：</p>  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">具体命令 <span class="meta">&gt;&gt; </span>EOF</span><br><span class="line">data</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>在命令行中使用内联输入重定向时，shell会用PS2变量中定义的次提示符来提示用户输入数据。</p>  <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[njust@njust tutorials]$ wc &lt;&lt; <span class="literal">EOF</span></span><br><span class="line">&gt; test <span class="type">string</span> <span class="number">1</span>  # &gt;表示的就是次提示符</span><br><span class="line">&gt; test <span class="type">string</span> <span class="number">2</span></span><br><span class="line">&gt; test <span class="type">string</span> <span class="number">3</span></span><br><span class="line">&gt; <span class="literal">EOF</span></span><br><span class="line"><span class="number">3</span>  <span class="number">9</span> <span class="number">42</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="6-管道"><a href="#6-管道" class="headerlink" title="6.管道"></a>6.管道</h4><ul><li>管道的目的：一个命令的输出作为另一个命令的输入。</li><li><p>管道被放在命令之间，将一个命令的输出重定向到另一个命令中。基本格式如下：</p>  <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令<span class="number">1</span> | 命令<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>管道串器的两个命令不是依次执行的，Linux系统实际上会同时运行这两个命令，在系统内部将它们连接起来。在第一个命令产生输出的同时，输出会被立即送个第二个命令。数据传输不会用的任何中间文件或缓冲区。</p></li><li><p>可以在一条命令中使用任意多条管道。可以持续地将命令的输出通过管道传给其他命令来细化操作。如下例所示：</p>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | <span class="built_in">sort</span> | more  <span class="comment"># 先生成已安装包的列表，再排序，最后再用more显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想更精致点，可以搭配使用重定向和管道将输出保存到文件中</span></span><br><span class="line">rpm -qa | <span class="built_in">sort</span> &gt; rpm.list</span><br></pre></td></tr></table></figure></li><li><p><strong>管道最流行的用法之一就是将产生的大量输出通过管道传给more命令，一般与ls命令结合使用</strong>。</p></li></ul><h4 id="7-执行数学运算"><a href="#7-执行数学运算" class="headerlink" title="7.执行数学运算"></a>7.执行数学运算</h4><ul><li>在shell中有两个途径进行数学运算。<ul><li>expr命令</li><li>使用方括号</li></ul></li><li><p><strong>expr命令允许在命令行中处理数学表达式，但特别笨拙</strong>。许多expr命令操作符在shell中另有含义，当它们出现在expr命令中时，会得到一些诡异的结果。对那些容易被shell错误解释的字符，需要使用转义字符。</p>  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>expr <span class="number">5</span> * <span class="number">2</span></span><br><span class="line"><span class="symbol">expr:</span> 语法错误</span><br><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>expr <span class="number">5</span> \* <span class="number">2</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>在shell脚本中expr命令也同样复杂，如下所示：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=10</span><br><span class="line">var2=20</span><br><span class="line">var3=$(expr <span class="variable">$var2</span> / <span class="variable">$var1</span>)  <span class="comment"># 要将一个数学表达式的结果赋值给一个变量var3,也需要借助命令替换。</span></span><br><span class="line"><span class="built_in">echo</span> The result is <span class="variable">$var3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">The result is 2</span><br></pre></td></tr></table></figure></li><li><p><strong>在bash中，在将一个数学运算结果赋给一个变量时，可以使用美元符和[]将整个表达式圈起来</strong>。</p>  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>var1=<span class="variable">$[</span><span class="number">1</span>+<span class="number">34</span>]</span><br><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>echo <span class="variable">$var1</span></span><br><span class="line"><span class="number">35</span></span><br></pre></td></tr></table></figure></li><li><p>用方括号执行shell运算比用expr命令方便很多，在shell脚本中也能看出。</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">var1</span>=10</span><br><span class="line"><span class="attribute">var2</span>=20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">var3</span>=`expr <span class="variable">$var2</span> / <span class="variable">$var1</span>`</span><br><span class="line">echo the result is <span class="variable">$var3</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">var1</span>=100</span><br><span class="line"><span class="attribute">var2</span>=200</span><br><span class="line"><span class="attribute">var3</span>=45</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">var4</span>=$[<span class="variable">$var1</span> * (<span class="variable">$var3</span> - <span class="variable">$var2</span>)]</span><br><span class="line">echo final result is <span class="variable">$var4</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">the result is 2</span><br><span class="line">final result is -15500</span><br></pre></td></tr></table></figure></li><li><p><strong>bash shell数学运算符只支持整数运算</strong>，这是一个巨大的限制。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=100</span><br><span class="line">var2=45</span><br><span class="line">var3=$[<span class="variable">$var1</span> / <span class="variable">$var2</span>]</span><br><span class="line"><span class="built_in">echo</span> The final result is <span class="variable">$var3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">The final result is 2</span><br></pre></td></tr></table></figure></li><li><p>浮点数运算的解决方案：使用内建的bash计算器bc。bash计算器允许在命令行中输入浮点表达式，然后解释并计算该表达式，返回结果。</p></li><li><p>浮动运算是由内建变量scale控制的，这个值设置为你需要保留的小数点后几位。</p>  <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[njust@njust ~]$ bc -q  # -q参数表示不显示欢迎信息</span><br><span class="line"><span class="number">3.44</span> /<span class="number">5</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">scale=<span class="number">4</span></span><br><span class="line"><span class="number">3.44</span> / <span class="number">5</span></span><br><span class="line"><span class="number">.6880</span></span><br><span class="line">quit</span><br></pre></td></tr></table></figure></li><li><p>bash计算器还支持变量，如下所示：</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bc -q</span><br><span class="line"><span class="attribute">var1</span>=10</span><br><span class="line">var1<span class="number">*4</span></span><br><span class="line">40</span><br><span class="line"><span class="attribute">var2</span>=var1 / 5</span><br><span class="line"><span class="builtin-name">print</span> var2</span><br><span class="line">2</span><br><span class="line">quit</span><br></pre></td></tr></table></figure></li><li><p><strong>在脚本中使用bc</strong>：可以使用命令替换运行bc命令，并将输出赋值给一个变量，基本格式如下：</p>  <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量名=$(echo <span class="string">"可选项; 表达式"</span> <span class="string">| bc)</span></span><br></pre></td></tr></table></figure></li><li><p>实例：在脚本中使用bc，如下所示。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=$(<span class="built_in">echo</span> <span class="string">"scale=4; 3.44/5"</span> | bc)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var1</span></span><br><span class="line">.6880</span><br></pre></td></tr></table></figure></li><li><p>上述方法适用于较短的运算，但有时候涉及更多的数字。需要进行大量的运算，在一个命令行中列出多个表达式就会麻烦。解决方法：使用内联输入重定向，它允许你直接在命令行中重定向数据。基本格式为：</p>  <figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">变量名=$(bc &lt;&lt; <span class="built_in">EOF</span></span><br><span class="line">可选项</span><br><span class="line">语句</span><br><span class="line">表达式</span><br><span class="line"><span class="built_in">EOF</span>)</span><br></pre></td></tr></table></figure></li><li><p>在bash计算器中创建的变量只在bash计算器中有效，不能在shell脚本中使用。</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attribute">var1</span>=10.46</span><br><span class="line"><span class="attribute">var2</span>=43.67</span><br><span class="line"><span class="attribute">var3</span>=33.2</span><br><span class="line"><span class="attribute">var4</span>=71</span><br><span class="line"></span><br><span class="line"><span class="attribute">var5</span>=$(bc &lt;&lt; EOF</span><br><span class="line"><span class="attribute">scale</span>=4</span><br><span class="line">a1 = (<span class="variable">$var1</span> * <span class="variable">$var2</span>)</span><br><span class="line">b1 = (<span class="variable">$var3</span> * <span class="variable">$var4</span>)</span><br><span class="line">a1 + b1</span><br><span class="line">EOF</span><br><span class="line">)</span><br><span class="line">echo final result is <span class="variable">$var5</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">final result is 2813.9882</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-退出脚本"><a href="#8-退出脚本" class="headerlink" title="8.退出脚本"></a>8.退出脚本</h4><ul><li><p>shell中运行的每个命令都使用退出状态码，shell告诉它已经运行完毕。退出状态码是一个0到255的整数值，在命令结束时由命令传给shell，可以捕捉这个值在脚本中使用。<strong>Linux专门提供了变量$?来保存上一个已执行命令的退出状态码</strong>。对于需要进行检查的命令，必须在其运行完毕后立即查看或使用$?变量。</p>  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>date</span><br><span class="line"><span class="number">2020</span>年 <span class="number">03</span>月 <span class="number">12</span>日 星期四 <span class="number">10</span><span class="symbol">:</span><span class="number">39</span><span class="symbol">:</span><span class="number">19</span> CST</span><br><span class="line">[njust<span class="variable">@njust</span> tutorials]<span class="variable">$ </span>echo <span class="variable">$?</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>Linux退出状态码如下：</p>  <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>          命令成功结束</span><br><span class="line"><span class="symbol">1 </span>          一般性未知错误</span><br><span class="line"><span class="symbol">2 </span>          不适合的<span class="keyword">shell</span>命令</span><br><span class="line"><span class="symbol">126 </span>        命令不可执行</span><br><span class="line"><span class="symbol">127 </span>        没找到命令</span><br><span class="line"><span class="symbol">128 </span>        无效的退出参数</span><br><span class="line"><span class="symbol">130 </span>        通过CTRL+C终止的命令</span><br></pre></td></tr></table></figure></li><li><p>exit命令：默认情况下，shell脚本会以脚本中最后一个命令的退出状态码退出。<strong>用户可以改变这种默认行为，返回自己的状态码。eixt命令允许在脚本结束时指定一个退出状态码</strong>。</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">var1=<span class="number">10</span></span><br><span class="line">var2=<span class="number">30</span></span><br><span class="line">var3=$[<span class="variable">$var1</span> + <span class="variable">$var2</span>]</span><br><span class="line">echo The answer is <span class="variable">$var3</span></span><br><span class="line"><span class="keyword">exit</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">The answer is <span class="number">40</span></span><br><span class="line">echo $?</span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以在exit命令的参数中使用变量</span></span><br><span class="line"><span class="keyword">exit</span> <span class="variable">$var3</span></span><br><span class="line"></span><br><span class="line">echo $?</span><br><span class="line"><span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：退出状态码最大为255，超过最大的255后，会通过取模运算得到最后的结果即实际值 % 256 = 最结果</span></span><br><span class="line">var1=<span class="number">10</span></span><br><span class="line">var2=<span class="number">30</span></span><br><span class="line">var3=$[<span class="variable">$var1</span> * <span class="variable">$var2</span>]</span><br><span class="line">echo The answer is <span class="variable">$var3</span></span><br><span class="line"><span class="keyword">exit</span> <span class="variable">$var3</span></span><br><span class="line"></span><br><span class="line">echo $?</span><br><span class="line"><span class="number">44</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="9-资料下载"><a href="#9-资料下载" class="headerlink" title="9.资料下载"></a>9.资料下载</h4><ul><li><a href="https://github.com/cdlwhm1217096231/Linux/tree/master/Shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">笔记，欢迎star,follow,fork……</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;技术交流QQ群-1027579432，欢迎你的加入！&quot;&gt;&lt;a href=&quot;#技术交流QQ群-1027579432，欢迎你的加入！&quot; class=&quot;headerlink&quot; title=&quot;技术交流QQ群:1027579432，欢迎你的加入！&quot;&gt;&lt;/a&gt;技术交流QQ群:
      
    
    </summary>
    
      <category term="shell脚本编程" scheme="https://cdlwhm1217096231.github.io/categories/shell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="https://cdlwhm1217096231.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>2020个人Flag已立，欢迎监督！</title>
    <link href="https://cdlwhm1217096231.github.io/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/2020%E4%B8%AA%E4%BA%BAFlag%E5%B7%B2%E7%AB%8B%EF%BC%8C%E6%AC%A2%E8%BF%8E%E7%9B%91%E7%9D%A3%EF%BC%81/"/>
    <id>https://cdlwhm1217096231.github.io/生活感悟/2020个人Flag已立，欢迎监督！/</id>
    <published>2020-03-11T04:11:13.000Z</published>
    <updated>2020-03-12T03:30:32.139Z</updated>
    
    <content type="html"><![CDATA[<h3 id="技术交流QQ群-1027579432，欢迎你的加入！"><a href="#技术交流QQ群-1027579432，欢迎你的加入！" class="headerlink" title="技术交流QQ群:1027579432，欢迎你的加入！"></a>技术交流QQ群:1027579432，欢迎你的加入！</h3><p><img src="https://upload-images.jianshu.io/upload_images/13407176-5dedc361efb3f6cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="个人Flag.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;技术交流QQ群-1027579432，欢迎你的加入！&quot;&gt;&lt;a href=&quot;#技术交流QQ群-1027579432，欢迎你的加入！&quot; class=&quot;headerlink&quot; title=&quot;技术交流QQ群:1027579432，欢迎你的加入！&quot;&gt;&lt;/a&gt;技术交流QQ群:
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://cdlwhm1217096231.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="随笔" scheme="https://cdlwhm1217096231.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>2020届秋招个人总结</title>
    <link href="https://cdlwhm1217096231.github.io/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/2020%E5%B1%8A%E7%A7%8B%E6%8B%9B%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/生活感悟/2020届秋招个人总结/</id>
    <published>2020-03-11T04:08:05.000Z</published>
    <updated>2020-03-11T04:12:04.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="技术交流QQ群-1027579432，欢迎你的加入！"><a href="#技术交流QQ群-1027579432，欢迎你的加入！" class="headerlink" title="技术交流QQ群:1027579432，欢迎你的加入！"></a>技术交流QQ群:1027579432，欢迎你的加入！</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>本人2020届，非科班211硕士，本科普通二本。同时，也是2020届秋招大军中的一员，由于我是毕业后辞职考研上岸的，因此个人年龄比其他同届毕业生大2到3岁，所以年龄在找工作中其实也是一个劣势。秋招经历了漫长的接近4个月煎熬，终于上岸了。下面将个人面试及相关感受记录分享下来，希望对有缘人有所帮助。</li></ul><h3 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h3><ul><li><strong>秋招准备开始阶段</strong><ul><li>我的秋招其实从3月份就开始了，那时候听取了实验室师兄的建议。尽早的就开始复习数据结构、C++ Prime、剑指offer、计算机网络(第六版)、MySQL数据库、Linux常用的指令、操作系统、Git、机器学习算法和NLP相关的模型(<strong>由于前期没想过找软件开发类的工作，一心想找算法岗。事实狠狠地打了我的脸，因此才让我认识到自己是一个大菜鸡</strong>)。这种状态一直持续到6月份，这个过程中自己也会写一些技术博客记录自己学习的知识点，由于自己是非计算机专业的，我知道自己需要补更多的计算机方面的知识。于是，我反复的看大话数据结构，也会写一些排序算法的程序。但是，由于前期没有意识到<strong>leetcode</strong>的重要性，一遇到难的编程题就不想做，所以编程能力很菜！（<strong>所以，一定要提前刷题，你会问不会咋办，我推荐我学习的一个网站，不是打广告！</strong>）学习C++语言的小伙伴可以<a href="https://www.acwing.com/solution/leetcode/" target="_blank" rel="noopener">点击此处有惊喜</a>。因此，对于后面参加秋招的小伙伴，如果自己没有质量好的论文、大厂实习、含金量高的比赛，不建议找算法岗，没有任何竞争力的！今年，算法岗已经是诸神黄昏了，后面只会更难（<strong>大神可以自行忽略</strong>）。建议尽早的转软件开发岗！前期需要准备的工作如下：<ul><li>LeetCode前200道必做！</li><li>剑指offer多刷几遍，自己看到题目就会写出程序的程度</li><li>数据结构、C++/Java编程语言基础、操作系统、数据库、Linux常用指令、计算机网络、Git、常见的机器学习算法(保险起见)！</li></ul></li></ul></li><li><strong>秋招笔试、面试阶段</strong><ul><li>时间到了7月份了，一些公司的提前批陆续已经开始了。比如中兴、顺丰、vivo、oppo、浦发银行、流利说、科大讯飞、同程艺龙等。至于提前批要不要投，提前批会不会对正式批有影响。大部分公司是有影响的，所以建议对于vivo、oppo这样的公司看本硕学历的，建议不要投提前批；对于中兴、浦发银行等一定要投提前批，一方面是由于这类公司的招聘流程很长，建议早投，太迟了就没hc了。校招投简历可以<a href="https://www.haitou.cc/" target="_blank" rel="noopener">点击此处有惊喜</a>，还有一些51job、智联招聘、<strong>你意向公司的官网</strong>等。然后8月份各大公司的正式批也开始了如中国农业银行总行、中国邮政、电信云、华为、天翼智慧家庭等。这些公司的正式批会有好几批组织的笔试和面试，尽量早投尽早参加笔试，后面可能没hc了，只是公司为了刷kpi，不招人的。下面我将我有幸进面试的公司面经分享如下：<ul><li>中兴ZTE：中兴我参加的是提前批，不用参加笔试。其实，中兴正式批的笔试也很水，基本都能进面试。因为后面会有很多人违约三方，因此中兴也会大量招人。中兴面试有点水，总共两面。一面是技术面（2对1）：我前期由于面的算法岗，因此就问问项目、比赛、梯度下降算法原理等，软开岗位的话听我同学说问问排序算法、进程与线程的区别、TCP/IP这些不过都不深，不会撕代码，顶多让你说下思路。二面是hr面(2对1)：就是聊聊项目、家庭情况、个人情况、就业地点、职业方向等，很水的。中兴基本面试都能过，那么你会问他怎么招人？中兴其实是<strong>更偏爱招男生，这里不是性别歧视的意思</strong>！因为，中兴是通信公司，开发岗位居多。加班的话1 2 4加班到晚上8点半吧，周六加班半天，性价比还可以的。面试过了的话，等很长时间会收到相应部门捞你的短信或者电话，通知你去现场洽谈，今年工资的白菜价应该是13*12,第一年没年终奖。总结<strong>中兴还是看学校、论文、成绩、比赛等给工资，不看个人开发能力</strong>，因此我拒绝了。</li><li>浦发银行合肥研发中心：浦发银行其实我非常想进，可惜面试被刷了。由于报的提前批，提前批凉凉了就没正式批的机会了。先是笔试，提前批的笔试考的是行测、英语、计算机基础知识，题目量大都是选择题，一般都能过。接着过几天会收到面试的通知，面试各个城市开始时间不同。面试分为现场上机编程和面试。上机撕代码都是不难的题目，leetcode简单和剑指offer上的题目，三道题目50分钟完成。上机完成后，进行面试过程。面试是7对1好像是，先自我介绍，再看你的成绩单，然后问一些C++/Java基础知识，<strong>数据库很重要，他们喜欢问数据库的知识</strong>，现场最后再口述一道编程题，只说思路就好！面试结束就可以离开了。如果8月份面试过了，11月份左右会收到邮件通知，通知你去体检，<strong>总的来说周期较长</strong>！工资待遇听我别的教研室同学说很好，合肥的话大概24*9600，喜欢稳定的同学可以去银行！</li><li>中国邮政研发中心：中国邮政是先组织考生去某个地点统一笔试，笔试考行测、计算机基础知识、邮政行情、性格测试。由于没有最后是性格测试，我瞎选了一通，结果笔试挂了。<strong>因此，大家一定要重视性格测试</strong>！不过，邮政集团的效率很慢，比浦发银行和农业银行总行都等的久。</li><li>农业银行总行：农行也是先组织考生去某个大学统一笔试，这个笔试是分批次的。先投的人先笔试和面试。笔试也是行测和计算机基础知识、最后性格测试，都是选择题。笔试过了，会通知你面试。面试的话先去现场手撕一道编程题，题目不难是leetcode简单级别和剑指offer上的题目。然后等面试，面试是群面。好像是8对10，每个人逐一介绍自己，然后面试官会根据你的简历来问你问题。对你感兴趣的话，会多问你一些。<strong>主要还是看本硕学历、相关实习经历、论文和成绩</strong>，由于本科二本没啥竞争力，面试凉凉。面试通过的同学等一段时候后会收到体检的通知，体检基本没问题，然后就上岸了。</li><li>华为：由于喜欢华为的企业文化，8月份投了软件开发岗位的志愿，9月安排笔试，笔试三道题目。题目不难，写成一道题目就可以进入面试。10月份才安排面试，<strong>从今年开始，华为面试就有三轮，前两轮面试会现场手撕代码，最后一名是总监面，我倒在了二面，面试又凉了一家</strong>。</li><li>江苏移动和移动设计院：这两家的面试的是无领导小组讨论，先是9月份面的移动设计院，再是11月初面的江苏移动。移动下的子公司的面试形式不太一样，像苏小研是技术面试，然后面试过了会通知你笔试好好准备，笔试过了基本就上岸了。笔试由移动集团在11月初全国统一组织考试；</li><li>zoom：zoom是我9月20几号面的，笔试做的很难，居然进了面试。和面试官约的是视频面试，由于C++深层的知识没有准备好，基础问题答上来了，C++更深层的知识不牢固，一面面试凉了。</li><li>新华三：新华三是10月12号左右来我们学校宣讲的，我也参加了。然后第二天安排的现场的笔试。笔试考了C/Java、操作系统、行测类型的选择题，还有两道编程题。笔试过了的话，会过几天通知你去某个酒店面试。面试分三轮，一天结束。一面是技术面问的知识很广，但是不难。从编程语言到计算机网络、操作系统，还有口述一道编程题的思路、还有笔试试卷上的题目。<strong>每面都会刷人，hr如果通知你可以直接回去了说明你凉凉了。二面是hr面，hr面也挂人，主要测试你的性格</strong>。三面是总监面，问项目和自己的实习和研究课题，也会问一些简单的技术问题。三面结束后就可以回去等通知了，华三每个城市的研发中心招聘结束后，总部进行技术岗位的汇总全国排序后再统一发offer，<strong>技术岗开奖的时间很久，我大概等了20多天。别的城市宣讲早的，等的时间更长</strong>。建议有别的offer的小伙伴可以等等，像我这样的0 offer的等的风险很大，凉凉就啥也没捞到了，等待的过程中压力会很大，晚上会失眠。还好，最终等到了。<strong>建议非全的小伙伴投华三要谨慎，新华三不收非全日制的好像</strong>。</li><li>南京信息技术研究院：这个研究院好像工资待遇非常好，不过是保密单位。在里面工作时是限制出国的，离职三年内也不能出国。研究院当然也是看学历的，由于来我们学校宣讲的，我是抱着试试的心态投的。宣讲完结束后，大概20天左右吧短信通知你去它们研究院现场笔试。报的人简直太多了，队排的很长！笔试是所有的研发岗一张卷子，因此考的题目很杂，例如：C++比Java考的多、计算机网络、大数据、机器学习、TensorFlow、操作系统、英语短文翻译等，总共两个小时。笔试结束后等通知，一般三天左右通知你去现场面试。由于我知道自己本科学校不行，面试我就没去，现在想想还是有些后悔。</li><li>银联商务公司：这家公司我是在学校就业网站上看的，网申后会统一一个时间在网上进行笔试，笔试的题目很简单，基本不刷人。笔试过了，当天晚上就会通知你第二天去某酒店去面试。同样的，我的本科学校不行，不太自信我也放弃了这家公司的面试。<strong>不过，这家公司今年有点坑，随便找个你性格测试有问题的理由单方面毁了意向书，随便打发了已经拿到这家公司offer的同学，真的是个坑啊</strong>！</li><li>联发科技：我错过了联发科技秋招的黄金时期，10月20几号联发科技到我们学校来宣讲的，感觉是最后一站了。宣讲会结束后，进行笔试。笔试题不难，技术开发岗就C语言，考的题目不难，编程题链表考的比较多。笔试过了，第二天会通知你去某个酒店面试。由于hr说软件开发岗的offer没了，问我愿不愿意转数字IC芯片岗，我觉得岗位不太适合，拒绝了。所以，<strong>对自己有意向的公司，一定要尽快投简历，避免错过网申的最佳时间</strong>！多看看牛客网、海投网以防错过最佳的时间，<strong>互联网相关的工作机会一般是金九银十，九月很重要</strong>！</li><li>恒生电子：恒生电子是全国最后一站了，此时我还没有offer。决定拼一把，先网上搜索恒生电子的笔试题目，<strong>重点练习了数据库的题目</strong>。恒生也是10月20几号到我们学校来宣讲的，宣讲会结束后，进行笔试。笔试考的C++/Java可选择其中一个，然后是数据库语法，还有一道编程题和算法题。最后加上行测题和性格测试。笔试完了，一般第二天会有通知，安排去当地某酒店面试。一面是群面，主要问问项目、实习和数据库等，<strong>主要是数据库和基本的排序算法</strong>。一面结束了可以回去了，等二面通知。一般是第二天通知二面，二面是hr+总监面，就问问个人情况、手上有没有其他的offer、期望薪水、笔试的一些题目。二面结束当天晚上就会有通知，过了的话就会有签约的邮件，第三天就去通知签约。由于自己没有offer在手，就去把一些个人资料交过去了，算是有个保底的。由于一直在等新华三，所以谎称三方没有下来，等下周三签约，恒生电子的工资是16*14+450*12。<strong>由于不太清楚这个公司在杭州咋样，不敢稀里糊涂的签约，违约金很高有点担心，所以拖了几天</strong>。（还好周二的时候收的的新华三的offer，运气还算好，不枉我等了好久）。</li><li>其中，还有笔试完就凉凉的公司，大华、阅文集团、一加手机、小米手机、招商银行信用卡中心、科大讯飞、步步高、携程、流利说、同程艺龙、广联达等，我猜想可能是由于我岁数有点大，同时是非科班的；一些简历直接挂了，如招银网络科技、vivo、oppo、顺丰科技等；还有一些公司测评挂了，如邮政公司、海康威视。<strong>大家一定要注意性格测试啊，真的会挂人</strong>！！！</li><li>还有一些银行，如中国工商银行、中国银行、农业银行省分行、建设银行、交通银行、民生银行、中信银行等，考的题目类型都差不多，行测+英语+计算机基础+性格测试等。<strong>中国银行题目量最大，大家注意补充能量</strong>。银行笔试完就等通知，目前已经收到的银行面试通知有农业银行省分行、中国银行、建设银行、交通银行，由于我的三方协议已经签了，所以就没有去面试了，<strong>个人感觉银行笔试应该是不刷人，基本都能进面试，面试完刷一部分人，然后差额体检再刷一部分人。有的银行还要去基层轮岗两年，各人有各人的看法吧</strong>。<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3></li></ul></li></ul></li><li>啰嗦了一大堆，感谢大家能看完，哈哈。由于自己太菜了，和大佬不能比。至于为啥我选择新华三（恒生电子给的比较高，大概多4万） ，由于考虑家里的情况，离家近些可以照顾父母。因此，没有选择恒生电子，选择回家乡发展了。<strong>最后，祝大家都能拿到自己满意的offer，生活幸福</strong>！</li></ul><h3 id="资料下载"><a href="#资料下载" class="headerlink" title="资料下载"></a>资料下载</h3><ul><li><a href="https://github.com/cdlwhm1217096231" target="_blank" rel="noopener">所有代码，欢迎star、fork</a></li><li><a href="https://www.jianshu.com/u/4645adadefec" target="_blank" rel="noopener">个人博客</a></li><li><a href="https://pan.baidu.com/s/1gVVrBtIVa4Nrwo1BL6-VIg" target="_blank" rel="noopener">软件开发校招资料合集，提取码: fg25</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;技术交流QQ群-1027579432，欢迎你的加入！&quot;&gt;&lt;a href=&quot;#技术交流QQ群-1027579432，欢迎你的加入！&quot; class=&quot;headerlink&quot; title=&quot;技术交流QQ群:1027579432，欢迎你的加入！&quot;&gt;&lt;/a&gt;技术交流QQ群:
      
    
    </summary>
    
      <category term="生活感悟" scheme="https://cdlwhm1217096231.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="随笔" scheme="https://cdlwhm1217096231.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>01移动端布局基础之流式布局</title>
    <link href="https://cdlwhm1217096231.github.io/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/01%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <id>https://cdlwhm1217096231.github.io/Web前端开发/01移动端布局基础之流式布局/</id>
    <published>2020-03-08T06:24:06.000Z</published>
    <updated>2020-03-11T04:10:36.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="技术交流QQ群-1027579432，欢迎你的加入！"><a href="#技术交流QQ群-1027579432，欢迎你的加入！" class="headerlink" title="技术交流QQ群:1027579432，欢迎你的加入！"></a>技术交流QQ群:1027579432，欢迎你的加入！</h3><h4 id="1-移动端基础"><a href="#1-移动端基础" class="headerlink" title="1.移动端基础"></a>1.移动端基础</h4><ul><li><strong>浏览器现状</strong><ul><li>PC端常见浏览器：360浏览器、谷歌浏览器、火狐浏览器、QQ浏览器、百度浏览器、搜狗浏览器、IE浏览器等。<br>移动端常见浏览器：UC浏览器、QQ浏览器、欧朋浏览器、百度手机浏览器等。</li></ul></li><li>国内的UC、QQ、百度等手机浏览器都是根据Webkit修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于安卓修改开发的一样。</li><li><strong>总结：兼容移动端主流浏览器，处理Webkit内核浏览器即可</strong>。</li><li><strong>手机屏幕现状</strong><ul><li>移动端设备屏幕尺寸非常多，碎片化严重；</li><li>Android设备有多种分辨率：480*480、480*854、720*1280、1080*1920等；</li><li>作为开发者无需关注这些分辨率，因为常用的尺寸单位是px；</li></ul></li><li><strong>常见移动端屏幕尺寸</strong><br><img src="https://upload-images.jianshu.io/upload_images/13407176-3f1ff3cf24a20445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="常见移动端屏幕尺寸.png"></li><li><strong>移动端调试方法</strong><ul><li>Chrome DevTools(谷歌浏览器)的模拟手机调试；</li><li>搭建本地web服务器，手机和服务器在一个局域网内，通过手机访问服务器；</li><li>使用外网服务器，直接IP或域名访问；</li></ul></li></ul><h4 id="2-视口"><a href="#2-视口" class="headerlink" title="2.视口"></a>2.视口</h4><ul><li>视口：<strong>浏览器显示页面内容的屏幕区域，视口可以分为布局视口、视觉视口、理想视口</strong>。</li><li><strong>布局视口layout viewport</strong><br><img src="https://upload-images.jianshu.io/upload_images/13407176-495c836b80b28244.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="布局视口.png"><ul><li>一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期PC端页面在手机上显示的问题；</li><li>IOS、Android基本都将这个视口分辨率设置为980px，所以PC上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页；</li></ul></li><li><strong>视觉视口visual viewport</strong><br><img src="https://upload-images.jianshu.io/upload_images/13407176-ad0439ed712c587c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="视觉视口.png"><ul><li>它是用户正在看到的网站的区域。注意：<strong>是网站的区域</strong>；</li><li>我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍然保持原来的宽度；</li></ul></li><li><strong>理想视口ideal viewport</strong><ul><li>为了使网站能在移动端有最理想的浏览和阅读宽度而设定；</li><li>理想视口，对设备来说，是最理论的视口尺寸；</li><li>需要手动添加meta视口标签通知浏览器操作；</li><li>meta视口标签主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，布局视口就要有多宽。</li></ul></li></ul><h4 id="3-meta视口标签"><a href="#3-meta视口标签" class="headerlink" title="3.meta视口标签"></a>3.meta视口标签</h4><ul><li>语法格式： <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta <span class="attr">name="viewport"</span> <span class="attr">content="width=device-width,</span> <span class="attr">user-scalable=no,</span> <span class="attr">initial-scale=1.0,</span> <span class="attr">maximum-scale=1.0,</span> <span class="attr">minimum-scale=1.0"&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/13407176-e6f98453e29928a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="meta视口标签属性.png"></p><ul><li>标准的viewport设置<ul><li>视口宽度和设备保持一致；</li><li>视口的默认缩放比例1.0；</li><li>不允许用户自行缩放；</li><li>最大允许的缩放比例1.0；</li><li>最小允许的缩放比例1.0；</li></ul></li></ul><h4 id="4-二倍图"><a href="#4-二倍图" class="headerlink" title="4.二倍图"></a>4.二倍图</h4><ul><li><strong>物理像素和物理像素比</strong><ul><li>物理像素指的是屏幕显示的最小颗粒，是物理中真实存在的。这是厂商在出厂时就设置好了。例如苹果手机的750*1334；</li><li>开发时的1px不是一定等于1个物理像素的；</li><li>PC端页面中，1px等于1个物理像素的，但是移动端就不尽相同；</li><li>1px能显示的物理像素点的个数，称为物理像素比或屏幕像素比；</li></ul></li></ul><h4 id="5-多倍图"><a href="#5-多倍图" class="headerlink" title="5.多倍图"></a>5.多倍图</h4><ul><li>PC端和手机端的手机屏幕/普通手机屏幕：1CSS像素=1物理像素</li><li>Retina(视网膜屏幕)是一种显示技术，可以把更多的物理像素点压缩至一块屏幕中，从而达到更高的分辨率，并提高屏幕显示的细腻程度。<br><img src="https://upload-images.jianshu.io/upload_images/13407176-29b015652de3f813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="视网膜屏幕显示技术.png"></li><li>对于一张50px*50px的图片，在手机Retina屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊；</li><li>在标准的viewport设置中，使用倍图来提高图片的质量，解决在高清设备中的模糊问题；</li><li>通常使用二倍图，因为iphone8的影响，但是现在还存在3倍图、4倍图的情况，这个根据实际开发需求；</li><li>背景图片，注意缩放问题；</li></ul><h4 id="6-背景缩放background-size"><a href="#6-背景缩放background-size" class="headerlink" title="6.背景缩放background-size"></a>6.背景缩放background-size</h4><ul><li>background-size属性规定了背景图像的尺寸；</li><li><p>语法格式：</p>  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">background</span>-<span class="built_in">size</span>: 背景图片宽度 背景图片高度;</span><br></pre></td></tr></table></figure></li><li><p>单位：长度或百分比或cover或contain；</p></li><li>cover把背景图像扩展足够大，从而使背景图像完全覆盖背景区域；</li><li>contain把背景图像扩展到最大尺寸，从而使宽度和高度完全适应内容区域；</li><li>多倍图切图cutterman<ul><li>@1*1倍图原图</li><li>@2*2倍图</li><li>@3*3倍图</li></ul></li></ul><h4 id="7-移动端开发选择"><a href="#7-移动端开发选择" class="headerlink" title="7.移动端开发选择"></a>7.移动端开发选择</h4><ul><li>a.单独制作移动端页面(主流)：通常情况下，网址域名前面加m(mobile)可以打开移动端。通过判断设备，如果是移动设备打开，则跳动<strong>移动端页面</strong>。<ul><li>京东商城手机版</li><li>淘宝触屏版</li><li>苏宁易购手机版</li></ul></li><li>b.<strong>响应式</strong>页面兼容移动端(其次)：通过判断屏幕宽度改变样式，以适应不同终端。缺点：制作麻烦，需要花很多精力去调<strong>兼容性</strong>问题。<ul><li>三星手机官网</li></ul></li></ul><h4 id="8-移动端技术解决方案"><a href="#8-移动端技术解决方案" class="headerlink" title="8.移动端技术解决方案"></a>8.移动端技术解决方案</h4><ul><li><strong>移动端浏览器</strong><ul><li>移动端浏览器基本以webkit内核为主，因此就需要考虑webkit兼容性问题；</li><li>可以放心使用H5标签和CSS3样式；</li><li>同时，我们浏览器的私有前缀只需要考虑添加webkit即可；</li></ul></li><li><strong>CSS样式初始化</strong>normalize.css<ul><li>移动端CSS初始化推荐使用normalize.css；</li></ul></li><li><p><strong>CSS盒子模型box-sizing</strong></p><ul><li>传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding；</li><li><p>CSS3盒子模型：盒子的宽度 = CSS中设置的宽度width里面包含了border和padding。即CSS3中的盒子模型，padding和border不会撑大盒子；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS3盒子模型 --&gt;</span></span><br><span class="line">box-sizing: border-box;</span><br><span class="line"><span class="comment">&lt;!-- 传统盒子模型 --&gt;</span></span><br><span class="line">box-sizing: content-box;</span><br></pre></td></tr></table></figure></li><li><p>移动端可以全部使用CSS3盒子模型；</p></li><li>PC端如果完全需要兼容，就使用传统盒子模型；如果不考虑兼容性，就选择CSS3盒子模型；</li></ul></li></ul><h4 id="9-特殊样式"><a href="#9-特殊样式" class="headerlink" title="9.特殊样式"></a>9.特殊样式</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS盒子模型 --&gt;</span></span><br><span class="line">box-sizing: border-box;</span><br><span class="line">-webkit-box-sizing: border-box;</span><br><span class="line"><span class="comment">&lt;!-- 点击高亮我们需要清除 设置transparent完成透明 --&gt;</span></span><br><span class="line">-webkit-tap-highlight-color: transparent;</span><br><span class="line"><span class="comment">&lt;!-- 在移动端浏览器默认的外观在IOS上加上这个属性才能给按钮和输入框自定义样式 --&gt;</span></span><br><span class="line">-webkit-appearance: none;</span><br><span class="line"><span class="comment">&lt;!-- 禁止长按页面时的弹出菜单 --&gt;</span></span><br><span class="line">img,a &#123;-webkit-touch-callout: none;&#125;</span><br></pre></td></tr></table></figure><h4 id="10-移动端常见布局"><a href="#10-移动端常见布局" class="headerlink" title="10.移动端常见布局"></a>10.移动端常见布局</h4><ul><li>移动端布局和PC端有所区别：<ul><li>a.单独制作移动端页面(主流)<ul><li>流式布局(百分比布局)</li><li>flex弹性布局(强烈推荐)</li><li>less+rem+媒体查询布局</li><li>混合布局</li></ul></li><li>b.<strong>响应式</strong>页面兼容移动端(其次)<ul><li>媒体查询</li><li>bootstarp</li></ul></li></ul></li></ul><h4 id="11-移动端布局之流式布局"><a href="#11-移动端布局之流式布局" class="headerlink" title="11.移动端布局之流式布局"></a>11.移动端布局之流式布局</h4><ul><li>流式布局，就是百分比布局，也称为非固定像素布局；</li><li>通过盒子的宽度设置成百分比来根据屏幕的宽度进行伸缩，不受固定像素的限制，内容向两侧填充；</li><li>流式布局方式是移动web开发中使用的比较常见的布局方式；</li><li>max-width 最大宽度(max-height 最大高度)</li><li>min-width 最小宽度 (min-height 最小高度)</li></ul><h4 id="12-资料下载"><a href="#12-资料下载" class="headerlink" title="12.资料下载"></a>12.资料下载</h4><ul><li><a href="https://github.com/cdlwhm1217096231/HTML_CSS_JavaScript/tree/master/CSS3/01%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80" target="_blank" rel="noopener">笔记及代码，欢迎star,follow,fork……</a></li></ul><!-- <span id="inline-blue"> 站点配置文件 </span><span id="inline-purple"> 主题配置文件 </span><span id="inline-yellow"> 站点配置文件 </span><span id="inline-green"> 主题配置文件 </span> -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;技术交流QQ群-1027579432，欢迎你的加入！&quot;&gt;&lt;a href=&quot;#技术交流QQ群-1027579432，欢迎你的加入！&quot; class=&quot;headerlink&quot; title=&quot;技术交流QQ群:1027579432，欢迎你的加入！&quot;&gt;&lt;/a&gt;技术交流QQ群:
      
    
    </summary>
    
      <category term="Web前端开发" scheme="https://cdlwhm1217096231.github.io/categories/Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="移动端" scheme="https://cdlwhm1217096231.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer第二版题解(详细版)</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%89%91%E6%8C%87offer%E7%AC%AC%E4%BA%8C%E7%89%88%E9%A2%98%E8%A7%A3-%E8%AF%A6%E7%BB%86%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/数据结构与算法/剑指offer第二版题解-详细版/</id>
    <published>2019-09-09T08:22:44.000Z</published>
    <updated>2020-03-08T07:00:18.942Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-滑动窗口的最大值（剑指offer原59题）"><a href="#1-滑动窗口的最大值（剑指offer原59题）" class="headerlink" title="1.滑动窗口的最大值（剑指offer原59题）"></a>1.滑动窗口的最大值（剑指offer原59题）</h4><ul><li>解题思路：<strong>其实是一个队列的问题，用一个队列去维护当前窗口中的所有元素；首先将超出窗口中的队头元素先删掉，然后将新的元素插入当前窗口中，插入时要判断新插入的元素与队尾元素的大小，如果队尾元素较小，则先删除队尾元素再插入</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)   <span class="comment">// k是窗口的大小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; q.front() &lt;= i - k) q.pop_front();  <span class="comment">// 将已经划出窗口中的元素从队列中删除</span></span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; nums[q.back()] &lt;= nums[i])  nums.pop_back();   <span class="comment">// 如果在队尾插入的元素大于等于当前队尾的元素值，就可以删除队尾的元素！</span></span><br><span class="line">            q.push_back(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) res.push_back(nums[q.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！-与剑指offer60题有点差别！"><a href="#2-n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！-与剑指offer60题有点差别！" class="headerlink" title="2.n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！(与剑指offer60题有点差别！)"></a>2.n个骰子的点数，这里求的是扔n次骰子，n次中骰子点数之和是s的，所有方案可能的数！(与剑指offer60题有点差别！)</h4><ul><li><p>解题思路：每次扔骰子，最小值是1，最大值是6；所以扔n个骰子在地上后的，最小值就是n，最大值就是6*n。dfs()算法的思路：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dfs方法来解决：注意两点，第一是状态的表示是什么(从输出中来)？第二是按照什么顺序来计算第一步中的状态？</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numberOfDice(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt;= <span class="number">6</span> * n; i++) res.push_back(dfs(n, i));  <span class="comment">// dfs(n, s)表示的就是所要输出的结果；也就是每次求总和是s的情况下，一共投了n次骰子，一共有多少种方案</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> !sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res += dfs(n - <span class="number">1</span>, sum - i);  <span class="comment">// 热狗法：最后一次骰子点数已经确定时，则只需要计算前面投了n-1次骰子，总和是s-i的情况下，一共有多少种方案。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>动态规划算法dp的思路：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dp方法来解决：注意三点，第一是状态的表示是什么(从输出中来)？第二是如何计算第一步中的状态？第三是边界问题</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numberOfDice(<span class="keyword">int</span> n)&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n * <span class="number">6</span> + <span class="number">1</span>));  <span class="comment">// dp的状态表示</span></span><br><span class="line">       f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 当所有的骰子都没有扔出时，总和s=0时，只有一种方案；总和s=1, 2, 3, 4, ....都是不合法的！</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;  <span class="comment">// 先循环扔出去的次数</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i * <span class="number">6</span>; j++)&#123;      <span class="comment">// 再循环总和s是多少</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= min(j, <span class="number">6</span>); k++)&#123;  <span class="comment">// 枚举最后一次的点数是多少</span></span><br><span class="line">                    f[i][j] += f[i- <span class="number">1</span>][j - k];  <span class="comment">// 状态f[i][j]表示前i次总和是j的方案数！</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt;= n * <span class="number">6</span>; i++) res.push_back(f[n][i]);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-扑克牌的顺子-剑指offer原61题"><a href="#3-扑克牌的顺子-剑指offer原61题" class="headerlink" title="3.扑克牌的顺子(剑指offer原61题)"></a>3.扑克牌的顺子(剑指offer原61题)</h4><ul><li>解题思路：模拟人的想法，先将<strong>除去了大小王之外</strong>的牌拿过来，如果有相同元素，则一定不是顺子！如果没有任何两个元素相同，看一下牌中最小值与最大值的差距是否在4以内。如果满足条件，则可以将缺失的部分用大小王来进行填补。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从扑克牌中随机抽5张牌，判断是不是一个顺子。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isContinous</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!nums[k]) k++;   <span class="comment">// 去掉行首的0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt; nums.size(); i++)&#123;  <span class="comment">// 去掉重复元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums.back() - nums[k] &lt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-圆圈中最后剩下的数字-剑指offer原62题-——约瑟夫环问题"><a href="#4-圆圈中最后剩下的数字-剑指offer原62题-——约瑟夫环问题" class="headerlink" title="4.圆圈中最后剩下的数字(剑指offer原62题)——约瑟夫环问题"></a>4.圆圈中最后剩下的数字(剑指offer原62题)——约瑟夫环问题</h4><ul><li>解题思路：f(n,m)表示总共n个数字，每次报到数字m时，就将此数字从环中删除,最后剩下的数字。f(n-1,m)表示从剩下的n-1个数字中，每次报到数字m时，就将此数字从环中删除，最后剩下的数字。观察f(n,m)与f(n-1,m)之间的关系，可知f(n,m) = (f(n-1,m) + m) % n,其中边界条件是f(n==1, m) = 0;  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (lastRemaining(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-股票的最大利润（剑指offer原63题）"><a href="#5-股票的最大利润（剑指offer原63题）" class="headerlink" title="5.股票的最大利润（剑指offer原63题）"></a>5.股票的最大利润（剑指offer原63题）</h4><ul><li>解题思路：找出前i天的最小值，利用一个变量minValue来存储。第i天卖出的价格是nums[i]，最大利润res是等于第i天卖出价格与前i天中价格最低时买入的价格之差，此时获得的利润是最大的。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDiff</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;   <span class="comment">// 最大利润</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, minValue = nums[<span class="number">0</span>]; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            res = max(res, nums[i] - minValue);  <span class="comment">// minValue表示前i天的最小值，nums[i]表示第i天卖出的价格！</span></span><br><span class="line">            minValue = min(minValue, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-求1-2-3-…-n，不能使用乘除法和各种循环、判断语句-剑指offer原64题"><a href="#6-求1-2-3-…-n，不能使用乘除法和各种循环、判断语句-剑指offer原64题" class="headerlink" title="6.求1+2+3+…+n，不能使用乘除法和各种循环、判断语句(剑指offer原64题)"></a>6.求1+2+3+…+n，不能使用乘除法和各种循环、判断语句(剑指offer原64题)</h4><ul><li>解题思路：使用递归的思路来写，但是将当中的if语句，改成&amp;&amp;运算符。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = n;</span><br><span class="line">        n &gt; <span class="number">0</span> &amp;&amp; (res += getSum(n - <span class="number">1</span>));   <span class="comment">// 实际是对if(n &gt; 0) res += getSum(n - 1);语句的改写</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-不用加减乘除做加法-剑指offer原65题"><a href="#7-不用加减乘除做加法-剑指offer原65题" class="headerlink" title="7.不用加减乘除做加法(剑指offer原65题)"></a>7.不用加减乘除做加法(剑指offer原65题)</h4><ul><li>解题思路：模拟计算机中的加法A + B，结果是CD。其中C是十位，D是个位。A和B对应位上的取值有四种(0 0、0 1、1 0、1 1)，C上的结果是(0 0 0 1),D上的结果是(0 1 1 0)。可以将C上的结果看出(A对应位上的取值 &amp; B对应位上的取值)；将D上的结果看出(A对应位上的取值 ^ B对应位上的取值)。因此，可以将多位数相加A + B可以看出是A + B= A^B(无进位) + (A &amp; B &lt;&lt; 1)(A &amp; B表示的就是进位)。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(num2)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = num1 ^ num2;</span><br><span class="line">            <span class="keyword">int</span> carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            num1 = sum;</span><br><span class="line">            num2 = carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-构建乘积数组-剑指offer原66题-不能用除法、只能开一个数组"><a href="#8-构建乘积数组-剑指offer原66题-不能用除法、只能开一个数组" class="headerlink" title="8.构建乘积数组(剑指offer原66题)[不能用除法、只能开一个数组]"></a>8.构建乘积数组(剑指offer原66题)[不能用除法、只能开一个数组]</h4><ul><li>解题思路：B[i] = A[0] * A[1] * … * A[i-1] * A[i+1] * … * A[n-1]。可以先算i的左半边 A[0] * A[1] * … * A[i-1]，然后算i的右半边A[i+1] * … * A[n-1]，最后两部分相乘。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.empty()) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先算A[0]到A[i-1]的乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, p = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            B[i] = p;</span><br><span class="line">            p *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再算A[i+1]到A[n-1]的乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>, p = <span class="number">1</span>; ~i; i--)&#123;</span><br><span class="line">            B[i] *= p;</span><br><span class="line">            p *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-把字符串转换成整数-剑指offer原67题"><a href="#9-把字符串转换成整数-剑指offer原67题" class="headerlink" title="9.把字符串转换成整数(剑指offer原67题)"></a>9.把字符串转换成整数(剑指offer原67题)</h4><ul><li>解题思路：处理好各种边界问题！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strToInt</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; str.size() &amp;&amp; str[k] == <span class="string">' '</span>) k++;  <span class="comment">// 忽略所有的行首空格！</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> is_minus = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 忽略完行首的空格后，可能有-/+的符号</span></span><br><span class="line">        <span class="keyword">if</span>(str[k] == <span class="string">'+'</span>) k++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[k] == <span class="string">'-'</span>) k++, is_minus = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(k &lt; str.size() &amp;&amp; str[k] &gt;= <span class="string">'0'</span> &amp;&amp; str[k] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">            number = number * <span class="number">10</span> + str[k] - <span class="string">'0'</span>;   <span class="comment">// 字符串表示的数字转换成真正的数字</span></span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(is_minus) number *= <span class="number">-1</span>;  <span class="comment">// 处理负数的情况</span></span><br><span class="line">        <span class="keyword">if</span>(number &gt; INT_MAX) number = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(number &lt; INT_MIN) number = INT_MIN;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-树中两个结点的最低公共祖先-剑指offer原68题"><a href="#10-树中两个结点的最低公共祖先-剑指offer原68题" class="headerlink" title="10.树中两个结点的最低公共祖先(剑指offer原68题)"></a>10.树中两个结点的最低公共祖先(剑指offer原68题)</h4><ul><li>解题思路：给出的两个结点的位置可能有两种情况，一种是两个结点出现在一个结点的左右两个子树上；另一种是一个给定的结点出现最低公共祖先节点上，另一个给定的结点出现在左子树或右子树上！<br>具体的方法是：先遍历左子树，检查是否有给定的两个结点p、q；再遍历右子树，检查是否有给定的两个结点p、q。如果左右子树中同时出现了p、q，则当前结点就是需要返回的就是最低公共祖先结点；如果只在左子树或右子树中出现p、q，则返回值就是p、q的最低公共祖先。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 空树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> left = lowestCommonAncestor(root-&gt;left, p, q);   <span class="comment">// 检查一下左边是否有p和q</span></span><br><span class="line">        <span class="keyword">auto</span> right = lowestCommonAncestor(root-&gt;right, p, q);  <span class="comment">// 检查一下右边是否有p和q</span></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-数字在排序数组中出现的次数-剑指offer原53题—题目一）"><a href="#11-数字在排序数组中出现的次数-剑指offer原53题—题目一）" class="headerlink" title="11.数字在排序数组中出现的次数(剑指offer原53题—题目一）"></a>11.数字在排序数组中出现的次数(剑指offer原53题—题目一）</h4><ul><li>解题思路：<strong>二分法解决！</strong>就是此数字第一次出现的位置与此数字最后一次出现的位置，两者之间的数的个数就是该数字出现的次数！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; k) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[l] != k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = l;</span><br><span class="line">        l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= k) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="12-0到n-1中缺失的数字-剑指offer原53题—-题目二"><a href="#12-0到n-1中缺失的数字-剑指offer原53题—-题目二" class="headerlink" title="12.0到n-1中缺失的数字(剑指offer原53题—-题目二)"></a>12.0到n-1中缺失的数字(剑指offer原53题—-题目二)</h4><ul><li>题目要求的是：长度为n的数组,将其中的一个数删掉，只剩下n-1个数了。将剩下的n-1个数作为程序的输入，找出被删除的那个数！</li><li>解题思路：先计算0到n-1中的n个数的和，再减去当前序列中的每个数，也就可以得到答案了。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;  <span class="comment">// nums是输入的n-1个数</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = (n - <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums) res -= x;</span><br><span class="line">        <span class="keyword">return</span> res;   <span class="comment">// res就是0到n-1中缺失的那个数字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="13-数组中数值和下标相等的元素-剑指offer原53题—-题目三"><a href="#13-数组中数值和下标相等的元素-剑指offer原53题—-题目三" class="headerlink" title="13.数组中数值和下标相等的元素(剑指offer原53题—-题目三)"></a>13.数组中数值和下标相等的元素(剑指offer原53题—-题目三)</h4><ul><li>解题思路：因为给定的数组nums具有单调递增的性质，可以使用二分查找，时间复杂度是O(logn)。考察数组nums[i]-i是否具有单调性。即（nums[i]-i &gt;= nums[i-1] - (i-1)是否成立？）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumberSameAsIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] - mid &gt;= <span class="number">0</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[r] - r == <span class="number">0</span>) <span class="keyword">return</span> r;  <span class="comment">// 相等元素的下标</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="14-二叉搜索树的第K个大的结点-剑指offer原54题"><a href="#14-二叉搜索树的第K个大的结点-剑指offer原54题" class="headerlink" title="14.二叉搜索树的第K个大的结点(剑指offer原54题)"></a>14.二叉搜索树的第K个大的结点(剑指offer原54题)</h4><ul><li>解题思路：先对二叉搜索树进行中序遍历，每遍历到一个结点后，就对K进行减一操作。直到k减小到0后，就已经找到了第K个大的结点。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        dfs(root, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root-&gt;left, k);  <span class="comment">// 中序遍历</span></span><br><span class="line">        k--;</span><br><span class="line">        <span class="keyword">if</span>(!k) ans = root;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; <span class="number">0</span>) dfs(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="15-二叉树的深度-剑指offer原55题"><a href="#15-二叉树的深度-剑指offer原55题" class="headerlink" title="15.二叉树的深度(剑指offer原55题)"></a>15.二叉树的深度(剑指offer原55题)</h4><ul><li>解题思路：深度就是找出从根结点到叶子节点的路径最长长度！具体就是找出根节点的左右子树两者中更长者的深度+1，即二叉树的深度。左右子树的深度用递归的方法来求解，当递归到叶子节点时，递归停止！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">treeDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 递归终止条件！</span></span><br><span class="line">        <span class="keyword">return</span> max(treeDepth(root-&gt;left), treeDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="16-平衡二叉树-剑指offer原55题—题目二"><a href="#16-平衡二叉树-剑指offer原55题—题目二" class="headerlink" title="16.平衡二叉树(剑指offer原55题—题目二)"></a>16.平衡二叉树(剑指offer原55题—题目二)</h4><ul><li>解题思路：利用上一题的思路，求出左右子树的深度之差是否是大于1的，如果所有点的深度差都不大于1的话，则是平衡二叉树；如果任意一个结点的左右子树深度之差大于1，则一定是非平衡二叉树!  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root-&gt;left), right = dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span>;  <span class="comment">// 当前结点的深度 == 当前结点左右子树的深度的更大者 + 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="17-数组中只出现一次的两个数字-剑指offer原56题"><a href="#17-数组中只出现一次的两个数字-剑指offer原56题" class="headerlink" title="17.数组中只出现一次的两个数字(剑指offer原56题)"></a>17.数组中只出现一次的两个数字(剑指offer原56题)</h4><ul><li>原题是：一个数组中除了两个数字之外，其他数字都出现了2次。利用程序找出这两个只出现一次的数字！</li><li>解题思路：<ul><li><strong>先考虑一种简单的情况</strong>，数组中除了一个数字只出现一次外，其余数字都出现了2次，找出这个只出现一次的数字。<strong>利用异或运算的特点，所有出现两次的数字异或时都被消成0，再将异或结果与只出现一次的数字进行异或，结果就是我们要找的数字</strong>。</li><li>本题中只出现一次的数字有两个，如何找出这两个只出现一次的数呢?<strong>*利用上面一样的操作，对所有的数字执行异或操作，得到的结果是两个只出现一次的数字的异或，由于两个数字都只出现一次。因此，最终的异或结果肯定不等于0</strong>。因为两个只出现一次的数字的异或的结果不等于0，所以异或结果的二进制表示中肯定有一位是1。假设异或结果中的第3位是1，则两个只出现一次的数字二进制表示的第3位一定是不相同的。<strong>此时，将原始数组中所有数字划分成两个集合，划分的依据就是看数组中每个数字的第3位是0还是1。因此，两个只出现一次的数字一定不在同一个集合中！所有出现两次的数字一定在同一个集合中！此时，两个集合中的数字就转化成最开始讨论的一种简单情况的例子</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumsAppearance(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) sum ^= x;   <span class="comment">// 先求所有数字的异或和,也就是sum = x ^ y  x,y分别表示数组中只出现一次的数字</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(sum &gt;&gt; k &amp; <span class="number">1</span>)) k++;  <span class="comment">// 然后从sum中找出其二进制表示中任意一位不为0的位，k存储的就是x ^ y结果中第k位是1的那一位</span></span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;&gt; k &amp; <span class="number">1</span>)   <span class="comment">// 将x的二进制表示中第k位是1的划分到第一个集合first中！</span></span><br><span class="line">                first ^= x;  <span class="comment">// 第一个集合异或的结果first  第二个结果异或的结果first ^ sum</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;first, sum ^ first&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="18-数组中唯一只出现一次的数字-剑指offer原56题—题目2"><a href="#18-数组中唯一只出现一次的数字-剑指offer原56题—题目2" class="headerlink" title="18.数组中唯一只出现一次的数字(剑指offer原56题—题目2)"></a>18.数组中唯一只出现一次的数字(剑指offer原56题—题目2)</h4><ul><li>原题目：一个数组中除了一个数字只出现一次外，其他数字都出现了三次，找出那个只出现一次的数字。</li><li>解题思路：<strong>有限状态机原理，初始的状态是(ones=0,twos=0);输入的数字的二进制表示中某一位是1时，状态转移成(1,0),接着数字的二进制表示中某一位仍然是1时，状态转移成(0,1),接着数字的二进制表示中某一位继续是1时，状态转移成(0,0)。也就是每三个状态构成一个循环；当输入的数字的二进制表示中某一位是0时，从初始的状态是(ones=0,twos=0)转移至自身(0,0)；当所有的输入数字中某一位出现次数是%3余1时，状态就转移到(1,0)；当所有的输入数字中某一位出现次数是%3余0时，状态就转移到(0,0)状态</strong>。ones就代表了上面两种情况的结果。数组中唯一只出现一次的数字。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNumberAppearingOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            ones = (ones ^ x) &amp; ~twos;</span><br><span class="line">            twos = (twos ^ x) &amp; ~ones;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ones;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="19-和为s的数字-剑指offer原57题—-题目一"><a href="#19-和为s的数字-剑指offer原57题—-题目一" class="headerlink" title="19.和为s的数字(剑指offer原57题—-题目一)"></a>19.和为s的数字(剑指offer原57题—-题目一)</h4><ul><li><p>解题思路1：暴力解法，先依次遍历每个数字，遍历到某个数字时，固定这个数字。再依次判断数组中其余的n-1个数字与它的和是否等于target。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力解法O(n**2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumberWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[j]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>解题思路2：对第二重循环进行优化，第二重循环的目的是判断对于j &lt; i这个范围内，是否存在一个数字nums[j]使得target - nums[i] == nums[j]成立。因此，可以使用哈希表来统计数字nums[j]是否出现从而来优化，使得时间复杂度变成O(n)。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findNumberWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hash.count(target - nums[i])) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;target - nums[i], nums[i]&#125;;  <span class="comment">// hash.count(target - nums[i])就是判断nums[j]是否在j &lt; i的范围内出现！</span></span><br><span class="line">            hash.insert(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="20-和为s的连续正数序列-剑指offer原57题—-题目二"><a href="#20-和为s的连续正数序列-剑指offer原57题—-题目二" class="headerlink" title="20.和为s的连续正数序列(剑指offer原57题—-题目二)"></a>20.和为s的连续正数序列(剑指offer原57题—-题目二)</h4><ul><li>原题：<strong>输入一个正数s,输出所有和为s的连续正数序列</strong>，序列中至少含有两个数。</li><li>解题思路：暴力方法是给出区间的起点i,再给出区间的终点j。利用求和公式计算出区间[i,j]中数字的和是否为s，时间复杂度是O(n<strong>2)。改进的方法是：假设区间[i,j]中数字的和是s，当区间左端点i向右移动到i1时，</strong>区间的右端点j也会向右移动到j1，如果右端点j向左移动到j2，则区间[i1,j2]中的数字之和一定是小于s的**。总结起来就是使用双指针算法，时间复杂度变成O(n)。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力方法：O(n**2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> sum)&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>, s = <span class="number">1</span>; i &lt;= sum; i++)  <span class="comment">// s是当前序列的和</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">while</span>(s &lt; sum) s += ++j;</span><br><span class="line">           <span class="keyword">if</span>(s == sum &amp;&amp; j - i + <span class="number">1</span> &gt; <span class="number">1</span>)&#123;  <span class="comment">// [i,j]中包含的元素个数是: j - i + 1</span></span><br><span class="line">               <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; line;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++) line.push_back(k);  <span class="comment">// line是一个一维数组，数组中存放的是区间[i,j]中和为s的数字</span></span><br><span class="line">               res.push_back(line);</span><br><span class="line">           &#125;</span><br><span class="line">           s -= i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="21-翻转单词顺序-剑指offer原58题—-题目一"><a href="#21-翻转单词顺序-剑指offer原58题—-题目一" class="headerlink" title="21.翻转单词顺序(剑指offer原58题—-题目一)"></a>21.翻转单词顺序(剑指offer原58题—-题目一)</h4><ul><li>原题：输入一个句子，翻转句子中单词的顺序，但每个单词内的字母顺序不变。</li><li>解题思路：先用双指针i和j，将整个句子的每个单词以字母为单位进行翻转；然后对句子的每个单词进行翻转。  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">string</span> reverseWords(<span class="keyword">string</span> s)&#123;</span><br><span class="line">        reverse(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());  <span class="comment">// 等价于for(int i = 0, j = s.size() - 1; i &lt; j; i++, j--) swap(s[i], s[j]); 第一步首先对整个句子进行翻转</span></span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;  <span class="comment">// 对第一步中翻转后的每个单词进行翻转，下面是从一段字符串中提取出一个单词的操作！</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="built_in">while</span>(j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] != <span class="string">' '</span>) j++;</span><br><span class="line">            reverse(s.<span class="built_in">begin</span>() + i, s.<span class="built_in">begin</span>() + j);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="22-左旋转字符串-剑指offer原58题—-题目二"><a href="#22-左旋转字符串-剑指offer原58题—-题目二" class="headerlink" title="22.左旋转字符串(剑指offer原58题—-题目二)"></a>22.左旋转字符串(剑指offer原58题—-题目二)</h4><ul><li>原题是：将字符串中的前面的前n位移动到字符串的尾部。</li><li>解题思路：和上一题一样的思路，先对整个字符串进行翻转。然后将翻转后的结果分成两个部分：前str.size() - n个字符和倒数n个字符，然后分别对上面的两部分进行翻转即可。  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">string</span> leftRotateString(<span class="keyword">string</span> str, <span class="keyword">int</span> n)&#123;</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>() + str.<span class="built_in">size</span>() - n);</span><br><span class="line">        reverse(str.<span class="built_in">begin</span>() + str.<span class="built_in">size</span>() - n, str.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="23-数字序列中某一位的数字-剑指offer原44题"><a href="#23-数字序列中某一位的数字-剑指offer原44题" class="headerlink" title="23.数字序列中某一位的数字(剑指offer原44题)"></a>23.数字序列中某一位的数字(剑指offer原44题)</h4><ul><li>解题思路：<ul><li>1.确定是几位数（n - 10*1 - 90*2 - 900*3 - …）</li><li>2.确定是几位数的第几个数</li><li>3.确定那个数的第几位</li></ul></li><li>详细过程：首先要确定第n位对应的数字在什么范围内，也就是确定第n位对应的数字是几位数。因为一位数有10个，占10位，两位数有90个，占180位，三位数有900个，占2700位。假设输入的是第1000位，则第1000位对应的应该是一个三位数（因为1000-10-180 = 720 &lt; 2700）；然后确定第1000位对应的是哪个三位数上的某一位。因为经过上一步的分析可知，输入的第1000位出现在两位数之后的第720位，因为三位数每个数占3位，所以输入的第1000位对应的应该是第240个三位数中的某一位！由于三位数从100开始，所以第240个三位数是100 + 240 - 1 = 339；最后确定对应是339中的哪一位（因为720 / 3 = 240，所以应该对应339的最后一位9）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>, s = <span class="number">9</span>, base = <span class="number">1</span>;  <span class="comment">// i是几位数  s是几位数的个数  base是几位数的开始第一个数字</span></span><br><span class="line">        <span class="comment">// 确定n对应是几位数</span></span><br><span class="line">        <span class="keyword">while</span>(n &gt; i * s)&#123;</span><br><span class="line">            n -= i * s;</span><br><span class="line">            i++;</span><br><span class="line">            s *= <span class="number">10</span>;</span><br><span class="line">            base *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定是几位数中的哪个数</span></span><br><span class="line">        <span class="keyword">int</span> number = base + (n + i - <span class="number">1</span>) / i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 确定那个数的第几位</span></span><br><span class="line">        <span class="keyword">int</span> r = n % i ? n % i : i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - r; j++) number /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="24-把数组排成最小的数-剑指offer原45题"><a href="#24-把数组排成最小的数-剑指offer原45题" class="headerlink" title="24.把数组排成最小的数(剑指offer原45题)"></a>24.把数组排成最小的数(剑指offer原45题)</h4><ul><li>解题思路：首先在数组中定义两个数字之间的小于&lt;关系：即a &lt; b等价于ab &lt; ba。然后将原始的输入数组按照定义的小于关系重新排序，一次拼接派好序后的数组中的数字即可。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> as = to_string(a), bs = to_string(b);</span><br><span class="line">        <span class="keyword">return</span> as + bs &lt; bs + as;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">printMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end(), cmp);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) res += to_string(x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="25-把数字翻译成字符串-剑指offer原46题"><a href="#25-把数字翻译成字符串-剑指offer原46题" class="headerlink" title="25.把数字翻译成字符串(剑指offer原46题)"></a>25.把数字翻译成字符串(剑指offer原46题)</h4><ul><li>解题思路：<strong>大部分计数的问题，可以看成是动态规划的问题</strong>。问题的关键是<strong>a.状态表示 b.状态如何计算 c.边界怎么定义</strong>。f(i)表示前i位数字一共有多少种翻译方式，f(i)<br>如何计算？如果将第i位数字单独翻译成一个字母，则f(i)可表示为前i-1位数字一共有多少种翻译方式；如果将第i位和第i-1位数字翻译成两个个字母，则f(i)可表示为前i-2为数字一共有多少种翻译方式。综合上述两种情况,f(i) = f(i-1) + f(i-2)。<strong>注意第二种情况：f(i-2)是将第i和第i-1位数字联合起来翻译成字母，因此必须有约束,范围是[10,25]之间</strong>。最后，考虑边界f(0) = 1。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTranslationCount</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n+<span class="number">1</span>);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>];   <span class="comment">// 第一种情况</span></span><br><span class="line">            <span class="keyword">int</span> t = (s[i<span class="number">-2</span>] - <span class="string">'0'</span>) * <span class="number">10</span> + s[i<span class="number">-1</span>] - <span class="string">'0'</span>;  <span class="comment">// 第二种情况</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt;= <span class="number">10</span> &amp;&amp; t &lt;= <span class="number">25</span>) f[i] += f[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="26-礼物的最大价值-剑指offer原47题"><a href="#26-礼物的最大价值-剑指offer原47题" class="headerlink" title="26.礼物的最大价值(剑指offer原47题)"></a>26.礼物的最大价值(剑指offer原47题)</h4><ul><li>解题思路：<strong>经典的边界问题，还是要考虑三个问题，状态怎么表示；状态的计算问题；怎么定义边界</strong>。f[i,j]表示从左上角出发，到达当格子获得的最大价值。状态计算[i, j] = max(f[i-1, j],f[i, j-1]) + gifts[i,j]；边界f[i,0] = f[0, j] = 0。所要求的答案是f[n,m]。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                f[i][j] = max(f[i <span class="number">-1</span>][j], f[i][j<span class="number">-1</span>]) + grid[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="27-最长不含重复字符的子字符串-剑指offer原48题"><a href="#27-最长不含重复字符的子字符串-剑指offer原48题" class="headerlink" title="27.最长不含重复字符的子字符串(剑指offer原48题)"></a>27.最长不含重复字符的子字符串(剑指offer原48题)</h4><ul><li>解题思路：双指针i、j算法，当j指针每向后移动一位时，判断i到j中是否有重复字符，如果出现了重复字符，就将i指向的重复字符删除，同时i指针向后移动一次。当j移动到字符串末尾时，j-i+1的距离就是不含重复字符的子字符串。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthLongestSubString</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">            hash[s[j]]++;</span><br><span class="line">            <span class="keyword">while</span>(hash[s[j]] &gt; <span class="number">1</span>) hash[s[i++]]--;</span><br><span class="line">            res = max(res, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="28-丑数-剑指offer原49题-———求第n个丑数的值"><a href="#28-丑数-剑指offer原49题-———求第n个丑数的值" class="headerlink" title="28.丑数(剑指offer原49题)———求第n个丑数的值"></a>28.丑数(剑指offer原49题)———求第n个丑数的值</h4><ul><li>解题思路：丑数：一个数的质因子中只包含2 3 5的数！首先将1加入丑数集合中去，然后分别用三个i,j,k指针指向1.。其中i表示2，j表示3，k表示5；然后用1分别与i、j、k三个指针相乘，取相乘后所有结果中的最小值放在1的下一个位置。同时，将指针向后移动一个位置。<strong>当有多个相等的最小值出现时，需要将多个指针分别向后移动一个位置</strong>。依次循环下去，就可以找到整个丑数组成的集合了。（实际上是3路归并排序，将包含因子2的排好序丑数放入一个数组、包含因子3的排好序丑数放入一个数组、包含因子5的排好序丑数放入一个数组；<strong>前面的三个数组中，是不包含因子1</strong>。然后将三个数组分别除以数字2 数字3 数字5得到的结果仍然是一个丑数序列，将得到的3个丑数序列合并后进行判重处理，就得到了最终结果）  <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">int</span> getUglyNumber(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; <span class="string">q(1, 1)</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(--n)&#123;  <span class="regexp">//</span> 循环n-<span class="number">1</span>次    <span class="keyword">while</span>(n--)&#123;&#125;是循环n次</span><br><span class="line">            <span class="keyword">int</span> t = min(<span class="string">q[i]</span> * <span class="number">2</span>, min(<span class="string">q[j]</span> * <span class="number">3</span>, <span class="string">q[k]</span> * <span class="number">5</span>));</span><br><span class="line">            q.push_back(t);</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">q[i]</span> * <span class="number">2</span> == t) i++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">q[j]</span> * <span class="number">3</span> == t) j++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">q[k]</span> * <span class="number">5</span> == t) k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="29-字符串中第一个只出现一次的字符-剑指offer原50题—-题目一"><a href="#29-字符串中第一个只出现一次的字符-剑指offer原50题—-题目一" class="headerlink" title="29.字符串中第一个只出现一次的字符(剑指offer原50题—-题目一)"></a>29.字符串中第一个只出现一次的字符(剑指offer原50题—-题目一)</h4><ul><li>解题思路：先定义一个hash表，统计每个字符出现多少次，然后从前往后遍历hash表，扫描到第一个值是1对应的key，也就是最终的结果  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) hash[c]++;  <span class="comment">// 统计字符串s中每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">char</span> res = <span class="string">'#'</span>;  <span class="comment">// 无解的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">            <span class="keyword">if</span>(hash[c] == <span class="number">1</span>)&#123;</span><br><span class="line">                res = c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="30-字符流中第一个只出现一次的字符-剑指offer原50题—-题目二"><a href="#30-字符流中第一个只出现一次的字符-剑指offer原50题—-题目二" class="headerlink" title="30.字符流中第一个只出现一次的字符(剑指offer原50题—-题目二)"></a>30.字符流中第一个只出现一次的字符(剑指offer原50题—-题目二)</h4><ul><li>解题思路：每次输入字符时，将输入的字符流中出现次数大于1的字符删除。使用队列的数据结构来存储插入的字符！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">char</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入字符到一个队列queue中</span></span><br><span class="line">    <span class="comment">// 利用hash表判断当前正在插入的字符是否出现在当前的队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(++hash[ch] &gt; <span class="number">1</span>)&#123;  <span class="comment">// 插入的字符已经出现在队列中</span></span><br><span class="line">            <span class="keyword">while</span>(q.size() &amp;&amp; hash[q.front()] &gt; <span class="number">1</span>) q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> q.push(ch); <span class="comment">// 插入的字符没有出现在队列中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">firstAppearingOnce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q.empty()) <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">return</span> q.front();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="31-数组中的逆序对-剑指offer原51题）"><a href="#31-数组中的逆序对-剑指offer原51题）" class="headerlink" title="31.数组中的逆序对(剑指offer原51题）"></a>31.数组中的逆序对(剑指offer原51题）</h4><ul><li>解题思路：暴力做法的时间复杂度是O(n**2)，考虑能否使用归并排序的方法来优化算法为O(nlogn)。首先分别对统计同时在左右两个子序列中一共有多少个逆序对（递归方法）；然后计算逆序对不在同一个子序列时，对第二个序列中的每一个数a[j]，计算第一个序列中一共有多少个数a[i]比a[j]要大。因此一共有r-i+1个数比a[j]]要大！最后的结果是上面三个部分的和。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = merge(nums, l, mid) + merge(nums, mid + <span class="number">1</span>, r);  <span class="comment">// 第一和第二部分</span></span><br><span class="line">        <span class="comment">// 第三个部分</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j]) temp.push_back(nums[i++]);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp.push_back(nums[j++]);</span><br><span class="line">                res += mid - i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= mid) temp.push_back(nums[i++]);</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= r) temp.push_back(nums[j++]);</span><br><span class="line">            i = l;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : temp) nums[i++] = x;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">inversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="32-两个链表的第一个公共结点-剑指offer原52题）"><a href="#32-两个链表的第一个公共结点-剑指offer原52题）" class="headerlink" title="32.两个链表的第一个公共结点(剑指offer原52题）"></a>32.两个链表的第一个公共结点(剑指offer原52题）</h4><ul><li>思路：使用两个指针p和q，p指针指向第一个链表的头结点，q指针指向第二个链表的头结点。当p指针遍历到第一个链表的末尾时，接着回到第二链表的头结点位置；当q指针遍历到第二个链表的末尾时，接着回到第一链表的头结点位置。<strong>注意两个指针所走的总距离是相等的</strong>！当进行了多次循环后，两个指针一定会在某个结点处相遇，即公共结点。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">findFirstCommonNode</span><span class="params">(ListNode* headA, ListNode* headB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = headA, q = headB;</span><br><span class="line">        <span class="keyword">while</span>(p != q)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p) p = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p = headB;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(q) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> q = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="33-二叉搜索树的后序遍历序列-剑指offer原33题"><a href="#33-二叉搜索树的后序遍历序列-剑指offer原33题" class="headerlink" title="33.二叉搜索树的后序遍历序列(剑指offer原33题)"></a>33.二叉搜索树的后序遍历序列(剑指offer原33题)</h4><ul><li>题目：给定一个数组，判断此数组是否是某二叉搜索树的后序遍历结果！</li><li>解题思路：先找出数组中的最后一个元素作为树根root，然后找到二叉搜索树的左子树的最后一个位置（左子树中的结点值均小于root，右子树的结点值均大于root）。接着找到二叉搜索树的右子树的最后一个位置。判断结点的值是否满足二叉搜索树的定义！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifySequenceOFBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span></span>&#123;</span><br><span class="line">        seq = sequence;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, seq.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> root = seq[r];</span><br><span class="line">        <span class="keyword">int</span> k = l;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; r &amp;&amp; seq[k] &lt; root) k++;  <span class="comment">// 二叉搜索树的左子树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; r; i++)&#123;  <span class="comment">// 判断二叉搜索树的右子树是否合法</span></span><br><span class="line">            <span class="keyword">if</span>(seq[i] &lt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(l, k<span class="number">-1</span>) &amp;&amp; dfs(k+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="34-二叉树中和为某一值的路径-剑指offer原34题"><a href="#34-二叉树中和为某一值的路径-剑指offer原34题" class="headerlink" title="34.二叉树中和为某一值的路径(剑指offer原34题)"></a>34.二叉树中和为某一值的路径(剑指offer原34题)</h4><ul><li>解题思路：直接遍历一遍二叉树，当遍历到叶节点时，判断从根节点到当前节点的路径上的节点值之和是否等于给定值。如果等于的话，就记录当前的路径。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findPath(TreeNode* root, <span class="keyword">int</span> sum)&#123;</span><br><span class="line">        dfs(root, sum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;  <span class="comment">// 当前节点是空的，就不是叶子节点</span></span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        sum -= root-&gt;val;</span><br><span class="line">        <span class="comment">// 如果当前节点的左右子树都是空的，则当前节点是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !sum) ans.push_back(path);</span><br><span class="line">        <span class="comment">// 递归处理左右子树</span></span><br><span class="line">        dfs(root-&gt;left, sum);</span><br><span class="line">        dfs(root-&gt;right, sum);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="35-复杂链表的复制-剑指offer原35题"><a href="#35-复杂链表的复制-剑指offer原35题" class="headerlink" title="35.复杂链表的复制(剑指offer原35题)"></a>35.复杂链表的复制(剑指offer原35题)</h4><ul><li>解题思路：第一步将每个节点复制出来，然后将当前节点的next指针指向复制出来的节点；第二步将原先节点p的random指针指向第3个节点；那么，被复制出来的p节点是p-&gt;next，其random指针即p-&gt;next-&gt;random指向p-&gt;random-&gt;next节点。最后将复制出来的节点全部连接起来！  <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next, *random;</span><br><span class="line">    ListNode(int x): val(x), next(nullptr), random(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* copyRandomList(ListNode* head)&#123;</span><br><span class="line">        <span class="comment">// 第一步复制所有的节点，并将当前节点指向复制出来的节点</span></span><br><span class="line">        <span class="keyword">for</span>(auto p = head; p;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="title">auto</span> np = new ListNode(p-&gt;</span>val);  <span class="comment">// 复制出来的新节点</span></span><br><span class="line">            <span class="function"><span class="title">auto</span> next = p-&gt;</span><span class="function"><span class="title">next</span>;   // 备份一下p-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span>-&gt;</span>next = np;   <span class="comment">// 复制出来的点接在当前节点的后面</span></span><br><span class="line">            <span class="function"><span class="title">np</span>-&gt;</span>next = next;</span><br><span class="line">            p = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二步复制random指针</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(auto p = head; p; p = p-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next)&#123;</span><br><span class="line">            <span class="function"><span class="title">if</span>(p-&gt;</span>random)</span><br><span class="line">                <span class="function"><span class="title">p</span>-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span><span class="function"><span class="title">random</span> = p-&gt;</span><span class="function"><span class="title">random</span>-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第三步将所有复制出来的节点连接起来</span></span><br><span class="line">        auto dummy = new ListNode(-<span class="number">1</span>);</span><br><span class="line">        auto cur = dummy;   <span class="comment">// 当前新链表的尾节点</span></span><br><span class="line">        <span class="function"><span class="title">for</span>(auto p = head; p; p = p-&gt;</span>next)&#123;</span><br><span class="line">            <span class="function"><span class="title">cur</span>-&gt;</span><span class="function"><span class="title">next</span> = p-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">cur</span> = cur-&gt;</span>next;</span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">return</span> dummy-&gt;</span>next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="36-二叉搜索树与双向链表-剑指offer原36题"><a href="#36-二叉搜索树与双向链表-剑指offer原36题" class="headerlink" title="36.二叉搜索树与双向链表(剑指offer原36题)"></a>36.二叉搜索树与双向链表(剑指offer原36题)</h4><ul><li>解题思路：首先获取根节点；然后分别递归左右子树，左右子树分别返回一个首尾节点(即当前子树中最左边的节点和当前子树中最右边的节点)；接着将三部分拼接起来；最后将左子树的最左侧和右子树的最右侧节点返回就是最后的答案。  <figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">using</span> namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* <span class="built_in">left</span>;</span><br><span class="line">    TreeNode* <span class="built_in">right</span>;</span><br><span class="line">    TreeNode(int x): val(x), <span class="built_in">left</span>(nullptr), <span class="built_in">right</span>(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* convert(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> nullptr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">auto</span> sides = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> sides.<span class="built_in">first</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pair&lt;TreeNode*, TreeNode*&gt; dfs(TreeNode* root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;<span class="built_in">left</span> &amp;&amp; !root-&gt;<span class="built_in">right</span>) <span class="keyword">return</span> &#123;root, root&#125;;  // 当前节点是叶子节点</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span> &amp;&amp; root-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="built_in">auto</span> lsides = dfs(root-&gt;<span class="built_in">left</span>), rsides = dfs(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">            lsides.second-&gt;<span class="built_in">right</span> = root, root-&gt;<span class="built_in">left</span> = lsides.second;</span><br><span class="line">            root-&gt;<span class="built_in">right</span> = rsides.<span class="built_in">first</span>, rsides.<span class="built_in">first</span>-&gt;<span class="built_in">left</span> = root;</span><br><span class="line">            <span class="keyword">return</span> &#123;lsides.<span class="built_in">first</span>, rsides.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">left</span>)&#123;</span><br><span class="line">            <span class="built_in">auto</span> lsides = dfs(root-&gt;<span class="built_in">left</span>);</span><br><span class="line">            lsides.second-&gt;<span class="built_in">right</span> = root, root-&gt;<span class="built_in">left</span> = lsides.second;</span><br><span class="line">            <span class="keyword">return</span> &#123;lsides.<span class="built_in">first</span>, root&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;<span class="built_in">right</span>)&#123;</span><br><span class="line">            <span class="built_in">auto</span> rsides = dfs(root-&gt;<span class="built_in">right</span>);</span><br><span class="line">            root-&gt;<span class="built_in">right</span> = rsides.<span class="built_in">first</span>, rsides.<span class="built_in">first</span>-&gt;<span class="built_in">left</span> = root;</span><br><span class="line">            <span class="keyword">return</span> &#123;root, rsides.second&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="37-序列化二叉树-剑指offer原37题"><a href="#37-序列化二叉树-剑指offer原37题" class="headerlink" title="37.序列化二叉树(剑指offer原37题)"></a>37.序列化二叉树(剑指offer原37题)</h4><ul><li>题目：确保二叉树可以序列化为字符串；并且可以将此字符串反序列化为原始树结构。</li><li>解题思路：利用二叉树的前序遍历实现从二叉树到字符串的序列化操作；反序列化实现的是从字符串到二叉树的转换，注意将字符串类型的数字转成整数的方法！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        dfs_s(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历实现序列化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs_s</span><span class="params">(TreeNode* root, <span class="built_in">string</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            res += <span class="string">"null "</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += to_string(root-&gt;val) + <span class="string">' '</span>;</span><br><span class="line">        dfs_s(root-&gt;left, res);</span><br><span class="line">        dfs_s(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs_d(data, u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_d</span><span class="params">(<span class="built_in">string</span> data, <span class="keyword">int</span>&amp; u)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u == data.size()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> k = u;</span><br><span class="line">        <span class="keyword">while</span>(data[k] != <span class="string">' '</span>) k++;</span><br><span class="line">        <span class="keyword">if</span>(data[u] == <span class="string">'n'</span>)&#123; <span class="comment">// 'n'是null的开始字符</span></span><br><span class="line">            u = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = u; i &lt; k; i++) val = val * <span class="number">10</span> + data[i] - <span class="string">'0'</span>;  <span class="comment">// 将字符串整数"123"转换成整数123</span></span><br><span class="line">        u = k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root-&gt;left = dfs_d(data, u);</span><br><span class="line">        root-&gt;right = dfs_d(data, u);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="38-数字排列—-（与剑指offer38题不同）"><a href="#38-数字排列—-（与剑指offer38题不同）" class="headerlink" title="38.数字排列—-（与剑指offer38题不同）"></a>38.数字排列—-（与剑指offer38题不同）</h4><ul><li>题目：输入一组数字(可能包含重复数字)，输出其所有的全排列</li><li>解题思路：先对输入的数字进行排序，然后开辟与输入一组数字相同长度的数组，接着从输入数字中按顺序取一个数字放在数组的任意一个位置上。<strong>接下来，取第二个数字放在数组中剩下空间的任意一个位置上，如果第二个数字与第一个数字值是相同的，则规定第二个数字只能放在第一个数字的后面的位置</strong>，依次将输入的数字放入数组中，直到数组的各位都已经占满为止。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permutation(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)&#123;</span><br><span class="line">        path.resize(nums.size());   <span class="comment">// 开辟的数组空间大小</span></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        dfs(nums, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);   <span class="comment">// 用一个二进制位来表示哪些位置是空的</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> u, <span class="keyword">int</span> start, <span class="keyword">int</span> state)</span></span>&#123;</span><br><span class="line">        <span class="comment">// u:当前枚举的位置   start: 当前这个数应该从哪个位置开始枚举？（即上一个数的后一个位置开始枚举）</span></span><br><span class="line">        <span class="comment">// state: 存储的是状态，表示哪些数被用过</span></span><br><span class="line">        <span class="keyword">if</span>(u == nums.size())&#123;</span><br><span class="line">            ans.push_back(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!u || nums[u] != nums[u<span class="number">-1</span>]) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!(state &gt;&gt; i &amp; <span class="number">1</span>))&#123;   <span class="comment">// state &gt;&gt; i &amp; 1：看一下state的二进制表示中第i位是否表示为1</span></span><br><span class="line">                path[i] = nums[u];</span><br><span class="line">                dfs(nums, u + <span class="number">1</span>, i + <span class="number">1</span>, state + (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="39-数组中出现次数超过一半的数字（寻找数组中的众数）-剑指offer原39题"><a href="#39-数组中出现次数超过一半的数字（寻找数组中的众数）-剑指offer原39题" class="headerlink" title="39.数组中出现次数超过一半的数字（寻找数组中的众数）(剑指offer原39题)"></a>39.数组中出现次数超过一半的数字（寻找数组中的众数）(剑指offer原39题)</h4><ul><li>解题思路：初始化一个计数变量count = 0，然后遍历数组中的每个元素，当val等于第一个元素时，count加1。接着遍历第二个元素，如果第二个元素的值与第一个元素的值相同时，则count加1；如果第二个元素的值与第一个元素的值不同时，count减1；最后遍历完整个数组后，最终结果存储在val变量中。<strong>摩尔投票法原理</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">moreThanHalfNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, val = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt) val = x, cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x == val) cnt++;</span><br><span class="line">                <span class="keyword">else</span> cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="40-最小的k个数-剑指offer原40题"><a href="#40-最小的k个数-剑指offer原40题" class="headerlink" title="40.最小的k个数(剑指offer原40题)"></a>40.最小的k个数(剑指offer原40题)</h4><ul><li>解题思路：维护一个大顶堆，当最小的k个数存放在大顶堆中。遍历输入数组中的每个元素，然后将每个元素与大顶堆中的堆顶元素进行比较，如果比堆顶元素小，就更新堆顶元素。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getLeastNumbers(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : input)</span><br><span class="line">        &#123;</span><br><span class="line">            heap.push(x);</span><br><span class="line">            <span class="keyword">if</span>(heap.size() &gt; k) heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(heap.size()) res.push_back(heap.top()), heap.pop();  <span class="comment">// heap存放的是从大到小的顺序</span></span><br><span class="line">        reverse(res.rbegin(), res.rend());  <span class="comment">// 翻转一下变成从小到大</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="41-数据流中的中位数-剑指offer原41题"><a href="#41-数据流中的中位数-剑指offer原41题" class="headerlink" title="41.数据流中的中位数(剑指offer原41题)"></a>41.数据流中的中位数(剑指offer原41题)</h4><ul><li>题目：如果从数据流中读出奇数个数值，则中位数就是所有数值排序后位于中间的数值；如果从数据流中读出偶数个数值，则中位数就是所有数值排序之后中间两个数的平均值。</li><li>解题思路：将当前所有的数维护成两个集合，第一个集合是一个小顶堆，存的是比较大的那一部分数；第二个集合是一个大顶堆，存的是比较小的那一部分数。<strong>可以发现，大顶堆的堆顶元素和小顶堆的堆顶元素实际就是输入数据流中间的两个数</strong>。规定，数据流中读出的是奇数个数值时，大顶堆比小顶堆中的元素多一个。如何维护这个结构？<strong>每次插入一个新的元素到大顶堆中，如果下面大顶堆的堆顶元素比上面小顶堆的堆顶元素的大（即逆序了），则交换；如果下面大顶堆中的元素太多了，就要直接转移当中的一个元素到小顶堆中</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; max_heap;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; min_heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        max_heap.push(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(min_heap.size() &amp;&amp; max_heap.top() &gt; min_heap.top())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> maxv = max_heap.top(), minv = min_heap.top();</span><br><span class="line">            max_heap.pop(), min_heap.pop();</span><br><span class="line">            max_heap.push(minv), min_heap.push(maxv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(max_heap.size() &gt; min_heap.size() + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            min_heap.push(max_heap.top());</span><br><span class="line">            max_heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMedian</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(max_heap.size() + min_heap.size() &amp; <span class="number">1</span>) <span class="keyword">return</span> max_heap.top();   <span class="comment">// 数据流中是奇数个数值</span></span><br><span class="line">        <span class="keyword">return</span> (max_heap.top() + min_heap.top()) / <span class="number">2.0</span>;    <span class="comment">// 数据流中是偶数个数值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="42-连续子数组的最大和-剑指offer原42题"><a href="#42-连续子数组的最大和-剑指offer原42题" class="headerlink" title="42.连续子数组的最大和(剑指offer原42题)"></a>42.连续子数组的最大和(剑指offer原42题)</h4><ul><li>解题思路：s表示遍历到当前数x前一个位置为结尾的子数组的和最大值，s如何更新？当s &gt; 0时，s = s + x；当s &lt;= 0时，s = x；  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MIN, s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s &lt; <span class="number">0</span>) s = <span class="number">0</span>;</span><br><span class="line">            s += x;</span><br><span class="line">            res = max(res, s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="43-从1到n整数中1出现的次数-剑指offer原43题"><a href="#43-从1到n整数中1出现的次数-剑指offer原43题" class="headerlink" title="43.从1到n整数中1出现的次数(剑指offer原43题)"></a>43.从1到n整数中1出现的次数(剑指offer原43题)</h4><ul><li>解题思路：假设输入13015，则万位上的1个数：10000-13015共3016个；千位上的1个数：1000-1999,11000-11999，一共有2000个；百位上的1个数：情况有很多种！十位上的1个数：情况有很多种！总结出的一般规律：输入的数字是abcedf，第一种情况：假设c位置上的数字是1，则ab位置上的取值范围是00到ab-1；def位置上的取值范围是000到999，则总方案数是ab*1000。第二种情况：最高位恰好取到ab时，分两种情况讨论。1.c位等于0时，就只有0个1；2.c位等于1时，则def的取值范围是0到def，一共有def+1种方案；3.c大于1时，def位置上的取值范围是000到999，则总方案数是1000！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfBetween1AndN</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; number;</span><br><span class="line">        <span class="comment">// 取出n中的每位数字放入number中</span></span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            number.push_back(n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = number.size() -  <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="number">0</span>, right = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = number.size() - <span class="number">1</span>; j &gt; i; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                left = left * <span class="number">10</span> + number[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                right = right * <span class="number">10</span> + number[j];</span><br><span class="line">                t *= <span class="number">10</span>;  <span class="comment">// t表示右边一共有多少位数</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res += left * t;</span><br><span class="line">            <span class="keyword">if</span>(number[i] == <span class="number">1</span>) res += right + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(number[i] &gt; <span class="number">1</span>) res += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="44-反转链表-剑指offer原24题"><a href="#44-反转链表-剑指offer原24题" class="headerlink" title="44.反转链表(剑指offer原24题)"></a>44.反转链表(剑指offer原24题)</h4><ul><li>解题思路：因为反转的是一个单向链表，所以无法直接遍历当前节点的前驱结点，因此利用一个变量pre记录当前节点的前驱结点。然后从头开始遍历给定的单向链表，直到遍历到空结点为止。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;   <span class="comment">// 记录当前结点的前驱结点</span></span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> next = cur-&gt;next;    <span class="comment">// 用next变量缓存cur-&gt;next，用来使得cur向后移动一位</span></span><br><span class="line">            cur-&gt;next = pre;                   <span class="comment">// 每次遍历时，将当前结点的next指针指向其前驱结点</span></span><br><span class="line">            pre = cur;        <span class="comment">// 将pre指针向后移动一位，此时pre指向cur</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;                 <span class="comment">// pre就是反转后链表的头结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="45-合并两个排序的链表-剑指offer原25题"><a href="#45-合并两个排序的链表-剑指offer原25题" class="headerlink" title="45.合并两个排序的链表(剑指offer原25题)"></a>45.合并两个排序的链表(剑指offer原25题)</h4><ul><li>解题思路：<strong>归并排序的方法来实现即可！</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> cur = dummy;   <span class="comment">// 因为往合并后的链表中添加元素时，是尾部插入的。因此，需要一个cur指针来记录当前链表的尾结点在哪。</span></span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                cur = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                cur = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将两个链表中更长者中剩余的部分链接到已合并链表的末尾</span></span><br><span class="line">        <span class="keyword">if</span>(l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">else</span> cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="46-树的子结构—-树的匹配-剑指offer原26题"><a href="#46-树的子结构—-树的匹配-剑指offer原26题" class="headerlink" title="46.树的子结构—-树的匹配(剑指offer原26题)"></a>46.树的子结构—-树的匹配(剑指offer原26题)</h4><ul><li>解题思路：类比字符串匹配的方法，从根结点root开始枚举，看一下树根root是否是子树的根节点；不是的话，判断树的左孩子结点是否是子树的树根结点；不是的话，判断树的右孩子结点是否是子树的树根结点。然后利用前序遍历树和子树即可。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasSubTree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pRoot1 || !pRoot2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 前序遍历树pRoot1，然后与pRoot2结点进行对比</span></span><br><span class="line">        <span class="keyword">if</span>(isPart(pRoot1, pRoot2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> hasSubTree(pRoot1-&gt;left, pRoot2) || hasSubTree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPart</span><span class="params">(TreeNode* p1, TreeNode* p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p1 || p1-&gt;val != p2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isPart(p1-&gt;left, p2-&gt;left) &amp;&amp; isPart(p1-&gt;right, p2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="47-二叉树的镜像-剑指offer原27题"><a href="#47-二叉树的镜像-剑指offer原27题" class="headerlink" title="47.二叉树的镜像(剑指offer原27题)"></a>47.二叉树的镜像(剑指offer原27题)</h4><ul><li>解题思路：所有结点的左右孩子结点都交换了一下，遍历树中的所有结点，每次遍历完后，将每个结点的左右孩子结点交换一下就可以了。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mirror</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        mirror(root-&gt;left);</span><br><span class="line">        mirror(root-&gt;right);</span><br><span class="line">        swap(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="48-对称的二叉树-剑指offer原28题"><a href="#48-对称的二叉树-剑指offer原28题" class="headerlink" title="48.对称的二叉树(剑指offer原28题)"></a>48.对称的二叉树(剑指offer原28题)</h4><ul><li>解题思路：除了根节点之外，其他的每个结点它的左边的结点和右边的结点是对应的！并且左边结点的左孩子和右边结点的右孩子是对称的，左边结点的右孩子和右边结点的左孩子是对称的！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* p, TreeNode* q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> !p &amp;&amp; !q;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val != q-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(p-&gt;left, q-&gt;right) &amp;&amp; dfs(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="49-顺时针打印矩阵-剑指offer原29题"><a href="#49-顺时针打印矩阵-剑指offer原29题" class="headerlink" title="49.顺时针打印矩阵(剑指offer原29题)"></a>49.顺时针打印矩阵(剑指offer原29题)</h4><ul><li>解题思路：顺时针定义四个方向：右 下 左 上；先按右的方向走，走到不能走为止；然后向下移动一个位置，按下的方向走，走到不能走为止；再向左移动一个位置，按左的方向走，走到不能走为止；最后向上移动一个位置，按上的方向走，走到不能走为止！直到总完n<em>m步就完成了！不能走的定义是：<em>*要么走出了边界，要么你已经走过了这个格子了</em></em>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size(), m = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">if</span>(!n) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>));   <span class="comment">// 二维数组记录每个格子是否被访问过</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;   <span class="comment">// 上 右 下 左</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">1</span>;  <span class="comment">// 起始方向是向右移动，故d = 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(matrix[x][y]);</span><br><span class="line">            st[x][y] = <span class="literal">true</span>;   <span class="comment">// 当前点被标记成已经访问</span></span><br><span class="line">            <span class="keyword">int</span> a = x + dx[d], b = y + dy[d];  <span class="comment">// 下一个点的坐标</span></span><br><span class="line">            <span class="keyword">if</span>(a &lt; <span class="number">0</span> || a &gt;= n || b &lt; <span class="number">0</span> || b &gt;= m || st[a][b])&#123;  <span class="comment">// 当前点已经出界或者被访问过</span></span><br><span class="line">                d = (d + <span class="number">1</span>) % <span class="number">4</span>;   <span class="comment">// d向下移动</span></span><br><span class="line">                a = x + dx[d], b = y + dy[d];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="50-包含min函数的栈-剑指offer原30题"><a href="#50-包含min函数的栈-剑指offer原30题" class="headerlink" title="50.包含min函数的栈(剑指offer原30题)"></a>50.包含min函数的栈(剑指offer原30题)</h4><ul><li>题目：设计一个支持push pop top等操作并可以在O(1)的时间复杂度内检索出最小元素的堆栈。</li><li>解题思路：利用一个辅助栈(<strong>单调栈</strong>)来操作。单调栈：即栈中的元素是单调的！维护一个单调栈，单调栈中的元素大小是单独变化的，当插入一个新的元素到主栈中时，将其与单调栈中的栈顶元素进行比较，当插入的元素比单调栈中的栈顶元素大，则不会将新的元素插入到主栈中；<strong>当插入的元素比单调栈中的栈顶元素小或者与单调栈中的栈顶元素相等时，则将新的元素插入到主栈中去</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk, min_stk;   <span class="comment">// stk是主栈  min_stk是单调栈</span></span><br><span class="line"></span><br><span class="line">    MinStack()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        stk.push(x);</span><br><span class="line">        <span class="keyword">if</span>(min_stk.empty() || min_stk.top() &gt;= x) min_stk.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.top() == min_stk.top()) min_stk.pop();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stk.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="51-栈的压入与弹出序列-剑指offer原31题"><a href="#51-栈的压入与弹出序列-剑指offer原31题" class="headerlink" title="51.栈的压入与弹出序列(剑指offer原31题)"></a>51.栈的压入与弹出序列(剑指offer原31题)</h4><ul><li>解题思路：模拟一遍整个过程，每次往栈里面加一个元素，加完后判断当前栈顶元素是否是当前弹出序列的元素。如果是，则将栈顶元素弹出。当栈里面已经是空时，弹出序列就是合法的，否则就是不合法的!  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(popV.size() != pushV.size()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushV.size(); i++)&#123;</span><br><span class="line">            s.push(pushV[i]);</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; s.top() == popV[index])&#123;</span><br><span class="line">                s.pop();</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="52-不分行从上往下打印二叉树-层序遍历-剑指offer原32题—-题目一"><a href="#52-不分行从上往下打印二叉树-层序遍历-剑指offer原32题—-题目一" class="headerlink" title="52.不分行从上往下打印二叉树[层序遍历](剑指offer原32题—-题目一)"></a>52.不分行从上往下打印二叉树[层序遍历](剑指offer原32题—-题目一)</h4><ul><li>解题思路：宽度优先搜索BFS，利用队列这个数据结构来实现  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printFromTopToBottom(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(q.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            res.push_back(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="53-分行从上往下打印二叉树-剑指offer原32题—-题目二"><a href="#53-分行从上往下打印二叉树-剑指offer原32题—-题目二" class="headerlink" title="53.分行从上往下打印二叉树(剑指offer原32题—-题目二)"></a>53.分行从上往下打印二叉树(剑指offer原32题—-题目二)</h4><ul><li>解题思路：在队列中增加一个null标记，表示当前层的结点已经全部遍历结束。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; printFromTopToBottom(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;   <span class="comment">// 辅助的数组表示每层中有多少个结点</span></span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();  <span class="comment">// 队首元素</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t)  <span class="comment">// t为空时，表示已经遍历完一层</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(level.empty()) <span class="keyword">break</span>;  <span class="comment">// level数组为空时，表示已经遍历完所有的结点，就直接返回</span></span><br><span class="line">                res.push_back(level);</span><br><span class="line">                level.clear();</span><br><span class="line">                q.push(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            level.push_back(t-&gt;val);  <span class="comment">// t不为空时，将当前的点加入到level中，进行扩展</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="54-之字形打印二叉树-剑指offer原32题—-题目三"><a href="#54-之字形打印二叉树-剑指offer原32题—-题目三" class="headerlink" title="54.之字形打印二叉树(剑指offer原32题—-题目三)"></a>54.之字形打印二叉树(剑指offer原32题—-题目三)</h4><ul><li>解题思路：在上一题的基础上增加一个布尔类型的变量zigzag，当zigzag为true时，表示从右到左打印；zigzag为false时，表示从左到右打印！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; printFromTopToBottom(TreeNode* root)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        q.push(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;   <span class="comment">// 辅助的数组表示每层中有多少个结点</span></span><br><span class="line">        <span class="keyword">bool</span> zigzag = <span class="literal">false</span>;   <span class="comment">// 表示从左到右打印</span></span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();  <span class="comment">// 队首元素</span></span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(!t)  <span class="comment">// t为空时，表示已经遍历完一层</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(level.empty()) <span class="keyword">break</span>;  <span class="comment">// level数组为空时，表示已经遍历完所有的结点，就直接返回</span></span><br><span class="line">                <span class="keyword">if</span>(zigzag) reverse(level.begin(), level.end());</span><br><span class="line">                res.push_back(level);</span><br><span class="line">                level.clear();</span><br><span class="line">                q.push(<span class="literal">nullptr</span>);</span><br><span class="line">                zigzag = !zigzag;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            level.push_back(t-&gt;val);  <span class="comment">// t不为空时，将当前的点加入到level中，进行扩展</span></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="55-机器人的运动范围-剑指offer原13题"><a href="#55-机器人的运动范围-剑指offer原13题" class="headerlink" title="55.机器人的运动范围(剑指offer原13题)"></a>55.机器人的运动范围(剑指offer原13题)</h4><ul><li>解题思路：一般考虑使用宽度优先遍历BFS，不建议使用深度优先遍历DFS。因为深度优先遍历在数据范围比较大时，可能会出现栈溢出！从(0,0)点开始遍历，每次将<strong>符合要求</strong>的格子加入到队列中去。最后一共遍历完多少个合法的格子，就是我们最终的结果。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 算出一个数字的各个位置上的数字之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_single_sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            s += x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 算出一个格子中的各个位置上数字之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_sum</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get_single_sum(p.first) + get_single_sum(p.second);    <span class="comment">// p.first是x坐标   p.second是y坐标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingcount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!rows || !cols) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; st(rows, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (cols, <span class="literal">false</span>));   <span class="comment">// 全部初始化成false，记录每个格子是否已经被访问</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);  <span class="comment">// 初始坐标初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;    <span class="comment">// 顺时针来记忆 上 右 下 左</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q.size())&#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(get_sum(t) &gt; threshold || st[t.first][t.second]) <span class="keyword">continue</span>;</span><br><span class="line">            res++;</span><br><span class="line">            st[t.first][t.second] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols)&#123;</span><br><span class="line">                    q.push(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="56-剪绳子-剑指offer原14题"><a href="#56-剪绳子-剑指offer原14题" class="headerlink" title="56.剪绳子(剑指offer原14题)"></a>56.剪绳子(剑指offer原14题)</h4><ul><li>题目：给定一个正整数，将此整数划分成若干个更小的正整数的和<br><strong>使得划分出来的若干个正整数的乘积最大</strong></li><li>解题思路：目标：假设输入的正整数是N，拆分成尽可能多的3！。分下面几种情况：1.如果N % 3 == 0，则拆分成若干个3；2.如果N % 3 == 1，则先将N拆分成两个2，剩下的全部拆分成3；3.如果N % 3 == 2，则先将N拆分成一个2，剩下的全部拆分成3；</li><li>证明上面的三种情况：N &gt; 0，N = n1 + n2 + n3 + …+ nk 1.假设ni &gt;= 5，3 * (ni - 3) &gt;= ni(即3*ni-9 &gt;= ni得到2ni &gt;= 9)是否成立？2.ni = 4， 4 = 2 * 2。<strong>由前面的1和2得到拆分出来的数字一定不包含4和大于等于5的数字</strong>；因此可知所有拆分出来的ni不是2就是3。接下来证明拆分出来的数字中，最多只有两个2（因为2*2*2 &lt; 3*3）。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProductAfterCutting</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span> * (n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">1</span>) res *= <span class="number">4</span>, n -= <span class="number">4</span>;  <span class="comment">// 拆成出来两个2</span></span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">3</span> == <span class="number">2</span>) res *= <span class="number">2</span>, n -= <span class="number">2</span>;  <span class="comment">// 拆出来一个2</span></span><br><span class="line">        <span class="keyword">while</span>(n) res *= <span class="number">3</span>, n -= <span class="number">3</span>;    <span class="comment">// 拆出来全部都是3</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="57-二进制中1的个数-剑指offer原15题"><a href="#57-二进制中1的个数-剑指offer原15题" class="headerlink" title="57.二进制中1的个数(剑指offer原15题)"></a>57.二进制中1的个数(剑指offer原15题)</h4><ul><li>解题思路：s += n &amp; 1是先统计n中个位上是数字1的个数，n&gt;&gt;1则是统计完n中个位的结果后，移除n的个位上的数字来进行更新。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOf1</span><span class="params">(<span class="keyword">int</span> _n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> n = _n;  <span class="comment">// 将有符号数转换成无符号数，为了下面的循环</span></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n)</span><br><span class="line">        &#123;</span><br><span class="line">            s += n &amp; <span class="number">1</span>;  <span class="comment">// 每次将n的个位取出来，判断是否是1，是1的话就s++</span></span><br><span class="line">            n &gt;&gt; <span class="number">1</span>;  <span class="comment">// 然后将n的个位移除，即n右移一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="58-数值的整数次方-剑指offer原16题"><a href="#58-数值的整数次方-剑指offer原16题" class="headerlink" title="58.数值的整数次方(剑指offer原16题)"></a>58.数值的整数次方(剑指offer原16题)</h4><ul><li>解题思路：注意处理次方是负数的情况即可！  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span>(<span class="params"><span class="keyword">double</span> <span class="keyword">base</span>, <span class="keyword">int</span> exponent</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; abs(exponent); i++)&#123;</span><br><span class="line">            res *= <span class="keyword">base</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>) res = <span class="number">1</span> / res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="59-在O-1-的时间复杂度内删除链表结点（剑指offer原18题—题目一）"><a href="#59-在O-1-的时间复杂度内删除链表结点（剑指offer原18题—题目一）" class="headerlink" title="59.在O(1)的时间复杂度内删除链表结点（剑指offer原18题—题目一）"></a>59.在O(1)的时间复杂度内删除链表结点（剑指offer原18题—题目一）</h4><ul><li>解题思路：此题不能使用常规方法！因为要删除的结点不是链表的最后一个结点，所以下一个结点一定不是空结点。删除的方法是：<strong>用下一个结点的值去覆盖当前结点的值，然后将下一个结点的值删掉</strong>。这种方法就不需要用到前驱结点了。  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(int x): val(x), next(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void deleteNode(ListNode* <span class="keyword">node</span><span class="title">)&#123;</span></span><br><span class="line"><span class="title">        node-</span>&gt;val = <span class="keyword">node</span><span class="title">-&gt;next-</span>&gt;val;</span><br><span class="line">        <span class="keyword">node</span><span class="title">-&gt;next</span> = <span class="keyword">node</span><span class="title">-&gt;next-</span>&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="60-删除链表中重复的结点（剑指offer原18题—题目二）"><a href="#60-删除链表中重复的结点（剑指offer原18题—题目二）" class="headerlink" title="60.删除链表中重复的结点（剑指offer原18题—题目二）"></a>60.删除链表中重复的结点（剑指offer原18题—题目二）</h4><ul><li>解题思路：<strong>建议凡是可能会把头结点删掉的链表问题，一般来说都会增加一个虚拟头结点来简化代码</strong>。使用两个指针，第一个指针p指向上一次保留的结点的最后一个位置，q指向的是下一段的第一个结点，q用来扫描下一段的所有结点。  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode* <span class="keyword">next</span>;</span><br><span class="line">    ListNode(int x): val(x), <span class="keyword">next</span>(nullptr)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Solution&#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    ListNode* deleteDuplication(ListNode* head)&#123;</span><br><span class="line">        auto dummy = new ListNode(-<span class="number">1</span>);</span><br><span class="line">        dummy-&gt;<span class="keyword">next</span> = head;</span><br><span class="line"></span><br><span class="line">        auto p = dummy;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;<span class="keyword">next</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            auto q = p-&gt;<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">while</span>(q &amp;&amp; p-&gt;<span class="keyword">next</span>-&gt;val == q-&gt;val)&#123;</span><br><span class="line">                q = q-&gt;<span class="keyword">next</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            if(p-&gt;<span class="keyword">next</span>-&gt;<span class="keyword">next</span> == q) p = p-&gt;<span class="keyword">next</span>;   <span class="regexp">//</span> 下一段的长度是<span class="number">1</span>，没有重复结点，不用删</span><br><span class="line">            else p-&gt;<span class="keyword">next</span> = q;   <span class="regexp">//</span> 下一段的长度超过<span class="number">1</span>，则删除重复结点</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="61-正则表达式的匹配（剑指offer原19题）"><a href="#61-正则表达式的匹配（剑指offer原19题）" class="headerlink" title="61.正则表达式的匹配（剑指offer原19题）"></a>61.正则表达式的匹配（剑指offer原19题）</h4><ul><li>题目：实现一个函数用来匹配包括.和*的正则表达式。字符.表示任意一个字符；字符*表示它前面的字符可以出现任意次（含0次）。</li><li>解题思路：<strong>动态规划问题</strong>。状态表示f[i][j]:s[i,…]和p[j,…]是相匹配的；状态转移：情况1：如果p[j]是正常字符，则f[i][j] = s[i] == p[j] &amp;&amp; f[i + 1][j + 1]；情况2：p[j]是.，f[i][j] = f[i + 1][j + 1]；情况3：p[j + 1] = *，*表示的字符是0次或*表示的字符匹配1次，则f[i][j] = f[i][j + 2] || f[i + 1][j]；边界问题：f[n][m] = true  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; f;</span><br><span class="line">    <span class="built_in">string</span> s, p;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">inMatch</span><span class="params">(<span class="built_in">string</span> _s, <span class="built_in">string</span> _p)</span></span>&#123;</span><br><span class="line">        s = _s, p = _p;</span><br><span class="line">        n = s.size(), m = p.size();</span><br><span class="line">        f = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x][y] != <span class="number">-1</span>) <span class="keyword">return</span> f[x][y];</span><br><span class="line">        <span class="keyword">if</span>(y == m)</span><br><span class="line">            <span class="keyword">return</span> f[x][y] = x == n;</span><br><span class="line">        <span class="keyword">bool</span> first_match = x &lt; n &amp;&amp; (p[y] == <span class="string">'.'</span> || s[x] == p[y]);  <span class="comment">// 情况1和情况2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(y + <span class="number">1</span> &lt; m &amp;&amp; p[y + <span class="number">1</span>] == <span class="string">'*'</span>)&#123;  <span class="comment">// 情况3</span></span><br><span class="line">            f[x][y] = dp(x, y + <span class="number">2</span>) || dp(x + <span class="number">1</span>, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[x][y] = first_match &amp;&amp; dp(x + <span class="number">1</span>, y + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="62-表示数值的字符串（剑指offer原20题）"><a href="#62-表示数值的字符串（剑指offer原20题）" class="headerlink" title="62.表示数值的字符串（剑指offer原20题）"></a>62.表示数值的字符串（剑指offer原20题）</h4><ul><li>解题思路：分各种情况讨论  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    bool isNumber(string s)&#123;</span><br><span class="line">        int i = <span class="number">0</span>, j = s.size();</span><br><span class="line">        /<span class="regexp">/ 删除字符串s中的前后空格</span></span><br><span class="line"><span class="regexp">        while(i &lt;= j &amp;&amp; s[i] == ' ') i++;</span></span><br><span class="line"><span class="regexp">        while(i &lt;= j &amp;&amp; s[j] == ' ') j--;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        if(i &gt; j) return false;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        s = s.substr(i, j - i + 1);</span></span><br><span class="line"><span class="regexp">        if(s[0] == '+' || s[0] == '-') s = s.substr(1);</span></span><br><span class="line"><span class="regexp">        if(s.empty() || (s[0] == '.' &amp;&amp; s.size() == 1)) return false;  /</span><span class="regexp">/ + - .</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        int dot = 0, e = 0;   /</span><span class="regexp">/ 统计有多少个.和e</span></span><br><span class="line"><span class="regexp">        for(int i = 0; i &lt; s.size(); i++)&#123;</span></span><br><span class="line"><span class="regexp">            if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9');</span></span><br><span class="line"><span class="regexp">            else if(s[i] == '.')&#123;</span></span><br><span class="line"><span class="regexp">                dot++;</span></span><br><span class="line"><span class="regexp">                if(dot &gt; 1 || e) return false;  /</span><span class="regexp">/ 3434.23232.4343, 23232e23232.2323</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            else if(s[i] == 'e' || s[i] == 'E')&#123;</span></span><br><span class="line"><span class="regexp">                e++;</span></span><br><span class="line"><span class="regexp">                if(!i || i + 1 == s.size() || e &gt; 1 || s[i - 1] == '.' &amp;&amp; i == 1) return false; /</span><span class="regexp">/ e1223233, 11232e, 1212e32323e</span></span><br><span class="line"><span class="regexp">                if(s[i + 1] == '+' || s[i + 1] == '-')&#123;</span></span><br><span class="line"><span class="regexp">                    if(i + 2 == s.size()) return false;   /</span><span class="regexp">/ 12341e+</span></span><br><span class="line"><span class="regexp">                    i++;</span></span><br><span class="line"><span class="regexp">                &#125;</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">            else return false;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        return true;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="63-调整数组顺序使奇数位于偶数前面（剑指offer原21题）"><a href="#63-调整数组顺序使奇数位于偶数前面（剑指offer原21题）" class="headerlink" title="63.调整数组顺序使奇数位于偶数前面（剑指offer原21题）"></a>63.调整数组顺序使奇数位于偶数前面（剑指offer原21题）</h4><ul><li>题目：输入一个数组，实现数组中数字的顺序，使得所有的奇数位于数组的前半部分；所有的偶数位于后半部分。</li><li>解题思路：使用双指针，一个指针从前往后，另一个指针从后往前。保证第一个指针前面全部是奇数，第二个指针前面全部是偶数。  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">class</span> Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    void reOrderArray(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">        int <span class="keyword">first</span> = <span class="number">0</span>, <span class="keyword">second</span> = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">first</span> &lt;= <span class="keyword">second</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">first</span> &lt;= <span class="keyword">second</span> &amp;&amp; nums[<span class="keyword">first</span>] % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">first</span>++;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">first</span> &lt;= <span class="keyword">second</span> &amp;&amp; nums[<span class="keyword">second</span>] % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">second</span><span class="comment">--;</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">first</span> &lt; <span class="keyword">second</span>) swap(nums[<span class="keyword">first</span>], nums[<span class="keyword">second</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="64-链表中倒数第k个节点（剑指offer原22题）"><a href="#64-链表中倒数第k个节点（剑指offer原22题）" class="headerlink" title="64.链表中倒数第k个节点（剑指offer原22题）"></a>64.链表中倒数第k个节点（剑指offer原22题）</h4><ul><li>解题思路：由于单链表不能从后往前遍历的，只能从前往后遍历。因此首先求出整个链表的长度n，求倒数第k个节点相当于求正序的n-k+1个节点，然后从前往后遍历到n-k+1个节点就可以了。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">findKthToTail</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p = head; p; p = p-&gt;next) n++;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> p = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k; i++) p = p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="65-链表中环的入口节点（剑指offer原23题）"><a href="#65-链表中环的入口节点（剑指offer原23题）" class="headerlink" title="65.链表中环的入口节点（剑指offer原23题）"></a>65.链表中环的入口节点（剑指offer原23题）</h4><ul><li>解题思路：<strong>使用快慢指针算法，用两个指针first和second分别从起点开始走，first每次走一步，second每次走两步。如果过程中second走到null，则说明不存在环；否则当first和second相遇后，让first返回起点，second待在原地不动，然后两个指针每次分别走一步，当相遇时，相遇点就是环的入口</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x): val(x), next(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">entryNodeOfLoop</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> i = head, j = head; <span class="comment">// i是慢指针，每次走一步;j是快指针，每次走两步</span></span><br><span class="line">        <span class="keyword">while</span>(i &amp;&amp; j)&#123;</span><br><span class="line">            i = i-&gt;next;</span><br><span class="line">            j = j-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(j) j = j-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;  <span class="comment">// i和j相遇了</span></span><br><span class="line">                i = head;  <span class="comment">// 慢指针i回到起点</span></span><br><span class="line">                <span class="keyword">while</span>(i != j)&#123; <span class="comment">// 慢指针和快指针同时向后移动一个位置</span></span><br><span class="line">                    i = i-&gt;next;</span><br><span class="line">                    j = j-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> i;   <span class="comment">// 环入口的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;  <span class="comment">// 无环存在</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="66-找出数组中重复的数字（剑指offer原3题—-题目一）"><a href="#66-找出数组中重复的数字（剑指offer原3题—-题目一）" class="headerlink" title="66.找出数组中重复的数字（剑指offer原3题—-题目一）"></a>66.找出数组中重复的数字（剑指offer原3题—-题目一）</h4><ul><li>解题思路：从前往后遍历整个数组中的每个元素，如果元素的取值不在0到n-1范围内，就直接返回-1；如果元素的取值在0到n-1范围内时，检查数组下标是取值为该元素时的数组位置上存储的是哪个数字；如果存储的数字与其在数组中对应的下标相等，则找出了重复的数字，否则将两个位置上的数字进行交换，重复此步骤，直到存储的数字与其在数组中对应的下标相等为止。  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    int duplicateInArray(vector&lt;int&gt;&amp; nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(auto x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= nums.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; nums.<span class="built_in">size</span>(); <span class="built_in">i</span>++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">i</span> != nums[<span class="built_in">i</span>] &amp;&amp; nums[nums[<span class="built_in">i</span>]] != nums[<span class="built_in">i</span>]) swap(nums[<span class="built_in">i</span>], nums[nums[<span class="built_in">i</span>]]);</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="built_in">i</span>] != <span class="built_in">i</span> &amp;&amp; nums[nums[<span class="built_in">i</span>]] == nums[<span class="built_in">i</span>]) <span class="keyword">return</span> nums[<span class="built_in">i</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="67-不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）"><a href="#67-不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）" class="headerlink" title="67.不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）"></a>67.不修改数组，找出数组中重复的数字（剑指offer原3题—-题目二）</h4><ul><li>解题思路：<strong>根据抽屉原理</strong>，至少有2个数字会重复！利用递归的思想，将这个数组一分为二，分别计算左右子数组两边的长度和元素的个数，至少有一边元素的个数会大于子数组的长度。递归上面的过程即可！  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duplicateInArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;  <span class="comment">// [l, mid], [mid + 1, r]</span></span><br><span class="line">            <span class="keyword">int</span> s = <span class="number">0</span>;  <span class="comment">// 统计元素的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) s += x &gt;= l &amp;&amp; x &lt;= mid;</span><br><span class="line">            <span class="keyword">if</span>(s &gt; mid - l + <span class="number">1</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="68-二维数组中的查找（剑指offer原4题）"><a href="#68-二维数组中的查找（剑指offer原4题）" class="headerlink" title="68.二维数组中的查找（剑指offer原4题）"></a>68.二维数组中的查找（剑指offer原4题）</h4><ul><li>解题思路：从二维数组右上角的位置开始查找，如果要查找的目标数字比右上角的数字要大，则目标数字出现在二维数组的右下角位置；如果要查找的目标数字比右上角的数字要小，则目标数字出现在二维数组的左上角位置。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty() || <span class="built_in">array</span>[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">array</span>[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; <span class="built_in">array</span>.size() &amp;&amp; j &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &gt; target) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="69-替换空格（剑指offer原5题）"><a href="#69-替换空格（剑指offer原5题）" class="headerlink" title="69.替换空格（剑指offer原5题）"></a>69.替换空格（剑指offer原5题）</h4><ul><li>解题思路：开一个新的字符串，遍历原始的字符串，如果遇到空格字符，就将20%存储在新字符串中；否则，直接存储在新字符串中。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">replaceSpaces</span><span class="params">(<span class="built_in">string</span>&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : str)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == <span class="string">' '</span>)</span><br><span class="line">                res += <span class="string">"20%"</span>;</span><br><span class="line">            <span class="keyword">else</span> res += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="70-从尾到头打印链表（剑指offer原6题）"><a href="#70-从尾到头打印链表（剑指offer原6题）" class="headerlink" title="70.从尾到头打印链表（剑指offer原6题）"></a>70.从尾到头打印链表（剑指offer原6题）</h4><ul><li>解题思路：先将整个链表遍历一遍，然后将整个链表翻转一下即可。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListReversingly(ListNode* head)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            res.push_back(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res.rbegin(), res.rend());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="71-重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）"><a href="#71-重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）" class="headerlink" title="71.重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）"></a>71.重建二叉树（根据前序遍历和中序遍历来重建二叉树）（剑指offer原7题）</h4><ul><li>解题思路：首先，根据前序遍历确定当前区间的根节点是哪个；然后，根据已经确定的根节点，从中序遍历中找到根节点的位置在哪，从而确定二叉树的左右子树中分别包含的数字；最后，在已经确定的左右子树中递归执行前面的两个步骤，即可重建二叉树。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x): val(x), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash;   <span class="comment">// 开一个hash表，记录每个节点在数组中的位置</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder, inorder;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; _preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; _inorder)</span></span>&#123;</span><br><span class="line">        preorder = _preorder, inorder = _inorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.size(); i++)&#123;</span><br><span class="line">            hash[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, preorder.size() - <span class="number">1</span>, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pl, <span class="keyword">int</span> pr, <span class="keyword">int</span> il, <span class="keyword">int</span> ir)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pl &gt; pr) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> TreeNode(preorder[pl]);</span><br><span class="line">        <span class="keyword">int</span> k = hash[inorder[root-&gt;val]];</span><br><span class="line">        <span class="keyword">auto</span> left = dfs(pl + <span class="number">1</span>, pl + <span class="number">1</span> + k - il - <span class="number">1</span>, il, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> right = dfs(pl + k - il + <span class="number">1</span>, pr, k + <span class="number">1</span>, ir);</span><br><span class="line">        root-&gt;left = left;</span><br><span class="line">        root-&gt;right = right;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="72-二叉树的下一个节点（剑指offer原8题）"><a href="#72-二叉树的下一个节点（剑指offer原8题）" class="headerlink" title="72.二叉树的下一个节点（剑指offer原8题）"></a>72.二叉树的下一个节点（剑指offer原8题）</h4><ul><li>题目：给定二叉树中的一个节点，找出<strong>中序遍历序列</strong>的下一个节点</li><li>解题思路：分情况进行讨论，情况1：如果给定的节点是存在右子树的，则下一个节点是右子树中最左边的节点；情况2：如果给定的节点是不存在右子树的，又分两种情况讨论：a.如果给定的节点存在父节点，并且给定的节点是父节点的左儿子的话，则下一个节点是给定节点的父节点；b.如果给定的节点存在父节点，并且给定的节点是父节点的右儿子的话，此时沿着父节点向上找，直到找到第一个节点是当前父节点的左儿子时停止，返回父节点。  <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* inorderSuccessor(TreeNode* p)&#123;</span><br><span class="line">        <span class="function"><span class="title">if</span>(p-&gt;</span>right)&#123;  <span class="comment">// 情况1</span></span><br><span class="line">            <span class="function"><span class="title">p</span> = p-&gt;</span>right;</span><br><span class="line">            <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">left</span>) p = p-&gt;</span>left;</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况2</span></span><br><span class="line">        <span class="function"><span class="title">while</span>(p-&gt;</span><span class="function"><span class="title">father</span> &amp;&amp; p == p-&gt;</span><span class="function"><span class="title">father</span>-&gt;</span><span class="function"><span class="title">right</span>) p = p-&gt;</span>father;</span><br><span class="line">        <span class="function"><span class="title">return</span> p-&gt;</span>father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="73-用两个栈实现一个队列（剑指offer原9题）"><a href="#73-用两个栈实现一个队列（剑指offer原9题）" class="headerlink" title="73.用两个栈实现一个队列（剑指offer原9题）"></a>73.用两个栈实现一个队列（剑指offer原9题）</h4><ul><li>解题思路：先将元素依次压入栈1中，然后逐个弹出栈1中的元素，将每个元素依次压入栈2中。此时，<strong>栈2中的栈顶元素就是栈1中的栈底元素</strong>，再依次弹出栈2中的元素时，就实现了队列的先进先出功能（最先进入栈1中的元素，最先从栈2中弹出）。  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyQueue&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stk, cache;</span><br><span class="line"></span><br><span class="line">    MyQueue()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">push</span>(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        stk.<span class="keyword">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">copy</span>(stack&lt;<span class="keyword">int</span>&gt;&amp; a, stack&lt;<span class="keyword">int</span>&gt;&amp; b)&#123;</span><br><span class="line">        <span class="keyword">while</span>(a.<span class="keyword">size</span>())&#123;</span><br><span class="line">            b.<span class="keyword">push</span>(a.top());</span><br><span class="line">            a.<span class="keyword">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">pop</span>()&#123;</span><br><span class="line">        <span class="keyword">copy</span>(stk, cache);</span><br><span class="line">        <span class="keyword">int</span> res = cache.top();</span><br><span class="line">        cache.<span class="keyword">pop</span>();</span><br><span class="line">        <span class="keyword">copy</span>(cache, stk);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> peak()&#123;</span><br><span class="line">        <span class="keyword">copy</span>(stk, cache);</span><br><span class="line">        <span class="keyword">int</span> res = cache.top();</span><br><span class="line">        <span class="keyword">copy</span>(cache, stk);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty()&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="74-斐波那契数列数列（剑指offer原10题）"><a href="#74-斐波那契数列数列（剑指offer原10题）" class="headerlink" title="74.斐波那契数列数列（剑指offer原10题）"></a>74.斐波那契数列数列（剑指offer原10题）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = a + b;</span><br><span class="line">            a = b, b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="75-旋转数组的最小数字（剑指offer原11题）"><a href="#75-旋转数组的最小数字（剑指offer原11题）" class="headerlink" title="75.旋转数组的最小数字（剑指offer原11题）"></a>75.旋转数组的最小数字（剑指offer原11题）</h4><ul><li>解题思路：利用<strong>画图法</strong>来解决。输入数组是0 1 2 2 2 2 3 4 5,则旋转后的数组是2 2 3 4 5 0 1 2 2。将旋转数组分成两部分2 2 3 4 5和0 1 2 2，两部分是单调的增加。首先将后半部分相同值删除，然后观察剩下的结果可知，所有的元素都比前半部分的第一个元素小。前半部分中后面的值都大于或等于第一个元素。<strong>下面就可以使用二分法，找出后半部分中第一个比前半部分第一个元素小的那个数字，就是我们要找的最小数字</strong>。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span> &amp;&amp; nums[n] == nums[<span class="number">0</span>]) n--;  <span class="comment">// 去掉后半部分相等的数值</span></span><br><span class="line">        <span class="keyword">if</span>(nums[n] &gt;= nums[<span class="number">0</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[<span class="number">0</span>]) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="76-矩阵中的路径（剑指offer原12题）"><a href="#76-矩阵中的路径（剑指offer原12题）" class="headerlink" title="76.矩阵中的路径（剑指offer原12题）"></a>76.矩阵中的路径（剑指offer原12题）</h4><ul><li>解题思路：先枚举所有起点，然后枚举方向。直到走到不能走为止，这样就得到所有的路径。  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">public:</span><br><span class="line">    bool hasPath(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;char&gt;&gt;&amp; <span class="keyword">matrix</span>, <span class="keyword">string</span> str)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">matrix</span>.<span class="keyword">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">matrix</span>[<span class="number">0</span>].<span class="keyword">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(<span class="keyword">matrix</span>, str, <span class="number">0</span>, i, j))  <span class="comment">// 枚举所有起点i, j，从字符串str第0个字符串开始枚举</span></span><br><span class="line">                    <span class="keyword">return</span> true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool dfs(<span class="keyword">vector</span>&lt;<span class="keyword">vector</span>&lt;char&gt;&gt;&amp; <span class="keyword">matrix</span>, <span class="keyword">string</span>&amp; str, <span class="keyword">int</span> u, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123; <span class="comment">// 当前字符串str中的第几个字符u，x和y是当前路径的坐标</span></span><br><span class="line">        <span class="keyword">if</span>(u == str.<span class="keyword">size</span>()) <span class="keyword">return</span> true;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">matrix</span>[x][y] != str[u]) <span class="keyword">return</span> false;</span><br><span class="line">        <span class="comment">// 枚举四个方向</span></span><br><span class="line">        <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        char t = <span class="keyword">matrix</span>[x][y];  <span class="comment">// 已经访问过的字符，不能重新访问</span></span><br><span class="line">        <span class="keyword">matrix</span>[x][y] = <span class="string">'*'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = x + dx[i], b = y + dx[i];</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="keyword">matrix</span>.<span class="keyword">size</span>() &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; <span class="keyword">matrix</span>[a].<span class="keyword">size</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(<span class="keyword">matrix</span>, str, u + <span class="number">1</span>, a, b)) <span class="keyword">return</span> true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">matrix</span>[x][y] = t;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-滑动窗口的最大值（剑指offer原59题）&quot;&gt;&lt;a href=&quot;#1-滑动窗口的最大值（剑指offer原59题）&quot; class=&quot;headerlink&quot; title=&quot;1.滑动窗口的最大值（剑指offer原59题）&quot;&gt;&lt;/a&gt;1.滑动窗口的最大值（剑指offe
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://cdlwhm1217096231.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指Offer" scheme="https://cdlwhm1217096231.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>C++中的基本变量类型介绍</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的基本变量类型介绍/</id>
    <published>2019-08-09T08:11:06.000Z</published>
    <updated>2019-08-09T08:19:07.447Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-cpp变量类型"><a href="#1-cpp变量类型" class="headerlink" title="1.cpp变量类型"></a>1.cpp变量类型</h3><ul><li>变量实际上是存储空间的名称，cpp中每个变量都有指定的类型，类型决定变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可以作用在变量上。</li><li>变量名可以是字母 数字 下划线组成，必须以字母或下划线开头。区分大小写</li><li>几种基本的变量类型：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni0xNjBmODg4YzdlMDJiNGZjLnBuZw" alt="基本的变量类型.png"><h3 id="2-cpp中的变量定义"><a href="#2-cpp中的变量定义" class="headerlink" title="2.cpp中的变量定义"></a>2.cpp中的变量定义</h3></li><li><p>变量定义就是<strong>告诉编译器在何处创建变量的存储，以及如何创建变量的存储</strong>。变量的定义指定一个数据类型，并包含该类型的一个或多个变量的列表，例如：</p>  <figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">格式：<span class="keyword">type</span> variable_list;</span><br></pre></td></tr></table></figure></li><li><p>type必须是基本数据类型或用户自定义的数据类型(如 类)，variable_list可以由一个或多个标识符名称组成，<strong>多个标识符之间用逗号分隔</strong>，例如：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, k;  <span class="comment">// 声明并定义了变量i, j, k,指示编译器创建类型为int的名为i,j,k的变量</span></span><br><span class="line"><span class="keyword">char</span> c, d, e;</span><br><span class="line"><span class="keyword">float</span> f, ss;</span><br><span class="line"><span class="keyword">double</span> d;</span><br></pre></td></tr></table></figure></li><li><p>变量可以在声明的时候被初始化，初始化器由一个等号后跟一个常量表达式组成,例如：</p>  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">格式:  type variable_name = <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> d = <span class="number">3</span>, f = <span class="number">6</span>;  <span class="comment">// d 和 f 的声明</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">3</span>, f = <span class="number">5</span>;  <span class="comment">// 定义并初始化 d 和 f</span></span><br><span class="line"><span class="keyword">byte</span> z = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">char</span> x = <span class="string">'x'</span>;</span><br></pre></td></tr></table></figure></li><li><p>不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的</p><h3 id="3-cpp中的变量声明"><a href="#3-cpp中的变量声明" class="headerlink" title="3.cpp中的变量声明"></a>3.cpp中的变量声明</h3></li><li>变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。<strong>变量声明只在编译时有它的意义</strong>，在程序连接时编译器需要实际的变量声明。</li><li><p>当使用多个文件且<strong>只在其中一个文件中定义变量时</strong>（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 变量的定义</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="comment">// 实际初始化</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量的声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a, b;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> c;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span> f;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 变量的定义</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="comment">// 实际初始化</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    <span class="keyword">int</span> i = func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-cpp中的左值和右值"><a href="#4-cpp中的左值和右值" class="headerlink" title="4.cpp中的左值和右值"></a>4.cpp中的左值和右值</h3><ul><li>cpp中的两种类型的表达式：<ul><li>左值：<strong>指向内存位置的表达式被称为左值（lvalue）表达式</strong>。左值可以出现在赋值号的左边或右边。</li><li>右值：<strong>存储在内存中某些地址的数值</strong>。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。</li></ul></li><li>变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int g = <span class="number">20</span>;</span><br><span class="line"><span class="number">10</span> = <span class="number">20</span>;  报错！</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-变量的类型转换"><a href="#5-变量的类型转换" class="headerlink" title="5.变量的类型转换"></a>5.变量的类型转换</h3><ul><li><p>变量的类型间是可以互相转换的，转换又分为自动转换和强制转换。</p><ul><li><p>自动转换规则</p><ul><li>若参与运算量的类型不同，则先转换成同一类型，然后进行运算。</li><li>转换按数据长度增加的方向进行，以保证精度不降低。如int型和long型运算时，先把int型转成long型后再进行运算。<ul><li>a、若两种类型的字节数不同，转换成字节数高的类型</li><li>b、若两种类型的字节数相同，且一种有符号，一种无符号，则转换成无符号类型</li></ul></li><li>所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。</li><li>char型和short型参与运算时，必须先转换成int型。</li><li>在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。如果右边量的数据类型长度比左边长时，将丢失一部分数据，这样会降低精度:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> aa = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> bb = <span class="number">2.1</span>;</span><br><span class="line">aa = bb;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"aa = "</span> &lt;&lt; aa &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为 2，丢失小数部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为a + b = 3.1</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>强制转换规则</p><ul><li>强制类型转换是通过类型转换运算来实现的。其一般形式为：<strong>（类型说明符）表达式</strong>其功能是把表达式的运算结果强制转换成类型说明符所表示的类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">2.1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a + b = "</span> &lt;&lt; a + (<span class="keyword">int</span>)b &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出为a + b = 3</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="6-变量定义与声明的区别"><a href="#6-变量定义与声明的区别" class="headerlink" title="6.变量定义与声明的区别"></a>6.变量定义与声明的区别</h3><ul><li>定义包含了声明，但是声明不包含定义,<strong>变量声明是不会为变量开辟内存空间的</strong>,只有当声明也是定义时，声明才可以有初始化，初始化必须有存储空间来进行初始化。如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;     <span class="comment">//定义并声明了变量 a</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;  <span class="comment">//只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-cpp变量类型&quot;&gt;&lt;a href=&quot;#1-cpp变量类型&quot; class=&quot;headerlink&quot; title=&quot;1.cpp变量类型&quot;&gt;&lt;/a&gt;1.cpp变量类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;变量实际上是存储空间的名称，cpp中每个变量都有指定的类型，类型决定变量
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的基本数据类型介绍</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的基本数据类型介绍/</id>
    <published>2019-08-09T08:08:54.000Z</published>
    <updated>2019-08-09T08:09:33.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-cpp中的基本内置数据类型（7种）"><a href="#1-cpp中的基本内置数据类型（7种）" class="headerlink" title="1.cpp中的基本内置数据类型（7种）"></a>1.cpp中的基本内置数据类型（7种）</h3><ul><li>bool  char  int float double void(无类型) wchar_t(宽字符型)：typedef wchar_t short int;</li><li>一个基本类型可以被一个或多个类型修饰符来修饰。<ul><li>signed</li><li>unsigned</li><li>short</li><li>long</li></ul></li><li>下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值(<strong>变量的大小会根据编译器和所使用的电脑而有所不同</strong>)<br><img src="https://upload-images.jianshu.io/upload_images/13407176-b102c5b08a016185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本数据类型.png"><h3 id="2-typedef声明"><a href="#2-typedef声明" class="headerlink" title="2.typedef声明"></a>2.typedef声明</h3></li><li><p>使用typedef为已有的类型取一个新的名字，语法如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：typedef<span class="built_in"> type </span>name;</span><br><span class="line">例如：typedef int feet;  feet是int的另一个名称</span><br><span class="line">     feet distance;  创建一个整型变量distance</span><br></pre></td></tr></table></figure></li><li><p>typedef 可以声明各种类型名，但不能用来定义变量。用 typedef 可以声明数组类型、字符串类型，使用比较方便。</p></li><li>用typedef只是对已经存在的类型增加一个类型名，而没有创造新的类型。</li><li>当在不同源文件中用到同一类型数据（尤其是像数组、指针、结构体、共用体等类型数据）时，常用 typedef 声明一些数据类型，把它们单独放在一个头文件中，然后在需要用到它们的文件中用 ＃include 命令把它们包含进来，以提高编程效率。</li><li>使用 typedef 有利于程序的通用与移植。有时程序会依赖于硬件特性，用 typedef 便于移植。</li><li><p>typedef 与 #define 的区别</p><ul><li><p>2.1 执行时间不同</p><ul><li>关键字 typedef 在编译阶段有效，由于是在编译阶段，因此 typedef 有类型检查的功能。</li><li>#define 则是宏定义，发生在预处理阶段，也就是编译之前，它只进行简单而机械的字符串替换，而不进行任何检查<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    UINT value = <span class="string">"abc"</span>;  <span class="comment">// 类型检测，将会报错</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x) x*x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>, b = <span class="number">2</span>, c;</span><br><span class="line">    c = f(a) / f(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>2.2 功能上的差异</p><ul><li>typedef 用来定义类型的别名，定义与平台无关的数据类型，与 struct 的结合使用等。</li><li>#define 不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</li></ul></li><li><p>2.3 作用域不同</p><ul><li>#define 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用。而 typedef 有自己的作用域。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宏的作用域</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> HW <span class="meta-string">"helloworld"</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = HW;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// typedef的作用域</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// UNIT uvalue = 5;  报错！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">        UINT uvalueA;</span><br><span class="line">        A(): uvalueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">        <span class="comment">// UINT uvalueB;  报错</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 在B类中使用UINT会出错，因为UINT只在类A的作用域中。</span></span><br><span class="line">    <span class="comment">// 此外，在类中用typedef定义的类型别名还具有相应的访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AA</span>&#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">        UINT valueA;</span><br><span class="line">        AA(): valueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// AA::UINT i = 1;报错，在typedef前加上public权限则可以</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>2.4 对指针的操作——二者修饰指针类型时，作用不同</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* pint;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINT int*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> pint p1 = &amp;i1;  <span class="comment">// 等价于int * const p;指针常量:指针p是一个常量,p不可更改，p指向的内容可以更改</span></span><br><span class="line"><span class="keyword">const</span> PINT p2 = &amp;i2;  <span class="comment">// 等价于const int *p/int const *p，p可以更改，p指向的内容不可更改，常量指针</span></span><br><span class="line"></span><br><span class="line">pint s1, s2;  <span class="comment">// s1 和 s2都是int类型指针</span></span><br><span class="line">PINT s3, s4;  <span class="comment">// 相当于 int * s3, s4;只有一个是指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// p1 = &amp;i2; 指针常量p1不能被修改</span></span><br><span class="line">    *p1 = <span class="number">5</span>;   <span class="comment">// 但是p1指向的内容可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// *p2 = 5; 常量指针p2能被修改</span></span><br><span class="line">    p2 = &amp;i1;   <span class="comment">// 但是p2指向的内容不可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-枚举类型"><a href="#3-枚举类型" class="headerlink" title="3.枚举类型"></a>3.枚举类型</h3><ul><li>枚举类型是cpp中的一种派生数据类型，是由用户定义的若干枚举常量的集合</li><li>如果一个变量只有几种可能的值，可以定义为枚举类型。“枚举”就是将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</li><li><p>创建枚举，需要用到关键字enum，枚举类型的一般形式为:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名&#123;</span></span><br><span class="line">    标识符[=整型常量];</span><br><span class="line">    标识符[=整型常量];</span><br><span class="line">    ....</span><br><span class="line">    标识符[=整型常量];</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure></li><li><p>如果枚举没有初始化，即省略掉’=整型常数’时,则从第一个标识开始，如下面的例子，变量c的类型是color,最后被赋值为blue。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>&#123;</span></span><br><span class="line">    red, green, blue</span><br><span class="line">&#125; c;</span><br><span class="line">c = blue;</span><br></pre></td></tr></table></figure></li><li><p>默认情况下，第一个名称的值是0，第二个名称的值是1，第三个名称的值是2，依次类推。可以在定义枚举类型时，对枚举元素赋值。此时，赋值的枚举值为所赋的值，而其他没有赋值的枚举值在为前一个枚举值加1，例如下面：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span>&#123;</span></span><br><span class="line">    red, greed = <span class="number">5</span>, blue</span><br><span class="line">&#125;;</span><br><span class="line">blue = <span class="number">6</span>,默认情况下，每个名称都会比前一个名称大，但red的值仍然是<span class="number">0</span>.</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-相关代码"><a href="#4-相关代码" class="headerlink" title="4.相关代码"></a>4.相关代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"limits"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> f(x)  x*x  <span class="comment">// 宏定义</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 typedef执行时间不同</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// UINT value = "abc";  类型检测，将出错</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; value &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 作用域不同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> HW <span class="meta-string">"helloworld"</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = HW;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// typedef的作用域</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// UNIT uvalue = 5;  报错！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">    UINT uvalueA;</span><br><span class="line">    A(): uvalueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="comment">// UINT uvalueB;  报错</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 在B类中使用UINT会出错，因为UINT只在类A的作用域中。</span></span><br><span class="line"><span class="comment">// 此外，在类中用typedef定义的类型别名还具有相应的访问权限</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span>&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> UINT;</span><br><span class="line">    UINT valueA;</span><br><span class="line">    AA(): valueA(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// AA::UINT i = 1;报错，在typedef前加上public权限则可以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 对指针的操作---二者修饰指针类型时，作用不同</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* pint;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PINT int*</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> pint p1 = &amp;i1;  <span class="comment">// 等价于int * const p;指针常量:指针p是一个常量,p不可更改，p指向的内容可以更改</span></span><br><span class="line"><span class="keyword">const</span> PINT p2 = &amp;i2;  <span class="comment">// 等价于const int *p/int const *p，p可以更改，p指向的内容不可更改，常量指针</span></span><br><span class="line"></span><br><span class="line">pint s1, s2;  <span class="comment">// s1 和 s2都是int类型指针</span></span><br><span class="line">PINT s3, s4;  <span class="comment">// 相当于 int * s3, s4;只有一个是指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestPointer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// p1 = &amp;i2; 指针常量p1不能被修改</span></span><br><span class="line">    *p1 = <span class="number">5</span>;   <span class="comment">// 但是p1指向的内容可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p1:"</span> &lt;&lt; p1 &lt;&lt; <span class="string">" *p1 = "</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// *p2 = 5; 常量指针p2能被修改</span></span><br><span class="line">    p2 = &amp;i1;   <span class="comment">// 但是p2指向的内容不可以修改</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"p2:"</span> &lt;&lt; p2 &lt;&lt; <span class="string">" *p2 = "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> color&#123;</span><br><span class="line">    red, green, blue=<span class="number">5</span>, yellow</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"bool: "</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"char: "</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed char: "</span> &lt;&lt; <span class="string">"所占字节数："</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"short int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned short int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed short int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">short</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"signed long  int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsigned long  int: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"float: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"double: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"long double: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"wchar_t: "</span> &lt;&lt; <span class="string">"所占的字节数: "</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> feet;   <span class="comment">// typedef声明,但typedef int feet = 100;错误！</span></span><br><span class="line">    feet distance;</span><br><span class="line">    <span class="comment">// 1 宏定义执行时间不同</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>, b = <span class="number">6</span>, c;</span><br><span class="line">    c = f(a) / f(b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TestPointer();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"red = "</span> &lt;&lt; red &lt;&lt; <span class="string">" yellow = "</span> &lt;&lt; yellow &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 枚举类型举例</span></span><br><span class="line">    <span class="keyword">enum</span> days&#123;</span><br><span class="line">        one, two, three</span><br><span class="line">    &#125;day;</span><br><span class="line">    day = one;</span><br><span class="line">    <span class="keyword">switch</span>(day)&#123;</span><br><span class="line">        <span class="keyword">case</span> one:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"one"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> two:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"two"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"默认输出"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-cpp中的基本内置数据类型（7种）&quot;&gt;&lt;a href=&quot;#1-cpp中的基本内置数据类型（7种）&quot; class=&quot;headerlink&quot; title=&quot;1.cpp中的基本内置数据类型（7种）&quot;&gt;&lt;/a&gt;1.cpp中的基本内置数据类型（7种）&lt;/h3&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的参数传递方式：传值、传地址、传引用总结</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BC%A0%E5%80%BC%E3%80%81%E4%BC%A0%E5%9C%B0%E5%9D%80%E3%80%81%E4%BC%A0%E5%BC%95%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的参数传递方式：传值、传地址、传引用总结/</id>
    <published>2019-08-09T08:07:01.000Z</published>
    <updated>2019-08-09T08:08:17.786Z</updated>
    
    <content type="html"><![CDATA[<ul><li>指针：指针是一个变量，只不过这个变量中存储的是一个地址，指向内存中的一个单元。</li><li>引用：引用和原变量是同一个东西，只不过是原变量的一个别名。  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">10</span><span class="comment">;  定义一个整型变量a</span></span><br><span class="line">int *p = &amp;a<span class="comment">;  定义一个指向整型变量的指针变量p，该指针指向a的存储单元，即p的值是a存储单元的地址</span></span><br><span class="line">int &amp;<span class="keyword">b </span>= a<span class="comment">;   定义一个整型变量a的引用，a和b是同一个东西，在内存中占用同一个存储单元</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="一、引用的特性："><a href="#一、引用的特性：" class="headerlink" title="一、引用的特性："></a>一、引用的特性：</h3><ul><li>引用在定义时必须初始化</li><li>一个变量可以有多个引用</li><li>引用一旦绑定某个实体，就不能再是其他变量的引用。</li></ul><h3 id="二、引用和指针的区别与联系："><a href="#二、引用和指针的区别与联系：" class="headerlink" title="二、引用和指针的区别与联系："></a>二、引用和指针的区别与联系：</h3><ul><li>1.相同点：<ul><li>底层的实现方式相同，都是按照指针的方式实现的</li></ul></li><li>2.不同点：<ul><li>引用定义的时候必须初始化，指针可以不用初始化；</li><li>引用一旦初始化为指向一个对象，就不能再指向其他对象，而指针可以在任何时候指向任何一个同类型的对象；</li><li>没有空引用，但是有空指针；</li><li>在sizeof中的含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节的个数(在32为平台下，指针求sizeof永远是4)；</li><li>引用++改变的是变量的内容，指针++改变的是指针的指向；</li><li>有多级指针，没有多级引用；</li><li>引用使用起来比指针安全；</li><li>如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；<h3 id="三、传值、传地址、传引用的区别，哪个更高效？"><a href="#三、传值、传地址、传引用的区别，哪个更高效？" class="headerlink" title="三、传值、传地址、传引用的区别，哪个更高效？"></a>三、传值、传地址、传引用的区别，哪个更高效？</h3></li></ul></li><li>1.传值<ul><li>这种传递方式中，实参和形参是两个不同的地址空间，参数传递的实质是将原函数中变量的值，复制到被调用函数形参所在的存储空间中，这个形参的地址空间在函数执行完毕后，会被回收掉。整个被调用函数对形参的操作，只影响形参对应的地址空间，不影响原函数中变量的值，因为这两个不是同一个存储空间。<br><strong>即使形参的值在函数中发生了变化，实参的值也完全不会受到影响，仍为调用前的值。</strong></li></ul></li><li>2.传地址<ul><li>这种传递方式中，实参是变量的地址，形参是指针类型的变量，在函数中对指针变量的操作，就是对实参（变量地址）所对应的变量的操作，函数调用结束后，原函数中的变量的值将会发生改变。<br><strong>被调用函数中对形参指针所指向的地址中内容的任何改变都会影响到实参。</strong></li></ul></li><li>3.传引用<ul><li>这种传递方式中，形参是引用类型变量，其实就是实参的一个别名，在被调用函数中，对引用变量的所有操作等价于对实参的操作。这样，整个函数执行完毕后，原先的实参的值将会发生改变。<br><strong>被调函数对形参做的任何操作都影响了主调函数中的实参变量。</strong></li></ul></li><li>4.哪种更高效？<ul><li>在内置类型当中三种传递方式的效率上都差不多；</li><li>在自定义类型当中，传引用方式效率的更高效一些，因为它没有对形参进行一次拷贝<h3 id="四、常引用"><a href="#四、常引用" class="headerlink" title="四、常引用"></a>四、常引用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;  等价于 <span class="keyword">int</span> *<span class="keyword">const</span> b = a;即引用是一个指针常量（又称常指针，即一个常量，其类型是指针）</span><br><span class="line">常引用：<span class="keyword">const</span> <span class="keyword">int</span> &amp;a=b;等价于<span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> a=b;不仅仅是a这个地址不可修改，而且其指向的内存空间也不可修改。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="五、引用的使用场景"><a href="#五、引用的使用场景" class="headerlink" title="五、引用的使用场景"></a>五、引用的使用场景</h3><ul><li><p>1.给变量起别名</p>  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a<span class="comment">;</span></span><br><span class="line">int &amp;<span class="keyword">b </span>= a<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>2.将引用作为函数的参数</p><ul><li>使用引用类型就不必在swap中声明形参是指针变量，指针变量要另外开辟内存单元，其内容是地址。而引用变量不是一个独立的变量，不单独占内存单元。而且在调用swap函数时，只需要传值即可，将引用作为函数的形参更加简单、直观、方便。  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">swap(int </span>&amp;a, int &amp;<span class="keyword">b)</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   int temp<span class="comment">;</span></span><br><span class="line">    temp = a<span class="comment">;</span></span><br><span class="line">    a = <span class="keyword">b;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">b </span>= temp<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>3.返回值</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> _iLeft, <span class="keyword">int</span> _iRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _iLeft + _iRight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引用返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">Add</span><span class="params">(<span class="keyword">int</span> &amp; _iLeft, <span class="keyword">int</span>&amp; _iRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> iResult = _iLeft + _iRight;</span><br><span class="line"><span class="keyword">return</span> iResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="六、代码实例"><a href="#六、代码实例" class="headerlink" title="六、代码实例"></a>六、代码实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_value</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_pointer</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_reference</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++的函数参数传递方式，可以是传值方式，也可以是传引用方式。</span></span><br><span class="line"><span class="comment">传值的本质是：形参是实参的一份复制。</span></span><br><span class="line"><span class="comment">传引用的本质是：形参和实参是同一个东西。</span></span><br><span class="line"><span class="comment">传值和传引用，对大多数常见类型都是适用的。指针、数组，它们都是数据类型的一种，没啥特殊的</span></span><br><span class="line"><span class="comment">因此,指针作为函数参数传递时，也区分为传值和传引用两种方式。</span></span><br><span class="line"><span class="comment">void fun_1(int a); int类型，传值(复制产生新的变量)</span></span><br><span class="line"><span class="comment">void fun_2(int &amp;a); int类型，传引用(形参和实参是同一个东西)</span></span><br><span class="line"><span class="comment">void fun_3(int *pi); 指针类型，传值(复制产生新的变量)</span></span><br><span class="line"><span class="comment">void fun_4(int *&amp;pi); 指针类型，传引用(形参和实参是同一个东西)</span></span><br><span class="line"><span class="comment">如果希望通过将参数传递到函数中，从而来改变变量的值（比如变量是T a，T表示类型)，</span></span><br><span class="line"><span class="comment">则可以有这2种方式选择：</span></span><br><span class="line"><span class="comment">    1.传a的引用： void my_fun(T &amp;a);</span></span><br><span class="line"><span class="comment">    2.传a的地址： void my_fun(T *a);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (1) 值传递</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">形参意思是被调用函数的参数/变量，实参意思是主调函数中放到括号中的参数/变量。</span></span><br><span class="line"><span class="comment">传值方式下，形参是实参的拷贝：重新建立了变量，变量取值和实参一样。</span></span><br><span class="line"><span class="comment">即实参a和b的值为20和10,形参x和y的值都是20和10；而a与x的地址、b与y的地址并不相同</span></span><br><span class="line"><span class="comment">表明形参x和y是新建的变量，也即实参a, b是从形参复制了一份</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap_by_value(a, b); <span class="comment">// 值传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*-------------------------分界线1------------------*/</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap_by_pointer(&amp;a, &amp;b); <span class="comment">// 值传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">/*-------------------------分界线2------------------*/</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换前: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    swap_by_reference(a, b); <span class="comment">// 引用传递</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"交换后: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">" ,b = "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_value</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 传指针(地址),实质还是传值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_pointer</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (3) 传引用</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传引用，传递的是实参本身，而不是实参的一个拷贝，形参的修改就是实参的修改,即值相同，地址也相同</span></span><br><span class="line"><span class="comment">相比于传值，传引用的好处是省去了复制，节约了空间和时间。</span></span><br><span class="line"><span class="comment">假如不希望修改变量的值，那么请选择传值而不是传引用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_by_reference</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// (4) 总结</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">“引用”类型变量的声明方式：变量类型 &amp;变量名;   int &amp;b;</span></span><br><span class="line"><span class="comment">“指针”类型的声明方式：基类型 *变量名;  int *pi;</span></span><br><span class="line"><span class="comment">“指针的引用类型”应当这样声明：基类型 *&amp;变量名   int *&amp;pi;</span></span><br><span class="line"><span class="comment">指针类型，也是有传值、传引用两种函数传参方式的：</span></span><br><span class="line"><span class="comment">    1.指针的传值方式</span></span><br><span class="line"><span class="comment">        void my_fun(int *a, int n);</span></span><br><span class="line"><span class="comment">    2.指针的传引用方式</span></span><br><span class="line"><span class="comment">        void my_fun(int *&amp;pi, int n);</span></span><br><span class="line"><span class="comment">// 普通类型，以int a为例</span></span><br><span class="line"><span class="comment">void myfun(int a)    //传值，产生复制</span></span><br><span class="line"><span class="comment">void myfun(int &amp;a)   //传引用，不产生复制</span></span><br><span class="line"><span class="comment">void myfun(int *a)   //传地址，产生复制，本质上是一种传值，这个值是地址</span></span><br><span class="line"><span class="comment">// 指针类型，以int *a为例</span></span><br><span class="line"><span class="comment">void myfun(int *a)   //传值，产生复制</span></span><br><span class="line"><span class="comment">void myfun(int *&amp;a)  //传引用，不产生复制</span></span><br><span class="line"><span class="comment">void myfun(int **a)   //传地址，产生复制，本质上是一种传值，这个值是指针的地址</span></span><br><span class="line"><span class="comment">// 数组类型，以int a[10]为例</span></span><br><span class="line"><span class="comment">void myfun(int a[], int n) //传值，产生复制</span></span><br><span class="line"><span class="comment">void myfun(int* a, int n) //传值，产生复制，传递的数组首地址</span></span><br><span class="line"><span class="comment">void myfun(int (&amp;arr)[10]) //传引用，不产生复制。需要硬编码数组长度</span></span><br><span class="line"><span class="comment">template&lt;size_t size&gt; void myfun(int (&amp;arr)[size]) //传引用，不产生复制。不需要硬编码数组长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="七、参考博客"><a href="#七、参考博客" class="headerlink" title="七、参考博客"></a>七、参考博客</h3><p><a href="http://www.cnblogs.com/zjutzz" target="_blank" rel="noopener">1.Chris的技术博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;指针：指针是一个变量，只不过这个变量中存储的是一个地址，指向内存中的一个单元。&lt;/li&gt;
&lt;li&gt;引用：引用和原变量是同一个东西，只不过是原变量的一个别名。  &lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>常引用、常量指针、指针常量、指向常量的常指针、空指针与野指针解释</title>
    <link href="https://cdlwhm1217096231.github.io/C/%E5%B8%B8%E5%BC%95%E7%94%A8%E3%80%81%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E3%80%81%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E3%80%81%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E5%B8%B8%E6%8C%87%E9%92%88%E3%80%81%E7%A9%BA%E6%8C%87%E9%92%88%E4%B8%8E%E9%87%8E%E6%8C%87%E9%92%88%E8%A7%A3%E9%87%8A/"/>
    <id>https://cdlwhm1217096231.github.io/C/常引用、常量指针、指针常量、指向常量的常指针、空指针与野指针解释/</id>
    <published>2019-08-09T08:05:33.000Z</published>
    <updated>2019-08-09T08:06:20.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、一-基础知识"><a href="#1、一-基础知识" class="headerlink" title="1、一.基础知识"></a>1、一.基础知识</h3><ul><li>引用并非对象</li><li>引用必须初始化</li><li>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起</li><li><p>类型要严格匹配</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;a = <span class="number">10</span>;             <span class="comment">//错误：引用类型的初始值必须是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;              <span class="comment">//错误：此处引用类型的初始值必须是int型对象</span></span><br></pre></td></tr></table></figure></li><li><p>指针本身就是对象</p></li><li>指针的类型要和它指向的对象严格匹配<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"><span class="keyword">double</span> *pd = &amp;dval;      <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">double</span> *pd2 = pd;        <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *pi = pd;            <span class="comment">//错误：指针pi的类型和pd的类型不匹配</span></span><br><span class="line">pi = &amp;dval;              <span class="comment">//错误：试图把double型对象的地址赋给int型指针</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="二-常量引用"><a href="#二-常量引用" class="headerlink" title="二.常量引用"></a>二.常量引用</h3><ul><li>初始化常量引用时允许用任意表达式作为初始值<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;       <span class="comment">//正确：允许将const int &amp; 绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;      <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>;        <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;    <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;</span><br><span class="line">r1 = <span class="number">0</span>;                  <span class="comment">//正确</span></span><br><span class="line">r2 = <span class="number">0</span>;                  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="三-常量指针"><a href="#三-常量指针" class="headerlink" title="三.常量指针"></a>三.常量指针</h3><ul><li>定义： 又叫常指针，可以理解为常量的指针，也即这个是指针，但指向的是个常量，这个常量是指针的值（地址），而不是地址指向的值。</li><li>关键点：<ul><li>1.常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改；</li><li>2.常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值；指针指向的地址可以改变，但指针指向的地址所对应的内容不可以改变</li><li>3.指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；</li></ul></li><li>代码形式：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;  <span class="keyword">const</span> <span class="keyword">int</span>* p;</span><br></pre></td></tr></table></figure></li></ul><h3 id="四-指针常量"><a href="#四-指针常量" class="headerlink" title="四.指针常量"></a>四.指针常量</h3><ul><li>定义：本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。</li><li>关键点：<ul><li>1.指针常量的值是指针，这个值是常量，不能被修改；指向的地址不可以改变，但指向的地址所对应的内容可以改变</li><li>2.指针本身是常量，指针指向的地址不可以变化,但是指针指向的地址所对应的内容可以变化；</li></ul></li><li>代码形式:  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure></li></ul><h3 id="五-指向常量的常指针"><a href="#五-指向常量的常指针" class="headerlink" title="五.指向常量的常指针"></a>五.指向常量的常指针</h3><ul><li>定义：指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。</li><li>关键点：<ul><li>1.一个指针常量，指向的是一个指针对象；</li><li>2.它指向的指针对象且是一个常量，即它指向的对象不能变化；</li></ul></li><li>代码形式：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p;</span><br></pre></td></tr></table></figure></li></ul><h3 id="六-那如何区分这几类呢"><a href="#六-那如何区分这几类呢" class="headerlink" title="六.那如何区分这几类呢?"></a>六.那如何区分这几类呢?</h3><ul><li><p>带两个const的肯定是指向常量的常指针，很容易理解，主要是如何区分常量指针和指针常量.</p><ul><li><p>一种方式是看 * 和 const 的排列顺序，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;    <span class="comment">//const * 即常量指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;    <span class="comment">//const * 即常量指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;    <span class="comment">//* const 即指针常量</span></span><br></pre></td></tr></table></figure></li><li><p>还一种方式是看const离谁近，即从右往左看，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p;    <span class="comment">//const修饰的是*p，即*p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改；</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p;    <span class="comment">//同上</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p;    <span class="comment">//const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------常量指针-------</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;a;</span><br><span class="line">a = <span class="number">300</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line"><span class="comment">//*p1 = 56;  //Error,*p1是const int的，不可修改，即常量指针不可修改其指向地址</span></span><br><span class="line">p1 = &amp;b;     <span class="comment">//OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针常量-------//</span></span><br><span class="line"><span class="keyword">int</span>*  <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">a = <span class="number">500</span>;     <span class="comment">//OK,仍然可以通过原来的声明修改值，</span></span><br><span class="line">*p2 = <span class="number">400</span>;   <span class="comment">//OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</span></span><br><span class="line"><span class="comment">//p2 = &amp;b;     //Error,因为p2是const 指针，因此不能改变p2指向的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指向常量的常量指针-------//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">//*p3 = 1;    //Error</span></span><br><span class="line"><span class="comment">//p3 = &amp;b;    //Error</span></span><br><span class="line">a = <span class="number">5000</span>;    <span class="comment">//OK,仍然可以通过原来的声明修改值</span></span><br></pre></td></tr></table></figure></li><li><p>在实际应用中，常量指针要比指针常量用的多，比如常量指针经常用在函数传参中，以避免函数内部修改内容。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>* src); <span class="comment">//常量指针，src的值不可改变；</span></span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> b[] = <span class="string">"world"</span>;</span><br><span class="line"><span class="keyword">size_t</span> a1 = <span class="built_in">strlen</span>(a);</span><br><span class="line"><span class="keyword">size_t</span> b1 = <span class="built_in">strlen</span>(b);</span><br><span class="line">虽然a、b是可以修改的，但是可以保证在<span class="built_in">strlen</span>函数内部不会修改a、b的内容。</span><br></pre></td></tr></table></figure></li></ul><h3 id="七-空指针与野指针"><a href="#七-空指针与野指针" class="headerlink" title="七.空指针与野指针"></a>七.空指针与野指针</h3><ul><li>空指针就是保存地址为空的指针，使用指针时必须先判断是否空指针，很多问题都是这一步导致的。</li><li>野指针是在delete掉指针之后，没有置0，导致指针随意指向了一个内存地址，如果继续使用，会造成不可预知的内存错误。另外指针的误用很容易造成BUG或者内存泄漏。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------空指针-------//</span></span><br><span class="line"><span class="keyword">int</span> *p4 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//printf("%d",*p4); //运行Error，使用指针时必须先判断是否空指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------野指针（悬浮、迷途指针）-------//</span></span><br><span class="line"><span class="keyword">int</span> *p5 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">delete</span> p5;</span><br><span class="line">p5 = <span class="literal">NULL</span>; <span class="comment">//一定要有这一步</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*p5);  <span class="comment">//隐藏bug，delete掉指针后一定要置0，不然指针指向位置不可控，运行中可导致系统挂掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-------指针的内存泄漏-------//</span></span><br><span class="line"><span class="keyword">int</span> *p6 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">6</span>);</span><br><span class="line">p6 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">7</span>); <span class="comment">//p6原本指向的那块内存尚未释放，结果p6又指向了别处，原来new的内存无法访问，也无法delete了，造成memory leak</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="八-参考资料"><a href="#八-参考资料" class="headerlink" title="八.参考资料"></a>八.参考资料</h3><ul><li><a href="http://www.runoob.com/w3cnote/c-constant-pointer.html" target="_blank" rel="noopener">1.菜鸟教程</a></li><li><a href="http://www.cnblogs.com/lizhenghn/p/3630405.html" target="_blank" rel="noopener">2.C++中指针常量和常量指针的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、一-基础知识&quot;&gt;&lt;a href=&quot;#1、一-基础知识&quot; class=&quot;headerlink&quot; title=&quot;1、一.基础知识&quot;&gt;&lt;/a&gt;1、一.基础知识&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;引用并非对象&lt;/li&gt;
&lt;li&gt;引用必须初始化&lt;/li&gt;
&lt;li&gt;引用只能绑定在
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++实现斐波那契数列</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-实现斐波那契数列/</id>
    <published>2019-08-09T08:00:45.000Z</published>
    <updated>2019-08-09T08:01:40.590Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归方法和循环方法的对比</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">递归方法代码实现比较简洁，但是性能不如循环方法，还会出现栈溢出的问题，优先采用递归的方法！</span></span><br><span class="line"><span class="comment">搜索路径的题目：一般使用回溯法，回溯法很适合使用递归方法的代码来实现！当要求不能使用递归实现的时候，考虑使用栈模拟递归的过程</span></span><br><span class="line"><span class="comment">求某个问题的最优解时，并且该问题可以拆分为多个子问题时：可以尝试使用动态规划的方法！在使用自上而下的递归思路去分析动态规划问题时，会发现子问题之间存在重叠</span></span><br><span class="line"><span class="comment">的更小的子问题。为了避免不必要的重复计算，使用自下而上的循环代码来实现，即把子问题的最优解先计算出来并用数组保存下来，然后基于子问题的解计算大问题的解。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特殊情况：在分解子问题的时候存在某个特殊的选择，采用这个特殊的选择将一定那个得到最优解，则此题目可能适用于贪心算法！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FibByRecursive</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> FibByRecursive(n<span class="number">-1</span>) + FibByRecursive(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环方法实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> first=<span class="number">0</span>, second=<span class="number">1</span>, third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            second = first;</span><br><span class="line">            third = second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的文件读写操作(4)</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-4/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的文件读写操作-4/</id>
    <published>2019-08-09T08:00:03.000Z</published>
    <updated>2019-08-09T08:00:23.616Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sstream"</span>    <span class="comment">// 使用istringstream所需要的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">string头文件定义了三个类型来支持内存IO:</span></span><br><span class="line"><span class="comment">    istringstream向string读取数据</span></span><br><span class="line"><span class="comment">    ostringstrream向string写入数据</span></span><br><span class="line"><span class="comment">    stringstream既可以从string读数据也可以向string写数据，就像string是一个IO流一样</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// istringstream的用法如下</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"hello world! I am Lee."</span>;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(is &gt;&gt; s)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的文件读写操作(3)</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-3/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的文件读写操作-3/</id>
    <published>2019-08-09T07:58:51.000Z</published>
    <updated>2019-08-09T07:59:40.615Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 如果源文件中的每行数据数量不一样，demo2中的方法就不行了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Num_3, Num_2;</span><br><span class="line">    <span class="keyword">int</span> v, w, weight;</span><br><span class="line">    ifstream infile;  <span class="comment">// 读操作,输入流</span></span><br><span class="line">    ofstream outfile; <span class="comment">// 写操作，输出流</span></span><br><span class="line">    infile.open(<span class="string">"E:\\C++\\cpp_Code\\data1.txt"</span>, ios::in);</span><br><span class="line">    <span class="keyword">if</span> (!infile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件操作失败...\n"</span>;</span><br><span class="line">    infile &gt;&gt; Num_3 &gt;&gt; Num_2;  <span class="comment">// 先读取第一行</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>!=Num_3)&#123;  <span class="comment">// 读取第3个数据</span></span><br><span class="line">        infile &gt;&gt; v &gt;&gt; w &gt;&gt; weight;</span><br><span class="line">        cost[v][w] = weight;</span><br><span class="line">        cost[w][v] = weight;</span><br><span class="line">        Num_3--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>!=Num_2)&#123;  <span class="comment">// 读取第2个数据</span></span><br><span class="line">        infile &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        cost[v][w] = <span class="number">100</span>;</span><br><span class="line">        cost[w][v] = <span class="number">100</span>;</span><br><span class="line">        Num_2--;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    outfile.open(<span class="string">"E:\\C++\\cpp_Code\\result1.txt"</span>, ios::out);</span><br><span class="line">    <span class="keyword">if</span>(!outfile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败\n"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">10</span>;j++)&#123;</span><br><span class="line">            outfile &lt;&lt; i &lt;&lt; <span class="string">"\t"</span> &lt;&lt; j &lt;&lt; <span class="string">"\t"</span> &lt;&lt; cost[i][j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的文件读写操作(2)</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-2/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的文件读写操作-2/</id>
    <published>2019-08-09T07:57:52.000Z</published>
    <updated>2019-08-09T07:58:30.591Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// demo1中是向文件中写入string类型，下面是向文件中写入int类型</span></span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v, w, weight;</span><br><span class="line">    ifstream infile;  <span class="comment">// 读操作</span></span><br><span class="line">    ofstream outfile;  <span class="comment">// 写操作</span></span><br><span class="line">    infile.open(<span class="string">"E:\\C++\\cpp_Code\\data.txt"</span>, ios::in);</span><br><span class="line">    <span class="keyword">if</span> (! infile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(!infile.eof())&#123;</span><br><span class="line">        infile &gt;&gt; v &gt;&gt; w &gt;&gt; weight;</span><br><span class="line">        cost[v][w] = weight;</span><br><span class="line">        cost[w][v] = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line"></span><br><span class="line">    outfile.open(<span class="string">"E:\\C++\\cpp_Code\\result.txt"</span>, ios::app);</span><br><span class="line">    <span class="keyword">if</span>(!outfile.is_open())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败...."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i!=<span class="number">10</span>;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j!=<span class="number">10</span>;++j)&#123;</span><br><span class="line">            outfile &lt;&lt; i &lt;&lt; <span class="string">"\t"</span> &lt;&lt; j &lt;&lt; <span class="string">"\t"</span> &lt;&lt; cost[i][j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++中的文件读写操作(1)</title>
    <link href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C-1/"/>
    <id>https://cdlwhm1217096231.github.io/C/C-中的文件读写操作-1/</id>
    <published>2019-08-09T07:55:56.000Z</published>
    <updated>2019-08-09T07:56:47.424Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fstream"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"vector"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">ofstream  文件写操作，内存写入存储设备</span></span><br><span class="line"><span class="comment">ifstream  文件读操作，存储设备读取到内存中</span></span><br><span class="line"><span class="comment">fstream   读写操作，对打开的文件可进行读写操作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">文件打开模式：</span></span><br><span class="line"><span class="comment">    ios::in   只读</span></span><br><span class="line"><span class="comment">    ios::out  只写</span></span><br><span class="line"><span class="comment">    ios::app  从文件末尾开始写，防止丢失文本中原有的内容，追加模式</span></span><br><span class="line"><span class="comment">    ios::binary 二进制模式</span></span><br><span class="line"><span class="comment">    ios::nocreate 打开一个文件时，如果文件不存在，不创建</span></span><br><span class="line"><span class="comment">    ios::noreplace 打开一个文件时，如果文件不存在，创建该文件</span></span><br><span class="line"><span class="comment">    ios::trunc   打开一个文件时，然后清空内容</span></span><br><span class="line"><span class="comment">    ios::ate     打开一个文件时，将位置移动到文件末尾</span></span><br><span class="line"><span class="comment">文件指针位置的C++中的用法：</span></span><br><span class="line"><span class="comment">    ios::beg   文件开头</span></span><br><span class="line"><span class="comment">    ios::end   文件末尾</span></span><br><span class="line"><span class="comment">    ios::cur   文件当前位置</span></span><br><span class="line"><span class="comment">    举个例子：</span></span><br><span class="line"><span class="comment">        file.seekg(0, ios::beg)  让文件指针定位到文件开头</span></span><br><span class="line"><span class="comment">        file.seekg(0, ios::end)  让文件指针定位到文件末尾</span></span><br><span class="line"><span class="comment">        file.seekg(10, ios::cur) 让文件指针从当前位置向文件末尾方向移动10个字节</span></span><br><span class="line"><span class="comment">        file.seekg(-10, ios::cur) 让文件指针从当前位置向文件开始方向移动10个字节</span></span><br><span class="line"><span class="comment">        file.seekg(10,ios::beg)   让文件指针定位到离文件开头10个字节的位置</span></span><br><span class="line"><span class="comment">常用的错误判断方法:</span></span><br><span class="line"><span class="comment">    good()   如果文件打开成功</span></span><br><span class="line"><span class="comment">    bad()    打开文件时发生错误</span></span><br><span class="line"><span class="comment">    eof()    到达文件尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取hello.txt文件中的字符串，写入out.txt中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"E:\\C++\\cpp_Code\\hello.txt"</span>)</span></span>;  <span class="comment">// 读操作</span></span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"E:\\C++\\cpp_Code\\out.txt"</span>)</span></span>;   <span class="comment">// 写操作</span></span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(! infile.is_open())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"打开文件失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(getline(infile, temp))&#123;  </span><br><span class="line">        outfile &lt;&lt; temp;</span><br><span class="line">        outfile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">getline()函数的作用：从输入字节流中读入字符，存到string变量中</span></span><br><span class="line"><span class="comment">直到遇到下面的情况停止：</span></span><br><span class="line"><span class="comment">    读入了文件结束标志</span></span><br><span class="line"><span class="comment">    读到一个新行</span></span><br><span class="line"><span class="comment">    达到字符串的最大穿长度</span></span><br><span class="line"><span class="comment">    如果getline没有读入字符，将返回false，用于判断文件是否结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
      <category term="C++" scheme="https://cdlwhm1217096231.github.io/categories/C/"/>
    
    
      <category term="编程语言" scheme="https://cdlwhm1217096231.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>复习07统计学习方法(支持向量机SVM)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A007%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习07统计学习方法-支持向量机SVM-图片版/</id>
    <published>2019-08-08T09:19:10.000Z</published>
    <updated>2019-08-08T09:19:38.978Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-e4c4763e681374ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-c1ff663b44869d2d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-de40ae539a1594b9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-06a7b0733b4a897f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-9e0578690b11ea48.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-e4c4763e681374ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习06统计学习方法(Logistic回归与最大熵模型)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A006%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-Logistic%E5%9B%9E%E5%BD%92%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习06统计学习方法-Logistic回归与最大熵模型-图片版/</id>
    <published>2019-08-08T09:18:28.000Z</published>
    <updated>2019-08-08T09:18:51.537Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-23330af289b7990d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-c546a04832004463.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-43f59ed14e078287.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-f62301a284aa666e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-23330af289b7990d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习05统计学习方法(决策树算法Decision Tree)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A005%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95Decision-Tree-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习05统计学习方法-决策树算法Decision-Tree-图片版/</id>
    <published>2019-08-08T09:17:29.000Z</published>
    <updated>2019-08-08T09:18:03.467Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-949bf3d21a6cd513.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-89551868a0657f58.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-db3b56affe58f09f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-fb1b2f4fd7c44637.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/13407176-15c3694d44fe89d9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图5.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-949bf3d21a6cd513.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习04统计学习方法(朴素贝叶斯算法Naive Bayes)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A004%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95Naive-Bayes-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习04统计学习方法-朴素贝叶斯算法Naive-Bayes-图片版/</id>
    <published>2019-08-08T09:16:37.000Z</published>
    <updated>2019-08-08T09:17:08.698Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-6db2674e97151f85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"><br><img src="https://upload-images.jianshu.io/upload_images/13407176-9ca54696ca36e9db.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-6db2674e97151f85.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复习03统计学习方法(K近邻算法KNN)---图片版</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%8D%E4%B9%A003%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95KNN-%E5%9B%BE%E7%89%87%E7%89%88/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/复习03统计学习方法-K近邻算法KNN-图片版/</id>
    <published>2019-08-08T09:15:49.000Z</published>
    <updated>2019-08-08T09:16:18.163Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/13407176-a32e76e75c8fe185.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="KNN"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13407176-a32e76e75c8fe185.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>常见的距离函数总结</title>
    <link href="https://cdlwhm1217096231.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>https://cdlwhm1217096231.github.io/机器学习/常见的距离函数总结/</id>
    <published>2019-08-08T09:14:30.000Z</published>
    <updated>2019-08-08T09:37:55.424Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-距离函数总结"><a href="#1-距离函数总结" class="headerlink" title="1.距离函数总结"></a>1.距离函数总结</h4><ul><li><strong>闵可夫斯基距离</strong>：<script type="math/tex; mode=display">\text { distance( }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left(\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{p}\right)^{1 / p}</script></li><li>当p=2时，闵可夫斯基距离就是<strong>欧式距离</strong>：<script type="math/tex; mode=display">\operatorname{distance}\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{2}=\sqrt{\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|^{2}}</script></li><li>当p=1时，闵可夫斯基距离就是<strong>曼哈顿距离</strong>：<script type="math/tex; mode=display">\text { distance }\left(\overrightarrow{\mathbf{x}}_{i}, \overrightarrow{\mathbf{x}}_{j}\right)=\left\|\overrightarrow{\mathbf{x}}_{i}-\overrightarrow{\mathbf{x}}_{j}\right\|_{1}=\sum_{d=1}^{n}\left|x_{i, d}-x_{j, d}\right|</script></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-距离函数总结&quot;&gt;&lt;a href=&quot;#1-距离函数总结&quot; class=&quot;headerlink&quot; title=&quot;1.距离函数总结&quot;&gt;&lt;/a&gt;1.距离函数总结&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;闵可夫斯基距离&lt;/strong&gt;：&lt;script type=&quot;m
      
    
    </summary>
    
      <category term="机器学习" scheme="https://cdlwhm1217096231.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://cdlwhm1217096231.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="算法" scheme="https://cdlwhm1217096231.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
